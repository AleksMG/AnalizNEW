                        <!DOCTYPE html>
                        <html lang="en">
                        <head>
                            <meta charset="UTF-8">
                            <meta name="viewport" content="width=device-width, initial-scale=1.0">
              <style>
                body {
                  background-color: white; /* Ensure the iframe has a white background */
                }

                
              </style>
                        </head>
                        <body>
                            <!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; connect-src 'self'; img-src 'self'; font-src 'self';">
    <meta name="description" content="AI Arena v4.1.0 Professional ‚Äî Multi-Agent Neural Architecture with TD(Œª)+Actor-Critic+MoE+Hebbian+SocialDynamics">
    <meta name="theme-color" content="#0a0a15">
    <meta name="robots" content="noindex">
    <title>üéÆ AI Arena v4.1.0 PROFESSIONAL ‚Äî Neural Architecture Complete</title>
    <style>
        /* ========================================================================
           AI ARENA v4.1.0 ‚Äî PROFESSIONAL CSS COMPLETE
           GitHub Pages compatible ‚Ä¢ Responsive ‚Ä¢ Accessible ‚Ä¢ Performant
           ======================================================================== */
        :root {
            /* Core color palette */
            --bg: #0a0a15;
            --bg-gradient-start: #0a0a15;
            --bg-gradient-end: #1a1a2e;
            --panel: #121225;
            --panel-alpha: rgba(18, 18, 37, 0.95);
            --text: #e0e0ff;
            --text-dim: #b0b0d0;
            --text-muted: #707090;
            --primary: #00f2ff;
            --primary-dark: #00c4d4;
            --accent: #ff0066;
            --success: #00ff9d;
            --warning: #ffaa00;
            --danger: #ff4444;
            --border: #2a2a45;
            --border-light: #3a3a5a;
            --purple: #aa88ff;
            --yellow: #ffdd44;
            --pink: #ff66cc;
            --cyan: #00d4ff;
            --orange: #ff8844;
            --green: #44ff44;
            --blue: #4444ff;
            --red: #ff4444;
            
            /* Stat colors */
            --stat-str: #ff4444;
            --stat-spd: #4444ff;
            --stat-hp: #44ff44;
            --stat-dod: #aa88ff;
            --stat-heal: #00ff9d;
            --stat-int: #aa88ff;
            
            /* Learning indicators */
            --learning-good: #00ff9d;
            --learning-bad: #ff5577;
            --learning-neutral: #ffaa00;
            
            /* Mode badge backgrounds */
            --mode-hunt-bg: rgba(0, 255, 157, 0.15);
            --mode-hunt-text: #00ff9d;
            --mode-flee-bg: rgba(255, 85, 119, 0.15);
            --mode-flee-text: #ff5577;
            --mode-explore-bg: rgba(0, 212, 255, 0.15);
            --mode-explore-text: #00d4ff;
            --mode-combat-bg: rgba(255, 170, 0, 0.15);
            --mode-combat-text: #ffaa00;
            --mode-avoid-bg: rgba(170, 136, 255, 0.15);
            --mode-avoid-text: #aa88ff;
            --mode-protect-bg: rgba(68, 255, 68, 0.15);
            --mode-protect-text: #44ff44;
            --mode-heal-bg: rgba(0, 255, 157, 0.15);
            --mode-heal-text: #00ff9d;
            
            /* Layout constants */
            --sidebar-width: 480px;
            --header-height: 48px;
            --panel-radius: 12px;
            --btn-radius: 8px;
            --input-radius: 6px;
            --card-radius: 10px;
            
            /* Transitions */
            --transition-fast: 150ms ease;
            --transition-normal: 250ms ease;
            --transition-slow: 400ms ease;
            
            /* Shadows */
            --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.3);
            --shadow-md: 0 4px 8px rgba(0, 0, 0, 0.4);
            --shadow-lg: 0 8px 24px rgba(0, 0, 0, 0.5);
            
            /* Z-index layers */
            --z-canvas: 1;
            --z-sidebar: 10;
            --z-header: 100;
            --z-modal: 1000;
        }
        
        /* Fallback for browsers without CSS variables */
        @supports not (--css: variables) {
            body { background: #0a0a15; color: #e0e0ff; }
            .sidebar { background: #121225; }
            .panel { background: rgba(0, 0, 0, 0.3); border-color: #2a2a45; }
            :root { --text-dim: #b0b0d0; --border-light: #3a3a5a; }
        }
        
        /* Reset & Base */
        *, *::before, *::after {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html {
            font-size: 16px;
            -webkit-text-size-adjust: 100%;
            -ms-text-size-adjust: 100%;
            scroll-behavior: smooth;
        }
        
        body {
            background: var(--bg);
            background: linear-gradient(135deg, var(--bg-gradient-start) 0%, var(--bg-gradient-end) 100%);
            color: var(--text);
            font-family: 'Segoe UI', system-ui, -apple-system, BlinkMacSystemFont, 'Helvetica Neue', sans-serif;
            font-size: 0.875rem;
            line-height: 1.4;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
            -ms-user-select: none;
            touch-action: manipulation;
            text-rendering: optimizeLegibility;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        
        /* Accessibility: Focus indicators */
        :focus-visible {
            outline: 2px solid var(--primary);
            outline-offset: 2px;
        }
        
        button:focus-visible,
        input:focus-visible,
        select:focus-visible,
        [tabindex]:focus-visible,
        [role="button"]:focus-visible {
            outline: 2px solid var(--primary);
            outline-offset: 2px;
            box-shadow: 0 0 0 4px rgba(0, 242, 255, 0.2);
        }
        
        /* Skip link for keyboard users */
        .skip-link {
            position: absolute;
            top: -40px;
            left: 0;
            background: var(--primary);
            color: #000;
            padding: 0.5rem 1rem;
            z-index: var(--z-modal);
            transition: top var(--transition-fast);
        }
        .skip-link:focus { top: 0; }
        
        /* Layout */
        .container {
            display: grid;
            grid-template-columns: 1fr var(--sidebar-width);
            grid-template-rows: var(--header-height) 1fr;
            grid-template-areas: "header header" "canvas sidebar";
            height: 100vh;
            min-height: 100vh;
            width: 100vw;
            min-width: 100vw;
            position: relative;
        }
        
        /* Header */
        .header {
            grid-area: header;
            background: var(--panel);
            border-bottom: 1px solid var(--border);
            padding: 0.5rem 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: var(--z-header);
            box-shadow: var(--shadow-sm);
            position: relative;
        }
        
        .header h1 {
            font-size: 1rem;
            font-weight: 700;
            color: var(--primary);
            display: flex;
            align-items: center;
            gap: 0.5rem;
            letter-spacing: 0.5px;
            margin: 0;
        }
        
        .version-badge {
            background: var(--accent);
            color: #fff;
            padding: 0.125rem 0.375rem;
            border-radius: 0.25rem;
            font-size: 0.625rem;
            font-weight: 600;
            letter-spacing: 0.5px;
            display: inline-flex;
            align-items: center;
        }
        
        .fps-counter {
            font-family: 'Courier New', Consolas, monospace;
            color: var(--success);
            font-weight: 700;
            font-size: 0.875rem;
            background: rgba(0, 255, 157, 0.1);
            padding: 0.25rem 0.5rem;
            border-radius: 0.375rem;
            border: 1px solid rgba(0, 255, 157, 0.3);
            min-width: 70px;
            text-align: center;
        }
        
        /* Canvas */
        #gameCanvas {
            grid-area: canvas;
            width: 100%;
            height: 100%;
            display: block;
            cursor: crosshair;
            touch-action: none;
            -webkit-tap-highlight-color: transparent;
            position: relative;
            z-index: var(--z-canvas);
        }
        
        /* Sidebar */
        .sidebar {
            grid-area: sidebar;
            background: var(--panel);
            border-left: 1px solid var(--border);
            padding: 0.625rem;
            overflow-y: auto;
            overflow-x: hidden;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            scrollbar-width: thin;
            scrollbar-color: var(--border) var(--bg);
            z-index: var(--z-sidebar);
            position: relative;
        }
        
        .sidebar::-webkit-scrollbar { width: 0.25rem; }
        .sidebar::-webkit-scrollbar-track { background: var(--bg); }
        .sidebar::-webkit-scrollbar-thumb { background: var(--border); border-radius: 0.125rem; }
        
        /* Panels */
        .panel {
            background: var(--panel-alpha);
            border: 1px solid var(--border);
            border-radius: var(--panel-radius);
            padding: 0.5rem;
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
            position: relative;
        }
        
        .panel-title {
            color: var(--primary);
            font-size: 0.75rem;
            font-weight: 700;
            margin-bottom: 0.375rem;
            display: flex;
            align-items: center;
            gap: 0.3125rem;
            padding-bottom: 0.25rem;
            border-bottom: 1px solid var(--border);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        /* Stats Grid */
        .stat-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.25rem;
        }
        
        .stat {
            background: rgba(0, 0, 0, 0.2);
            padding: 0.25rem 0.375rem;
            border-radius: 0.375rem;
            font-size: 0.625rem;
            border: 1px solid transparent;
            transition: border-color var(--transition-fast), background var(--transition-fast);
        }
        
        .stat:hover { border-color: var(--border-light); background: rgba(0, 0, 0, 0.25); }
        
        .stat-label { color: var(--text-dim); display: block; margin-bottom: 0.0625rem; font-size: 0.5625rem; }
        
        .stat-value {
            color: var(--primary);
            font-weight: 700;
            font-family: 'Courier New', Consolas, monospace;
            font-size: 0.6875rem;
        }
        
        .stat-value.good { color: var(--success); }
        .stat-value.bad { color: var(--danger); }
        .stat-value.warn { color: var(--warning); }
        .stat-value.learning { color: var(--learning-good); }
        
        /* Controls */
        .control-group { margin-bottom: 0.375rem; }
        
        .control-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.6875rem;
            margin-bottom: 0.125rem;
            color: var(--text-dim);
        }
        
        input[type="range"],
        input[type="number"],
        select {
            width: 100%;
            padding: 0.25rem;
            background: var(--border);
            border: 1px solid var(--border-light);
            border-radius: var(--input-radius);
            color: var(--text);
            font-size: 0.6875rem;
            outline: none;
            cursor: pointer;
        }
        
        input[type="range"] {
            height: 0.25rem;
            background: var(--border);
            border-radius: 0.125rem;
            appearance: none;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 0.75rem;
            height: 0.75rem;
            background: var(--primary);
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid var(--bg);
            transition: transform var(--transition-fast), background var(--transition-fast);
        }
        
        input[type="range"]::-webkit-slider-thumb:hover { transform: scale(1.1); background: #fff; }
        input[type="range"]::-moz-range-thumb {
            width: 0.75rem;
            height: 0.75rem;
            background: var(--primary);
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid var(--bg);
        }
        
        /* Buttons */
        .btn-group { display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.25rem; margin-top: 0.25rem; }
        .btn-group-3 { display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.25rem; margin-top: 0.25rem; }
        .btn-group-4 { display: grid; grid-template-columns: repeat(4, 1fr); gap: 0.25rem; margin-top: 0.25rem; }
        
        button {
            padding: 0.375rem 0.5rem;
            border: none;
            border-radius: var(--btn-radius);
            font-weight: 700;
            cursor: pointer;
            font-size: 0.6875rem;
            transition: all var(--transition-fast);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.25rem;
            background: var(--border);
            color: var(--text);
            position: relative;
            overflow: hidden;
            min-height: 2rem;
        }
        
        button::before {
            content: '';
            position: absolute;
            top: 0; left: -100%;
            width: 100%; height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
            transition: left 0.3s ease;
            pointer-events: none;
        }
        
        button:hover::before { left: 100%; }
        button:active { transform: translateY(1px); }
        button:disabled { opacity: 0.5; cursor: not-allowed; transform: none; pointer-events: none; }
        
        .btn-primary { background: var(--primary); color: #000; }
        .btn-primary:hover:not(:disabled) { background: #fff; box-shadow: 0 0 0 2px var(--primary-dark); }
        .btn-danger { background: var(--danger); color: #fff; }
        .btn-danger:hover:not(:disabled) { background: #ff6666; box-shadow: 0 0 0 2px #ff2222; }
        .btn-success { background: var(--success); color: #000; }
        .btn-success:hover:not(:disabled) { background: #66ffcc; box-shadow: 0 0 0 2px #00cc7d; }
        .btn-secondary { background: var(--border); color: var(--text); }
        .btn-secondary:hover:not(:disabled) { background: var(--border-light); }
        .btn-toggle { background: var(--border); color: var(--text); }
        .btn-toggle.active { background: var(--accent); color: #fff; box-shadow: 0 0 0 2px var(--accent); }
        .btn-learning { background: var(--purple); color: #fff; }
        .btn-learning:hover:not(:disabled) { background: #cc88ff; box-shadow: 0 0 0 2px #8855ff; }
        .btn-professional { background: linear-gradient(135deg, var(--primary), var(--purple)); color: #000; font-weight: 800; }
        .btn-professional:hover:not(:disabled) { background: linear-gradient(135deg, #fff, #cc88ff); box-shadow: 0 0 0 2px var(--primary); }
        
        /* Toggles */
        .toggle {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            font-size: 0.6875rem;
            margin-bottom: 0.1875rem;
            color: var(--text-dim);
            cursor: pointer;
            user-select: none;
            padding: 0.125rem 0;
        }
        
        .toggle input { accent-color: var(--primary); width: 0.875rem; height: 0.875rem; cursor: pointer; margin: 0; }
        .toggle:hover { color: var(--text); }
        
        /* Log */
        .log {
            background: #000;
            border: 1px solid var(--border);
            border-radius: 0.5rem;
            padding: 0.375rem;
            height: 5.625rem;
            overflow-y: auto;
            font-size: 0.5625rem;
            font-family: 'Courier New', Consolas, monospace;
            word-break: break-word;
            white-space: pre-wrap;
            max-width: 100%;
            scrollbar-width: thin;
        }
        
        .log::-webkit-scrollbar { width: 0.25rem; }
        .log::-webkit-scrollbar-thumb { background: var(--border); border-radius: 0.125rem; }
        
        .log-entry { margin-bottom: 0.125rem; padding-bottom: 0.125rem; border-bottom: 1px solid #111; line-height: 1.3; }
        .log-entry:last-child { border-bottom: none; margin-bottom: 0; padding-bottom: 0; }
        
        .log-entry.info { color: var(--primary); }
        .log-entry.success { color: var(--success); }
        .log-entry.warn { color: var(--warning); }
        .log-entry.error { color: var(--danger); }
        .log-entry.learning { color: var(--learning-good); }
        .log-entry.social { color: var(--purple); }
        
        /* Progress bars */
        .progress-bar {
            height: 0.25rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 0.1875rem;
            overflow: hidden;
            margin-top: 0.1875rem;
            position: relative;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), var(--success));
            transition: width var(--transition-normal);
            will-change: width;
            position: relative;
        }
        
        .progress-fill::after {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            animation: shimmer 2s infinite;
        }
        
        @keyframes shimmer { 0% { transform: translateX(-100%); } 100% { transform: translateX(100%); } }
        
        /* Agent legend */
        .agent-legend { display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.1875rem; margin-top: 0.25rem; }
        .legend-item { display: flex; align-items: center; gap: 0.25rem; font-size: 0.5625rem; }
        .legend-color { width: 0.5rem; height: 0.5rem; border-radius: 0.125rem; flex-shrink: 0; border: 1px solid rgba(255,255,255,0.2); }
        
        /* Agent cards */
        .agent-card {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
            padding: 0.375rem;
            background: rgba(0, 0, 0, 0.2);
            border-radius: var(--card-radius);
            margin-bottom: 0.375rem;
            border-left: 3px solid transparent;
            transition: border-left-color var(--transition-fast), background var(--transition-fast);
        }
        
        .agent-card:hover { background: rgba(0, 0, 0, 0.25); }
        .agent-card.blue { border-left-color: var(--primary); }
        .agent-card.red { border-left-color: var(--accent); }
        .agent-card.green { border-left-color: var(--green); }
        .agent-card.yellow { border-left-color: var(--warning); }
        .agent-card.purple { border-left-color: var(--purple); }
        .agent-card.pink { border-left-color: var(--pink); }
        .agent-card.orange { border-left-color: var(--orange); }
        
        .agent-header { display: flex; align-items: center; gap: 0.25rem; font-size: 0.6875rem; font-weight: 600; }
        
        .health-bar {
            height: 0.1875rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 0.125rem;
            overflow: hidden;
            position: relative;
        }
        
        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--success), var(--primary));
            transition: width var(--transition-fast);
            will-change: width;
        }
        
        .health-fill.low { background: linear-gradient(90deg, var(--danger), var(--warning)); }
        
        .agent-stats {
            display: flex;
            justify-content: space-between;
            font-size: 0.5625rem;
            color: var(--text-dim);
            flex-wrap: wrap;
            gap: 0.125rem;
        }
        
        .agent-stats b { color: var(--text); font-weight: 600; }
        
        .stat-badge {
            display: inline-flex;
            align-items: center;
            padding: 0.0625rem 0.1875rem;
            border-radius: 0.125rem;
            font-size: 0.5rem;
            font-weight: 600;
            margin-right: 0.125rem;
            border: 1px solid transparent;
        }
        
        .stat-badge.stat-hp { background: rgba(68, 255, 68, 0.15); color: var(--stat-hp); border-color: var(--stat-hp); }
        .stat-badge.stat-str { background: rgba(255, 68, 68, 0.15); color: var(--stat-str); border-color: var(--stat-str); }
        .stat-badge.stat-spd { background: rgba(68, 68, 255, 0.15); color: var(--stat-spd); border-color: var(--stat-spd); }
        .stat-badge.stat-dod { background: rgba(170, 136, 255, 0.15); color: var(--stat-dod); border-color: var(--stat-dod); }
        .stat-badge.stat-heal { background: rgba(0, 255, 157, 0.15); color: var(--stat-heal); border-color: var(--stat-heal); }
        
        /* Skills display */
        .skills-display { display: grid; grid-template-columns: repeat(5, 1fr); gap: 0.125rem; margin-top: 0.1875rem; }
        .skill-item { text-align: center; font-size: 0.5rem; }
        .skill-bar { height: 0.125rem; background: rgba(0, 0, 0, 0.3); border-radius: 0.0625rem; margin-top: 0.0625rem; overflow: hidden; position: relative; }
        .skill-fill { height: 100%; transition: width var(--transition-normal); will-change: width; }
        .skill-hunt .skill-fill { background: var(--success); }
        .skill-flee .skill-fill { background: var(--danger); }
        .skill-combat .skill-fill { background: var(--warning); }
        .skill-explore .skill-fill { background: var(--primary); }
        .skill-avoid .skill-fill { background: var(--purple); }
        
        /* Confidence meter */
        .confidence-meter { display: flex; align-items: center; gap: 0.1875rem; margin-top: 0.1875rem; font-size: 0.5625rem; }
        .confidence-bar { flex: 1; height: 0.1875rem; background: rgba(0, 0, 0, 0.3); border-radius: 0.125rem; overflow: hidden; position: relative; }
        .confidence-fill { height: 100%; background: linear-gradient(90deg, var(--danger), var(--warning), var(--success)); transition: width var(--transition-fast); will-change: width; }
        
        /* Learning metrics */
        .learning-metrics { display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.1875rem; margin-top: 0.25rem; }
        .metric-item { background: rgba(0, 0, 0, 0.2); padding: 0.1875rem 0.25rem; border-radius: 0.25rem; font-size: 0.5rem; transition: background var(--transition-fast); }
        .metric-item:hover { background: rgba(0, 0, 0, 0.25); }
        .metric-label { color: var(--text-dim); display: block; font-size: 0.4375rem; }
        .metric-value { color: var(--learning-good); font-weight: 600; font-family: 'Courier New', monospace; }
        .metric-value.degrading { color: var(--danger); }
        
        /* Learning progress */
        .learning-progress { display: flex; flex-direction: column; gap: 0.125rem; margin-top: 0.25rem; }
        .progress-row { display: flex; align-items: center; gap: 0.25rem; font-size: 0.5rem; }
        .progress-label { width: 4.375rem; color: var(--text-dim); flex-shrink: 0; }
        .progress-track { flex: 1; height: 0.1875rem; background: rgba(0, 0, 0, 0.3); border-radius: 0.125rem; overflow: hidden; position: relative; }
        .progress-track.td .progress-fill { background: linear-gradient(90deg, var(--danger), var(--warning), var(--success)); }
        .progress-track.entropy .progress-fill { background: linear-gradient(90deg, var(--warning), var(--primary)); }
        .progress-track.pred .progress-fill { background: linear-gradient(90deg, var(--danger), var(--success)); }
        
        /* Mode badges */
        .mode-badge {
            display: inline-flex;
            align-items: center;
            gap: 0.125rem;
            padding: 0.0625rem 0.25rem;
            border-radius: 0.375rem;
            font-size: 0.5rem;
            font-weight: 600;
            margin-left: 0.25rem;
        }
        
        .mode-hunt { background: var(--mode-hunt-bg); color: var(--mode-hunt-text); }
        .mode-flee { background: var(--mode-flee-bg); color: var(--mode-flee-text); }
        .mode-explore { background: var(--mode-explore-bg); color: var(--mode-explore-text); }
        .mode-combat { background: var(--mode-combat-bg); color: var(--mode-combat-text); }
        .mode-avoid { background: var(--mode-avoid-bg); color: var(--mode-avoid-text); }
        .mode-protect { background: var(--mode-protect-bg); color: var(--mode-protect-text); }
        .mode-heal { background: var(--mode-heal-bg); color: var(--mode-heal-text); }
        
        /* Role badge */
        .role-badge {
            display: inline-flex;
            align-items: center;
            padding: 0.0625rem 0.25rem;
            border-radius: 0.25rem;
            font-size: 0.5rem;
            font-weight: 600;
            margin-left: 0.25rem;
            background: rgba(170, 136, 255, 0.15);
            color: var(--purple);
        }
        
        /* Debug panel */
        .debug-panel {
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid var(--border);
            border-radius: 0.5rem;
            padding: 0.375rem;
            font-size: 0.5625rem;
            display: none;
            animation: slideDown var(--transition-fast) ease;
        }
        
        .debug-panel.active { display: block; }
        @keyframes slideDown { from { opacity: 0; transform: translateY(-0.5rem); } to { opacity: 1; transform: translateY(0); } }
        
        .debug-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.125rem 0.25rem; }
        .debug-item { display: flex; justify-content: space-between; padding: 0.0625rem 0; }
        .debug-label { color: var(--text-dim); }
        .debug-value { color: var(--primary); font-weight: 600; font-family: 'Courier New', monospace; }
        .debug-value.good { color: var(--success); }
        .debug-value.bad { color: var(--danger); }
        
        /* Neural architecture panel */
        .arch-panel { background: rgba(0, 0, 0, 0.3); border-radius: 0.5rem; padding: 0.375rem; font-size: 0.5rem; }
        .arch-layer { display: flex; align-items: center; gap: 0.25rem; padding: 0.125rem 0; }
        .arch-size { background: var(--border); padding: 0.0625rem 0.25rem; border-radius: 0.125rem; font-weight: 600; min-width: 2rem; text-align: center; }
        .arch-connector { flex: 1; height: 2px; background: var(--border-light); position: relative; }
        .arch-connector::after {
            content: '';
            position: absolute;
            top: -2px; left: 0;
            width: 30%; height: 4px;
            background: var(--primary);
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse { 0%, 100% { opacity: 0.3; } 50% { opacity: 1; } }
        
        /* Weight inspector */
        .weight-inspector {
            background: #000;
            border: 1px solid var(--border);
            border-radius: 0.375rem;
            padding: 0.25rem;
            font-family: 'Courier New', monospace;
            font-size: 0.5rem;
            max-height: 4rem;
            overflow: auto;
        }
        
        .weight-value { display: inline-block; padding: 0 0.125rem; margin: 0 0.0625rem; border-radius: 0.0625rem; }
        .weight-pos { background: rgba(0, 255, 157, 0.2); color: var(--success); }
        .weight-neg { background: rgba(255, 68, 68, 0.2); color: var(--danger); }
        .weight-zero { color: var(--text-muted); }
        
        /* Separator */
        .separator { height: 1px; background: var(--border); margin: 0.375rem 0; }
        
        /* File inputs */
        input[type="file"] { display: none; }
        
        /* Noscript fallback */
        noscript {
            grid-column: 1 / -1;
            padding: 1rem;
            background: var(--danger);
            color: #fff;
            text-align: center;
            font-size: 0.75rem;
            font-weight: 600;
            border-radius: var(--panel-radius);
        }
        
        /* Responsive design */
        @media (max-width: 1200px) {
            .container {
                grid-template-columns: 1fr !important;
                grid-template-rows: var(--header-height) 1fr auto !important;
                grid-template-areas: "header" "canvas" "sidebar" !important;
            }
            .sidebar {
                border-left: none !important;
                border-top: 1px solid var(--border) !important;
                max-height: 50vh !important;
                overflow-y: auto !important;
            }
        }
        
        @media (max-width: 600px) {
            :root { --sidebar-width: 100%; }
            .header { padding: 0.375rem 0.75rem; }
            .header h1 { font-size: 0.875rem; }
            .panel { padding: 0.375rem; }
            .stat-grid { grid-template-columns: repeat(2, 1fr); }
            .btn-group, .btn-group-3, .btn-group-4 { grid-template-columns: repeat(2, 1fr); }
            .agent-legend { grid-template-columns: repeat(2, 1fr); }
            .learning-metrics { grid-template-columns: repeat(2, 1fr); }
            .debug-grid { grid-template-columns: 1fr; }
            .skills-display { grid-template-columns: repeat(5, 1fr); }
        }
        
        /* Print styles */
        @media print {
            body { background: #fff; color: #000; overflow: visible; }
            .sidebar, .header { display: none; }
            #gameCanvas { width: 100%; height: auto; display: block; }
        }
        
        /* Reduced motion */
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
                scroll-behavior: auto !important;
            }
            .progress-fill, .health-fill, .skill-fill, .confidence-fill { transition: none !important; }
        }
        
        /* High contrast mode */
        @media (prefers-contrast: high) {
            :root { --border: #5a5a7a; --text-dim: #d0d0f0; }
            .stat, .metric-item { border-color: var(--border-light); }
            button { border: 2px solid var(--border); }
        }
        
        /* Screen reader only */
        .sr-only {
            position: absolute;
            width: 1px; height: 1px;
            padding: 0; margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }
        
        /* Professional mode highlight */
        .professional-mode .panel {
            border-color: var(--primary);
            box-shadow: 0 0 0 1px rgba(0, 242, 255, 0.3);
        }
        
        .professional-mode .btn-professional {
            animation: professionalGlow 2s infinite;
        }
        
        @keyframes professionalGlow {
            0%, 100% { box-shadow: 0 0 5px rgba(0, 242, 255, 0.5); }
            50% { box-shadow: 0 0 15px rgba(0, 242, 255, 0.8); }
        }
    </style>
</head>
<body>
    <a href="#gameCanvas" class="skip-link">–ü–µ—Ä–µ–π—Ç–∏ –∫ —Å–∏–º—É–ª—è—Ü–∏–∏</a>
    
    <div class="container">
        <header class="header" role="banner">
            <h1>
                üéÆ AI ARENA
                <span class="version-badge">v4.1.0 PROFESSIONAL</span>
            </h1>
            <div class="fps-counter" id="fpsCounter" aria-live="polite" aria-atomic="true">FPS: 60</div>
        </header>
        
        <canvas id="gameCanvas" aria-label="AI Arena simulation canvas" role="application" tabindex="0"></canvas>
        
        <noscript>
            ‚ö†Ô∏è –î–ª—è —Ä–∞–±–æ—Ç—ã AI Arena v4.1.0 Professional —Ç—Ä–µ–±—É–µ—Ç—Å—è JavaScript. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–∫–ª—é—á–∏—Ç–µ JavaScript –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö –±—Ä–∞—É–∑–µ—Ä–∞.
        </noscript>
        
        <aside class="sidebar" role="complementary" aria-label="–ü–∞–Ω–µ–ª—å —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è">
            <!-- AGENTS PANEL -->
            <section class="panel" aria-labelledby="agents-title">
                <h2 class="panel-title" id="agents-title">üë• –ê–ì–ï–ù–¢–´ <span id="agentCountBadge" class="stat-value">0</span></h2>
                <div id="agentsList" style="max-height: 12rem; overflow-y: auto;"></div>
            </section>

            <!-- STATISTICS PANEL -->
            <section class="panel" aria-labelledby="stats-title">
                <h2 class="panel-title" id="stats-title">üìä –°–¢–ê–¢–ò–°–¢–ò–ö–ê</h2>
                <div class="stat-grid">
                    <div class="stat"><span class="stat-label">–≠–ø–∏–∑–æ–¥</span><span class="stat-value" id="episodeStat" aria-live="polite">0</span></div>
                    <div class="stat"><span class="stat-label">–®–∞–≥</span><span class="stat-value" id="stepStat" aria-live="polite">0</span></div>
                    <div class="stat"><span class="stat-label">–¢–æ—á–∫–∏</span><span class="stat-value" id="dotsStat" aria-live="polite">50</span></div>
                    <div class="stat"><span class="stat-label">–ü—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è</span><span class="stat-value" id="obstaclesStat" aria-live="polite">12</span></div>
                    <div class="stat"><span class="stat-label">–°—Ä. —Ñ–∏—Ç–Ω–µ—Å</span><span class="stat-value good" id="fitnessStat" aria-live="polite">0</span></div>
                    <div class="stat"><span class="stat-label">–õ—É—á—à–∏–π</span><span class="stat-value good" id="bestFitnessStat" aria-live="polite">0</span></div>
                </div>
                <div class="progress-bar" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100" aria-label="–ü—Ä–æ–≥—Ä–µ—Å—Å —ç–ø–∏–∑–æ–¥–∞">
                    <div class="progress-fill" id="episodeProgress" style="width: 0%"></div>
                </div>
            </section>

            <!-- GAME MODE PANEL -->
            <section class="panel" aria-labelledby="mode-title">
                <h2 class="panel-title" id="mode-title">‚öôÔ∏è –†–ï–ñ–ò–ú –ò–ì–†–´</h2>
                <div class="control-group">
                    <label class="control-label">–¢–∏–ø —Ä–µ–∂–∏–º–∞</label>
                    <select id="gameModeType">
                        <option value="freeforall">üÜì Free For All</option>
                        <option value="tournament" selected>üèÜ Tournament</option>
                        <option value="survival">üßü Survival</option>
                    </select>
                </div>
                <div id="tournamentSettings">
                    <div class="control-group">
                        <label class="control-label">–§–æ—Ä–º–∞—Ç</label>
                        <select id="tournamentFormat">
                            <option value="1v1">‚öîÔ∏è 1 vs 1</option>
                            <option value="2v2">‚öîÔ∏è 2 vs 2</option>
                            <option value="team" selected>üë• –ö–æ–º–∞–Ω–¥—ã</option>
                            <option value="free">üé≤ –°–ª—É—á–∞–π–Ω—ã–µ</option>
                        </select>
                    </div>
                    <div class="stat-grid">
                        <div class="control-group">
                            <label class="control-label" for="teamCountInput">–ö–æ–º–∞–Ω–¥</label>
                            <input type="number" id="teamCountInput" min="2" max="8" value="4">
                        </div>
                        <div class="control-group">
                            <label class="control-label" for="agentsPerTeamInput">–ê–≥–µ–Ω—Ç–æ–≤/–∫–æ–º</label>
                            <input type="number" id="agentsPerTeamInput" min="1" max="10" value="5">
                        </div>
                    </div>
                    <label class="toggle"><input type="checkbox" id="allowUnevenTeams" checked><span>–ù–µ—Ä–∞–≤–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã</span></label>
                    <label class="toggle"><input type="checkbox" id="dynamicTeams" checked><span>–î–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–µ –∫–æ–º–∞–Ω–¥—ã (—ç–º–ø–∞—Ç–∏—è)</span></label>
                    <label class="toggle"><input type="checkbox" id="individualMutation" checked><span>–ò–Ω–¥–∏–≤–∏–¥—É–∞–ª—å–Ω–∞—è –º—É—Ç–∞—Ü–∏—è</span></label>
                </div>
            </section>

            <!-- LEARNING PARAMETERS PANEL -->
            <section class="panel" aria-labelledby="learning-title">
                <h2 class="panel-title" id="learning-title">üß† –û–ë–£–ß–ï–ù–ò–ï ‚Äî TD(Œª)+Actor-Critic+MoE+Hebbian</h2>
                <div class="control-group">
                    <label class="control-label" for="learningRate"><span>Learning Rate (Œ±)</span><span id="learningRateValue">0.005</span></label>
                    <input type="range" id="learningRate" min="0.001" max="0.05" step="0.001" value="0.005">
                </div>
                <div class="control-group">
                    <label class="control-label" for="lambda"><span>TD Lambda (Œª)</span><span id="lambdaValue">0.95</span></label>
                    <input type="range" id="lambda" min="0.8" max="0.99" step="0.01" value="0.95">
                </div>
                <div class="control-group">
                    <label class="control-label" for="gamma"><span>Discount (Œ≥)</span><span id="gammaValue">0.99</span></label>
                    <input type="range" id="gamma" min="0.9" max="0.999" step="0.001" value="0.99">
                </div>
                <div class="control-group">
                    <label class="control-label" for="entropyCoeff"><span>Entropy Coef</span><span id="entropyValue">0.01</span></label>
                    <input type="range" id="entropyCoeff" min="0.001" max="0.05" step="0.001" value="0.01">
                </div>
                <div class="control-group">
                    <label class="control-label" for="mutationRate"><span>Mutation Rate</span><span id="mutationRateValue">0.1</span></label>
                    <input type="range" id="mutationRate" min="0.05" max="0.3" step="0.01" value="0.1">
                </div>
                <div class="control-group">
                    <label class="control-label" for="skillGrowth"><span>Skill Growth</span><span id="skillGrowthValue">0.04</span></label>
                    <input type="range" id="skillGrowth" min="0.01" max="0.1" step="0.01" value="0.04">
                </div>
                <div class="separator"></div>
                <label class="toggle"><input type="checkbox" id="enableTraining" checked><span>TD(Œª) Learning</span></label>
                <label class="toggle"><input type="checkbox" id="enableCritic" checked><span>Actor-Critic (Value Estimation)</span></label>
                <label class="toggle"><input type="checkbox" id="enablePolicySelector" checked><span>Learnable Behavior Policy</span></label>
                <label class="toggle"><input type="checkbox" id="enableEvolution" checked><span>Weight Mutation</span></label>
                <label class="toggle"><input type="checkbox" id="enableSkillEvolution" checked><span>Skill Evolution</span></label>
                <label class="toggle"><input type="checkbox" id="enableMoE" checked><span>Mixture-of-Experts + Load Balance</span></label>
                <label class="toggle"><input type="checkbox" id="enableConsolidation" checked><span>Memory Consolidation</span></label>
                <label class="toggle"><input type="checkbox" id="enableFighting" checked><span>–ë–æ–∏ –º–µ–∂–¥—É –∞–≥–µ–Ω—Ç–∞–º–∏</span></label>
                <label class="toggle"><input type="checkbox" id="enableRanged" checked><span>–î–∏—Å—Ç–∞–Ω—Ü–∏–æ–Ω–Ω–æ–µ –æ—Ä—É–∂–∏–µ</span></label>
                <label class="toggle"><input type="checkbox" id="enableVisualization"><span>–í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –Ω–µ–π—Ä–æ–Ω–æ–≤</span></label>
                <label class="toggle"><input type="checkbox" id="enableHebbian" checked><span>Hebbian Learning (Fast Associations)</span></label>
            </section>

            <!-- PROFESSIONAL MODE PANEL -->
            <section class="panel" aria-labelledby="professional-title" id="professionalPanel">
                <h2 class="panel-title" id="professional-title">‚ö° PROFESSIONAL MODE ‚Äî Neural Architecture</h2>
                <button class="btn-professional" id="btnToggleProfessional" aria-pressed="false">üî¨ –í–∫–ª—é—á–∏—Ç—å Professional Mode</button>
                <div id="professionalContent" style="display: none; margin-top: 0.5rem;">
                    <div class="arch-panel">
                        <div class="arch-layer"><span class="arch-size">57</span><div class="arch-connector"></div><span>Input</span></div>
                        <div class="arch-layer"><span class="arch-size">24</span><div class="arch-connector"></div><span>Embedding</span></div>
                        <div class="arch-layer"><span class="arch-size">56</span><div class="arch-connector"></div><span>+Memory(32)</span></div>
                        <div class="arch-layer"><span class="arch-size">48</span><div class="arch-connector"></div><span>Hidden1+Attention(4h)</span></div>
                        <div class="arch-layer"><span class="arch-size">36</span><div class="arch-connector"></div><span>MoE(4experts)</span></div>
                        <div class="arch-layer"><span class="arch-size">16</span><div class="arch-connector"></div><span>Output+Memory</span></div>
                    </div>
                    <div class="separator"></div>
                    <label class="toggle"><input type="checkbox" id="compactInputs"><span>Compact Inputs (25 vs 57)</span></label>
                    <label class="toggle"><input type="checkbox" id="enableWeightInheritance" checked><span>Weight Inheritance (50%)</span></label>
                    <label class="toggle"><input type="checkbox" id="showWeights"><span>–ü–æ–∫–∞–∑–∞—Ç—å –≤–µ—Å–∞ (sample)</span></label>
                    <label class="toggle"><input type="checkbox" id="showGradients"><span>–ü–æ–∫–∞–∑–∞—Ç—å –≥—Ä–∞–¥–∏–µ–Ω—Ç—ã</span></label>
                    <label class="toggle"><input type="checkbox" id="showAttention"><span>–í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è Attention</span></label>
                    <label class="toggle"><input type="checkbox" id="showMoEGate"><span>MoE Gate Probabilities</span></label>
                    <label class="toggle"><input type="checkbox" id="showMemory"><span>Memory Content Inspector</span></label>
                    <div id="weightSample" class="weight-inspector" style="display: none;"></div>
                    <div id="attentionSample" class="weight-inspector" style="display: none;"></div>
                </div>
            </section>

            <!-- METRICS PANEL -->
            <section class="panel" aria-labelledby="metrics-title">
                <h2 class="panel-title" id="metrics-title">üìà METRICS ‚Äî –ß–¢–û –£–õ–£–ß–®–ê–ï–¢–°–Ø</h2>
                <div class="learning-metrics">
                    <div class="metric-item"><span class="metric-label">TD-Error</span><span class="metric-value" id="metricTDError">0.0000</span></div>
                    <div class="metric-item"><span class="metric-label">Pred.Error</span><span class="metric-value" id="metricPredError">0.000</span></div>
                    <div class="metric-item"><span class="metric-label">Entropy</span><span class="metric-value" id="metricEntropy">0.000</span></div>
                    <div class="metric-item"><span class="metric-label">Win Rate</span><span class="metric-value" id="metricWinRate">0.00</span></div>
                    <div class="metric-item"><span class="metric-label">Collection</span><span class="metric-value" id="metricCollection">0.00</span></div>
                    <div class="metric-item"><span class="metric-label">Survival</span><span class="metric-value" id="metricSurvival">0.00</span></div>
                </div>
                <div class="learning-progress">
                    <div class="progress-row"><span class="progress-label">TD Learning</span><div class="progress-track td"><div class="progress-fill" id="progressTD" style="width: 50%"></div></div></div>
                    <div class="progress-row"><span class="progress-label">Exploration</span><div class="progress-track entropy"><div class="progress-fill" id="progressEntropy" style="width: 50%"></div></div></div>
                    <div class="progress-row"><span class="progress-label">Memory</span><div class="progress-track pred"><div class="progress-fill" id="progressPred" style="width: 50%"></div></div></div>
                </div>
            </section>

            <!-- SOCIAL DYNAMICS PANEL -->
            <section class="panel" aria-labelledby="social-title">
                <h2 class="panel-title" id="social-title">üåê –°–û–¶–ò–ê–õ–¨–ù–ê–Ø –î–ò–ù–ê–ú–ò–ö–ê</h2>
                <div class="stat-grid">
                    <div class="stat"><span class="stat-label">–ê–ª—å—è–Ω—Å–æ–≤</span><span class="stat-value good" id="allianceCount">0</span></div>
                    <div class="stat"><span class="stat-label">–í–æ–π–Ω</span><span class="stat-value bad" id="warCount">0</span></div>
                    <div class="stat"><span class="stat-label">–ö–æ–æ–ø–µ—Ä–∞—Ü–∏–π</span><span class="stat-value" id="coopCount">0</span></div>
                    <div class="stat"><span class="stat-label">–ü—Ä–µ–¥–∞—Ç–µ–ª—å—Å—Ç–≤</span><span class="stat-value warn" id="betrayalCount">0</span></div>
                </div>
                <div id="topReputation" style="margin-top:0.5rem;font-size:0.625rem;"></div>
            </section>

            <!-- TEAMS PANEL -->
            <section class="panel" aria-labelledby="teams-title">
                <h2 class="panel-title" id="teams-title">üë• –ö–û–ú–ê–ù–î–´</h2>
                <div id="teamsList" class="agent-legend"></div>
            </section>

            <!-- CONTROLS PANEL -->
            <section class="panel" aria-labelledby="controls-title">
                <h2 class="panel-title" id="controls-title">üéÆ –£–ü–†–ê–í–õ–ï–ù–ò–ï</h2>
                <div class="btn-group">
                    <button class="btn-primary" id="btnStart" aria-pressed="false">‚ñ∂ –°—Ç–∞—Ä—Ç</button>
                    <button class="btn-danger" id="btnReset">üîÑ –°–±—Ä–æ—Å</button>
                    <button class="btn-success" id="btnSave">üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
                    <button class="btn-secondary" id="btnLoad">üìÇ –ó–∞–≥—Ä—É–∑–∏—Ç—å</button>
                </div>
                <div class="btn-group-3" style="margin-top: 0.25rem;">
                    <button class="btn-toggle" id="btnDebug" aria-pressed="false">üîç Debug</button>
                    <button class="btn-toggle" id="btnVision" aria-pressed="false">üëÅÔ∏è Vision</button>
                    <button class="btn-learning" id="btnMetrics" aria-pressed="true">üìä Metrics</button>
                </div>
                <div class="btn-group" style="margin-top: 0.25rem;">
                    <button class="btn-secondary" id="btnExport">üì§ –≠–∫—Å–ø–æ—Ä—Ç</button>
                    <button class="btn-secondary" id="btnPretrain">‚¨ÜÔ∏è Pretrain</button>
                    <button class="btn-secondary" id="btnImport">üì• –ò–º–ø–æ—Ä—Ç</button>
                </div>
                <input type="file" id="fileImport" accept=".json">
                <input type="file" id="filePretrain" accept=".json">
            </section>

            <!-- LEGEND PANEL -->
            <section class="panel" aria-labelledby="legend-title">
                <h2 class="panel-title" id="legend-title">üé® –õ–ï–ì–ï–ù–î–ê</h2>
                <div class="agent-legend">
                    <div class="legend-item"><div class="legend-color" style="background: #00d4ff"></div><span>–ê–≥–µ–Ω—Ç</span></div>
                    <div class="legend-item"><div class="legend-color" style="background: #00ff9d"></div><span>–¢–æ—á–∫–∞ (5)</span></div>
                    <div class="legend-item"><div class="legend-color" style="background: #ff66cc"></div><span>Scared (8)</span></div>
                    <div class="legend-item"><div class="legend-color" style="background: #ffaa00"></div><span>Rare (20)</span></div>
                    <div class="legend-item"><div class="legend-color" style="background: #4a4a7a"></div><span>–ü—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–µ</span></div>
                    <div class="legend-item"><div class="legend-color" style="background: var(--stat-str)"></div><span>–°–∏–ª–∞</span></div>
                    <div class="legend-item"><div class="legend-color" style="background: var(--stat-spd)"></div><span>–°–∫–æ—Ä–æ—Å—Ç—å</span></div>
                    <div class="legend-item"><div class="legend-color" style="background: var(--stat-hp)"></div><span>–ó–¥–æ—Ä–æ–≤—å–µ</span></div>
                    <div class="legend-item"><div class="legend-color" style="background: var(--learning-good)"></div><span>–£–ª—É—á—à–µ–Ω–∏–µ</span></div>
                    <div class="legend-item"><div class="legend-color" style="background: var(--purple)"></div><span>–†–æ–ª—å</span></div>
                </div>
            </section>

            <!-- LOG PANEL -->
            <section class="panel" aria-labelledby="log-title">
                <h2 class="panel-title" id="log-title">üìù –õ–û–ì</h2>
                <div class="log" id="eventLog" role="log" aria-live="polite" aria-relevant="additions"></div>
            </section>

            <!-- DEBUG PANEL -->
            <section class="debug-panel" id="debugPanel" aria-labelledby="debug-title" hidden>
                <h3 id="debug-title" style="margin-bottom: 0.25rem; font-weight: 600; color: var(--primary); font-size: 0.625rem;">üîç INSPECTOR ‚Äî v4.1.0</h3>
                <div class="debug-grid" id="debugGrid">
                    <div class="debug-item"><span class="debug-label">Mode</span><span class="debug-value" id="dbgMode">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">Target</span><span class="debug-value" id="dbgTarget">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">Speed</span><span class="debug-value" id="dbgSpeed">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">Aggro</span><span class="debug-value" id="dbgAggro">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">Memory</span><span class="debug-value" id="dbgMemory">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">Neurons</span><span class="debug-value" id="dbgNeurons">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">Reward</span><span class="debug-value" id="dbgReward">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">Stuck</span><span class="debug-value" id="dbgStuck">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">Confidence</span><span class="debug-value" id="dbgConf">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">TD-Error</span><span class="debug-value" id="dbgTDErr">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">Entropy</span><span class="debug-value" id="dbgEntropy">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">Pred.Err</span><span class="debug-value" id="dbgPredErr">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">WinRate</span><span class="debug-value" id="dbgWinRate">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">Collect</span><span class="debug-value" id="dbgCollection">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">Gate[0]</span><span class="debug-value" id="dbgGate0">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">Gate[1]</span><span class="debug-value" id="dbgGate1">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">Expert[0]</span><span class="debug-value" id="dbgExpert0">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">Expert[1]</span><span class="debug-value" id="dbgExpert1">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">LoadBal</span><span class="debug-value" id="dbgLoadBal">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">Hebbian</span><span class="debug-value" id="dbgHebbian">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">Team</span><span class="debug-value" id="dbgTeam">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">Role</span><span class="debug-value" id="dbgRole">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">Trust</span><span class="debug-value" id="dbgTrust">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">Reputation</span><span class="debug-value" id="dbgReputation">‚Äî</span></div>
                </div>
                <div class="confidence-meter">
                    <span>Conf:</span>
                    <div class="confidence-bar" role="progressbar" aria-valuenow="50" aria-valuemin="0" aria-valuemax="100" aria-label="–£–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è">
                        <div class="confidence-fill" id="dbgConfBar" style="width: 50%"></div>
                    </div>
                    <span id="dbgConfVal">0.50</span>
                </div>
            </section>
        </aside>
    </div>

<script>
/**
 * ============================================================================
 * AI ARENA v4.1.0 ‚Äî PROFESSIONAL COMPLETE
 * ============================================================================
 * ‚úÖ FULL ARCHITECTURE PRESERVED: 57‚Üí24‚Üí48‚Üí36‚Üí16 + RNN(16)
 * ‚úÖ DETERMINISTIC INIT: seed + timestamp + hash-avalanche
 * ‚úÖ MULTI-AGENT: dynamic teams, empathy, social memory, roles
 * ‚úÖ TOURNAMENT MODES: freeforall/tournament/survival with config
 * ‚úÖ PROFESSIONAL MODE: neural architecture visualization, weight inspection
 * ‚úÖ ALL PREVIOUS IMPROVEMENTS: individual stats, collective behavior, MoE, Hebbian
 * ‚úÖ NULL-SAFE: all inputs validated, all accesses guarded
 * ‚úÖ NUMERICALLY STABLE: softmax, tanh, sigmoid with overflow protection
 * ‚úÖ CSP-COMPLIANT: no external resources, safe HTML escaping
 * ‚úÖ ACCESSIBLE: ARIA, keyboard nav, reduced motion, high contrast
 * ‚úÖ PERFORMANCE: spatial hashing hints, early-exit, Float32Array
 * ============================================================================
 */

'use strict';

// ============================================================================
// GLOBAL CONFIGURATION ‚Äî DETERMINISTIC + MULTI-AGENT + PROFESSIONAL
// ============================================================================
window.arenaConfig = Object.freeze({
    // Feature flags
    enableTraining: true,
    enableCritic: true,
    enablePolicySelector: true,
    enableEvolution: true,
    enableSkillEvolution: true,
    enableMoE: true,
    enableConsolidation: true,
    enableFighting: true,
    enableRanged: true,
    enableVisualization: false,
    enableHebbian: true,
    
    // Hyperparameters
    learningRate: 0.005,
    lambda: 0.95,
    gamma: 0.99,
    entropyCoeff: 0.01,
    mutationRate: 0.1,
    skillGrowthRate: 0.04,
    
    // Deterministic initialization
    seed: 'ARENA_V4.1.0_PRO_' + (typeof performance !== 'undefined' ? performance.now() : Date.now()).toFixed(0),
    timestamp: Date.now(),
    version: '4.1.0',
    
    // Game mode configuration
    gameMode: Object.freeze({
        type: 'tournament',
        tournament: {
            format: 'team',
            teamCount: 4,
            agentsPerTeam: 5,
            allowUneven: true,
            dynamicTeams: true,
            mutationMode: 'individual'
        },
        colors: ['#00d4ff', '#ff5577', '#44ff44', '#ffaa00', '#aa88ff', '#ff66cc', '#00ff9d', '#ff8844']
    }),
    
    // Architecture constants ‚Äî DO NOT CHANGE for compatibility
    ARCH: Object.freeze({
        INPUT_DIM: 57,
        INPUT_DIM_COMPACT: 25,
        EMBEDDING_DIM: 24,
        EMBEDDING_DIM_COMPACT: 16,
        HIDDEN1: 48,
        HIDDEN2: 36,
        OUTPUT_DIM: 16,
        MEMORY_DIM: 16,
        NUM_HEADS: 4,
        NUM_EXPERTS: 4,
        EXPERT_DIM: 36,
        POLICY_CONTEXT_DIM: 8,
        POLICY_SKILL_DIM: 5,
        POLICY_HIDDEN: 24,
        POLICY_MODES: 5,
        CRITIC_HIDDEN: 32,
        LOGICAL_WIDTH: 820,
        LOGICAL_HEIGHT: 600
    }),
    
    // Professional mode flags
    professionalMode: false,
    showWeights: false,
    showGradients: false,
    showAttention: false,
    showMoEGate: false,
    showMemory: false,
    compactInputs: false,
    enableWeightInheritance: true
});

// ============================================================================
// UTILITIES ‚Äî NUMERICALLY STABLE, SAFE, OPTIMIZED
// ============================================================================
const Utils = Object.freeze({
    clamp: (v, min, max) => Math.max(min, Math.min(max, v)),
    lerp: (a, b, t) => a + (b - a) * Utils.clamp(t, 0, 1),
    dist: (a, b) => Math.hypot((a?.x ?? 0) - (b?.x ?? 0), (a?.y ?? 0) - (b?.y ?? 0)),
    normalize: (x, y) => { const l = Math.hypot(x, y); return l > 1e-10 ? { x: x / l, y: y / l } : { x: 0, y: 0 }; },
    tanh: (x) => { if (x > 20) return 1; if (x < -20) return -1; const e = Math.exp(2 * x); return (e - 1) / (e + 1); },
    sigmoid: (x) => { if (x > 20) return 1; if (x < -20) return 0; return 1 / (1 + Math.exp(-x)); },
    leakyRelu: (x, Œ± = 0.01) => x > 0 ? x : Œ± * x,
    argmax: (arr) => { if (!arr || arr.length === 0) return -1; let mi = 0; for (let i = 1; i < arr.length; i++) if (arr[i] > arr[mi]) mi = i; return mi; },
    rand: (min, max) => Math.random() * (max - min) + min,
    randInt: (min, max) => Math.floor(Math.random() * (max - min + 1)) + min,
    safeNumber: (val, fallback = 0) => (typeof val === 'number' && isFinite(val)) ? val : fallback,
    
    softmax: (arr, temp = 1) => {
        if (!arr || !Array.isArray(arr) || arr.length === 0) return [];
        const max = Math.max(...arr);
        const exps = arr.map(v => { const s = (v - max) / temp; return s > 700 ? 0 : Math.exp(Math.min(s, 700)); });
        const sum = exps.reduce((s, x) => s + x, 0) || 1e-10;
        return exps.map(e => e / sum);
    },
    
    logSoftmax: (arr, temp = 1) => {
        if (!arr || !Array.isArray(arr) || arr.length === 0) return [];
        const max = Math.max(...arr);
        const logSumExp = max + Math.log(arr.reduce((s, x) => { const sc = (x - max) / temp; return s + (sc > 700 ? 0 : Math.exp(Math.min(sc, 700))); }, 0) + 1e-10);
        return arr.map(v => ((v - max) / temp - logSumExp));
    },
    
    policyGradientLoss: (logProbs, advantages) => {
        if (!logProbs?.length || !advantages?.length) return 0;
        const len = Math.min(logProbs.length, advantages.length);
        if (len === 0) return 0;
        let sum = 0;
        for (let i = 0; i < len; i++) { const lp = Utils.safeNumber(logProbs[i], 0), adv = Utils.safeNumber(advantages[i], 0); sum += lp * adv; }
        return -sum / len;
    },
    
    entropyBonus: (probs) => {
        if (!probs?.length) return 0;
        let sum = 0;
        for (const p of probs) { const sp = Math.max(Utils.safeNumber(p, 0), 1e-10); sum += sp * Math.log(sp); }
        return -sum;
    },
    
    moeLoadBalanceLoss: (gateProbs, expertUsage) => {
        if (!gateProbs?.length) return 0;
        const numExperts = gateProbs.length, targetUsage = 1 / numExperts;
        let sum = 0;
        for (let i = 0; i < numExperts; i++) { const usage = Utils.safeNumber(expertUsage?.[i], 0); sum += Math.pow(usage - targetUsage, 2); }
        return sum / numExperts;
    },
    
    computeGAE: (rewards, values, nextValue, gamma = 0.99, lambda = 0.95) => {
        const advantages = new Array(rewards.length);
        let advantage = 0;
        for (let t = rewards.length - 1; t >= 0; t--) {
            const nextVal = (t === rewards.length - 1) ? nextValue : values[t + 1];
            const delta = Utils.safeNumber(rewards[t], 0) + gamma * Utils.safeNumber(nextVal, 0) - Utils.safeNumber(values[t], 0);
            advantage = delta + gamma * lambda * advantage;
            advantages[t] = advantage;
        }
        return advantages;
    },
    
    tdError: (reward, value, nextValue, gamma = 0.99) => Utils.safeNumber(reward, 0) + gamma * Utils.safeNumber(nextValue, 0) - Utils.safeNumber(value, 0),
    
    _pointSegDist: (ax, ay, bx, by, cx, cy) => {
        const vx = bx - ax, vy = by - ay, wx = cx - ax, wy = cy - ay;
        const c1 = vx * wx + vy * wy;
        if (c1 <= 0) return Math.hypot(cx - ax, cy - ay);
        const c2 = vx * vx + vy * vy;
        if (c2 <= c1) return Math.hypot(cx - bx, cy - by);
        const b = c1 / c2, pbx = ax + b * vx, pby = ay + b * vy;
        return Math.hypot(cx - pbx, cy - pby);
    },
    
    hasLineOfSight: (a, b, walls, wallRadius = 14) => {
        if (!a || !b) return false; if (!walls?.length) return true;
        for (const w of walls) { if (!w) continue; const d = Utils._pointSegDist(a.x, a.y, b.x, b.y, w.x, w.y); if (d < wallRadius + 2) return false; }
        return true;
    },
    
    projectInput: (rawInputs, embeddingWeights, bias, outputDim) => {
        const projected = new Array(outputDim).fill(0);
        for (let o = 0; o < outputDim; o++) {
            let sum = Utils.safeNumber(bias?.[o], 0);
            for (let i = 0; i < rawInputs.length; i++) { const w = embeddingWeights?.[i]?.[o]; sum += Utils.safeNumber(rawInputs[i], 0) * Utils.safeNumber(w, 0); }
            projected[o] = Utils.leakyRelu(sum);
        }
        return projected;
    },
    
    hashSeed: (seed, i, j) => {
        if (!seed) seed = 'default';
        let h = String(seed).split('').reduce((a, c, idx) => ((a * 31 + c.charCodeAt(0)) ^ (idx * 17 + i * 7919 + j * 104729)) % 2147483647, String(seed).length) || 12345;
        h = (h * 2654435761) >>> 0;
        return h / 4294967296;
    },
    
    deepClone: (obj) => {
        if (obj === null || typeof obj !== 'object') return obj;
        if (obj instanceof Float32Array) return new Float32Array(obj);
        if (Array.isArray(obj)) return obj.map(Utils.deepClone);
        const clone = {}; for (const key of Object.keys(obj)) clone[key] = Utils.deepClone(obj[key]);
        return clone;
    },
    
    validateAttention: (scores) => {
        if (!scores?.length || !scores[0]?.length) return { valid: false, error: 'empty' };
        const n = scores.length, m = scores[0].length;
        let rowSumValid = true;
        for (let i = 0; i < n; i++) { const sum = scores[i].reduce((s, v) => s + v, 0); if (Math.abs(sum - 1) > 0.01) { rowSumValid = false; break; } }
        let hasInvalid = false;
        for (let i = 0; i < n && !hasInvalid; i++) for (let j = 0; j < m; j++) if (!isFinite(scores[i][j])) { hasInvalid = true; break; }
        return { valid: rowSumValid && !hasInvalid, shape: [n, m], rowSumValid, hasInvalid };
    },
    
    computeLoadBalance: (usage) => {
        if (!usage?.length) return 1;
        const mean = usage.reduce((s, v) => s + v, 0) / usage.length;
        if (mean < 1e-10) return 1;
        const variance = usage.reduce((s, v) => s + Math.pow(v - mean, 2), 0) / usage.length;
        return Math.sqrt(variance) / mean;
    }
});

// ============================================================================
// SEEDED RNG ‚Äî DETERMINISTIC WEIGHT INITIALIZATION
// ============================================================================
class SeededRNG {
    constructor(seed) {
        this._baseSeed = String(seed || 'default').split('').reduce((a, c, i) => ((a * 31 + c.charCodeAt(0)) ^ (i * 17)) % 2147483647, String(seed || 'default').length) || 12345;
        this._state = this._baseSeed;
    }
    next() {
        let x = this._state; x ^= x << 13; x ^= x >>> 17; x ^= x << 5;
        this._state = x >>> 0;
        return (x * 0x2545F4914F6CDD1D) >>> 0 / 4294967296;
    }
    deriveWeights(rows, cols, scale) {
        const weights = [];
        for (let i = 0; i < rows; i++) {
            const row = [];
            for (let j = 0; j < cols; j++) {
                const hash = Utils.hashSeed(String(this._baseSeed), i, j);
                row.push((hash * 2 - 1) * scale);
            }
            weights.push(row);
        }
        return weights;
    }
    deriveVector(length, scale) {
        const vec = [];
        for (let i = 0; i < length; i++) { const hash = Utils.hashSeed(String(this._baseSeed), i, 0); vec.push((hash * 2 - 1) * scale); }
        return vec;
    }
    reset() { this._state = this._baseSeed; }
    getSeed() { return String(this._baseSeed); }
}

// ============================================================================
// NEURAL NETWORK ‚Äî DUAL-MEMORY ARCHITECTURE 57‚Üí24‚Üí48‚Üí36‚Üí16 + RNN(16)
// ============================================================================
class NeuralNetwork {
    constructor(config = {}) {
        // Architecture with adaptive input dimension
        const useCompact = config.compactInputs ?? arenaConfig.compactInputs;
        this.inputDim = config.inputDim ?? (useCompact ? arenaConfig.ARCH.INPUT_DIM_COMPACT : arenaConfig.ARCH.INPUT_DIM);
        this.embeddingDim = config.embeddingDim ?? (useCompact ? arenaConfig.ARCH.EMBEDDING_DIM_COMPACT : arenaConfig.ARCH.EMBEDDING_DIM);
        this.hidden1 = config.hidden1 ?? arenaConfig.ARCH.HIDDEN1;
        this.hidden2 = config.hidden2 ?? arenaConfig.ARCH.HIDDEN2;
        this.outputDim = config.outputDim ?? arenaConfig.ARCH.OUTPUT_DIM;
        this.memoryDim = config.memoryDim ?? arenaConfig.ARCH.MEMORY_DIM;
        
        // Deterministic initialization
        this.seed = config.seed ?? arenaConfig.seed;
        this._rng = new SeededRNG(this.seed);
        
        // Weight matrices (seed-derived)
        this._inputEmbedding = this._rng.deriveWeights(this.inputDim, this.embeddingDim, 0.3);
        this._embeddingBias = this._rng.deriveVector(this.embeddingDim, 0.1);
        
        const combinedInputDim = this.embeddingDim + this.memoryDim * 2;
        this._W1 = this._rng.deriveWeights(combinedInputDim, this.hidden1, 0.3);
        this._W2 = this._rng.deriveWeights(this.hidden1, this.hidden2, 0.2);
        this._W3 = this._rng.deriveWeights(this.hidden2, this.outputDim, 0.1);
        
        // Multi-head attention (4 heads) ‚Äî correct Q¬∑K^T
        this.numHeads = config.numHeads ?? arenaConfig.ARCH.NUM_HEADS;
        this.headDim = Math.floor(this.hidden1 / this.numHeads);
        this._Wq = this._rng.deriveWeights(this.hidden1, this.hidden1, 0.08);
        this._Wk = this._rng.deriveWeights(this.hidden1, this.hidden1, 0.08);
        this._Wv = this._rng.deriveWeights(this.hidden1, this.hidden1, 0.08);
        this._Wo = this._rng.deriveWeights(this.hidden1, this.hidden1, 0.08);
        
        // Mixture-of-Experts (4 experts) ‚Äî correctly connected
        this.numExperts = config.numExperts ?? arenaConfig.ARCH.NUM_EXPERTS;
        this.expertDim = config.expertDim ?? arenaConfig.ARCH.EXPERT_DIM;
        this._Wg = this._rng.deriveWeights(this.hidden1, this.numExperts, 0.12);
        this._expertW1 = []; this._expertW2 = [];
        for (let e = 0; e < this.numExperts; e++) {
            this._expertW1.push(this._rng.deriveWeights(this.hidden1, this.expertDim, 0.15));
            this._expertW2.push(this._rng.deriveWeights(this.expertDim, this.outputDim, 0.1));
        }
        
        // Eligibility traces for TD(Œª)
        this._eligibilityEmbedding = new Float32Array(this.inputDim * this.embeddingDim);
        this._eligibilityW1 = new Float32Array(combinedInputDim * this.hidden1);
        this._eligibilityW2 = new Float32Array(this.hidden1 * this.hidden2);
        this._eligibilityW3 = new Float32Array(this.hidden2 * this.outputDim);
        
        // Dual memory system
        this._memoryPermanent = new Float32Array(this.memoryDim);
        this._memoryPredictive = new Float32Array(this.memoryDim);
        this._predictionErrors = new Float32Array(this.memoryDim);
        this._consolidationBuffer = []; this._maxBuffer = 32;
        
        // Hyperparameters
        this.lr = config.lr ?? arenaConfig.learningRate;
        this.hebbianRate = config.hebbianRate ?? 0.002;
        this.gamma = config.gamma ?? arenaConfig.gamma;
        this.lambda = config.lambda ?? arenaConfig.lambda;
        this.entropyCoeff = config.entropyCoeff ?? arenaConfig.entropyCoeff;
        
        // Training metrics
        this._trainingStats = {
            tdErrorHistory: [], predictionErrorHistory: [], policyEntropyHistory: [], loadBalanceHistory: [],
            winRate: 0, collectionRate: 0, survivalTime: 0, totalSteps: 0, avgRewardPerStep: 0
        };
        
        // Forward pass cache
        this._lastInputs = null; this._lastEmbedded = null; this._lastHidden1 = null;
        this._lastHidden2 = null; this._lastOutput = null; this._lastGateProbs = null;
        this._lastAttentionWeights = null; this._activeNeurons = []; this._lastActiveExperts = [];
    }
    
    _embedInputs(rawInputs) { return Utils.projectInput(rawInputs, this._inputEmbedding, this._embeddingBias, this.embeddingDim); }
    
    _selfAttention(h1) {
        if (!h1?.length) return h1 || [];
        const Q = this._linMatMul(h1, this._Wq), K = this._linMatMul(h1, this._Wk), V = this._linMatMul(h1, this._Wv);
        const scale = 1 / Math.sqrt(Math.max(1, this.headDim)), numHeads = this.numHeads || 4, headDim = Math.floor(this.hidden1 / numHeads);
        const Q_heads = [], K_heads = [], V_heads = [];
        for (let h = 0; h < numHeads; h++) { const s = h * headDim; Q_heads.push(Q.slice(s, s + headDim)); K_heads.push(K.slice(s, s + headDim)); V_heads.push(V.slice(s, s + headDim)); }
        const headOutputs = [];
        for (let h = 0; h < numHeads; h++) {
            const Qh = Q_heads[h], Kh = K_heads[h], Vh = V_heads[h], scores = [];
            for (let i = 0; i < headDim; i++) { const row = []; for (let j = 0; j < headDim; j++) row.push(Qh[i] * Kh[j] * scale); scores.push(row); }
            const weights = scores.map(row => Utils.softmax(row, 1)), attended = new Array(headDim).fill(0);
            for (let i = 0; i < headDim; i++) for (let j = 0; j < headDim; j++) attended[i] += weights[i][j] * Vh[j];
            headOutputs.push(attended);
        }
        const concatenated = headOutputs.flat(), projected = this._linMatMul(concatenated, this._Wo);
        const output = h1.map((v, i) => Utils.lerp(v, v + projected[i], 0.6));
        this._lastAttentionWeights = headOutputs[0]?.slice() || [];
        return output;
    }
    
    _matMul(vec, mat) {
        if (!vec?.length || !mat?.length) return [];
        const out = [];
        for (let i = 0; i < mat[0].length; i++) {
            let sum = 0;
            for (let j = 0; j < vec.length; j++) sum += Utils.safeNumber(vec[j], 0) * Utils.safeNumber(mat[j]?.[i], 0);
            out.push(Utils.tanh(sum));
        }
        return out;
    }
    
    _linMatMul(vec, mat) {
        if (!vec?.length || !mat?.length) return [];
        const out = new Array(mat[0].length).fill(0);
        for (let i = 0; i < mat[0].length; i++) {
            let sum = 0;
            for (let j = 0; j < vec.length; j++) sum += Utils.safeNumber(vec[j], 0) * Utils.safeNumber(mat[j]?.[i], 0);
            out[i] = sum;
        }
        return out;
    }
    
    forward(inputs) {
        if (!Array.isArray(inputs) || inputs.length !== this.inputDim) inputs = new Array(this.inputDim).fill(0);
        this._lastInputs = inputs.slice();
        const embedded = this._embedInputs(inputs); this._lastEmbedded = embedded.slice();
        const combined = [...embedded, ...this._memoryPermanent, ...this._memoryPredictive];
        let h1 = this._matMul(combined, this._W1); this._lastHidden1 = h1.slice(); h1 = this._selfAttention(h1);
        
        // MoE gate and expert selection
        const gateLogits = this._linMatMul(h1, this._Wg), gateProbs = Utils.softmax(gateLogits, 0.7);
        this._lastGateProbs = gateProbs.slice();
        const expertNames = ['hunter', 'fleeer', 'fighter', 'explorer'];
        const expertScores = gateProbs.map((p, i) => ({ idx: i, score: p, name: expertNames[i] }));
        expertScores.sort((a, b) => b.score - a.score);
        const activeExperts = expertScores.slice(0, Math.min(2, this.numExperts)).map(e => e.idx);
        this._lastActiveExperts = activeExperts.map(i => expertNames[i]);
        
        // Expert computation
        let expertOutput = new Array(this.outputDim).fill(0), expertUsage = new Array(this.numExperts).fill(0);
        for (const e of activeExperts) {
            const h_expert = this._matMul(h1, this._expertW1[e]), out_expert = this._matMul(h_expert, this._expertW2[e]);
            for (let j = 0; j < this.outputDim; j++) expertOutput[j] += out_expert[j] * gateProbs[e];
            expertUsage[e] = gateProbs[e];
        }
        const loadBalanceLoss = Utils.moeLoadBalanceLoss(gateProbs, expertUsage);
        if (arenaConfig.enableMoE && loadBalanceLoss > 0.01) {
            const lbGrad = -0.001 * loadBalanceLoss;
            for (let i = 0; i < this.hidden1; i++) for (let e = 0; e < this.numExperts; e++) {
                const target = 1 / this.numExperts, grad = lbGrad * (expertUsage[e] - target);
                this._Wg[i][e] += this.lr * grad * h1[i]; this._Wg[i][e] = Utils.clamp(this._Wg[i][e], -2, 2);
            }
        }
        
        // Second hidden layer and output
        let h2 = this._matMul(h1, this._W2); this._lastHidden2 = h2.slice();
        const standardOutput = this._matMul(h2, this._W3), blendedOutput = new Array(this.outputDim).fill(0);
        for (let j = 0; j < this.outputDim; j++) blendedOutput[j] = Utils.tanh(standardOutput[j] * 0.7 + expertOutput[j] * 0.3);
        this._lastOutput = blendedOutput.slice();
        
        // Memory update
        const predictedMemory = h2.slice(0, this.memoryDim);
        for (let i = 0; i < this.memoryDim; i++) {
            const error = Math.abs(Utils.safeNumber(predictedMemory[i], 0) - this._memoryPredictive[i]);
            this._predictionErrors[i] = Utils.lerp(this._predictionErrors[i], error, 0.1);
        }
        this._memoryPredictive = new Float32Array(predictedMemory);
        for (let i = 0; i < this.memoryDim; i++) {
            if (this._predictionErrors[i] > 0.3) this._memoryPermanent[i] = Utils.lerp(this._memoryPermanent[i], predictedMemory[i], 0.15);
            else this._memoryPermanent[i] = Utils.lerp(this._memoryPermanent[i], predictedMemory[i], 0.02);
        }
        
        // Track active neurons
        this._activeNeurons = [...h1, ...h2, ...blendedOutput].map((v, i) => ({ i, v: Utils.safeNumber(v, 0) }))
            .sort((a, b) => Math.abs(b.v) - Math.abs(a.v)).slice(0, 5).map(n => n.i);
        
        return {
            output: blendedOutput.map(v => Utils.safeNumber(v, 0)), gateLogits, gateProbs, loadBalanceLoss, expertUsage,
            memoryPermanent: Array.from(this._memoryPermanent), memoryPredictive: Array.from(this._memoryPredictive),
            predictionErrors: Array.from(this._predictionErrors), activeNeurons: this._activeNeurons,
            embedded, h1, h2, attentionWeights: this._lastAttentionWeights, activeExperts: this._lastActiveExperts
        };
    }
    
    _hebbianUpdate(pre, post, correlation = 1, layer = 'W1') {
        if (!arenaConfig.enableHebbian || !pre?.length || !post?.length) return;
        const Œ∑ = this.hebbianRate * correlation;
        if (layer === 'embedding') {
            for (let i = 0; i < Math.min(pre.length, this.inputDim); i++) for (let o = 0; o < Math.min(post.length, this.embeddingDim); o++) {
                const delta = Œ∑ * Utils.safeNumber(pre[i], 0) * Utils.safeNumber(post[o], 0);
                this._inputEmbedding[i][o] += delta; this._inputEmbedding[i][o] = Utils.clamp(this._inputEmbedding[i][o], -2, 2);
            }
        } else if (layer === 'W1') {
            for (let i = 0; i < pre.length; i++) for (let o = 0; o < post.length; o++) {
                const delta = Œ∑ * Utils.safeNumber(pre[i], 0) * Utils.safeNumber(post[o], 0);
                this._eligibilityW1[i * this.hidden1 + o] += delta * 0.1;
                this._W1[i][o] += delta * 0.01; this._W1[i][o] = Utils.clamp(this._W1[i][o], -2, 2);
            }
        } else if (layer === 'W2') {
            for (let i = 0; i < pre.length; i++) for (let o = 0; o < post.length; o++) {
                const delta = Œ∑ * Utils.safeNumber(pre[i], 0) * Utils.safeNumber(post[o], 0);
                this._W2[i][o] += delta * 0.005; this._W2[i][o] = Utils.clamp(this._W2[i][o], -2, 2);
            }
        }
    }
    
    tdLearn(inputs, outputs, reward, value, nextValue, actionLogProbs = null) {
        const tdErr = Utils.tdError(reward, value, nextValue, this.gamma);
        this._trainingStats.tdErrorHistory.push(Math.abs(tdErr));
        if (this._trainingStats.tdErrorHistory.length > 100) this._trainingStats.tdErrorHistory.shift();
        this._updateEligibilityTraces(inputs, outputs);
        this._applyTDError(tdErr);
        if (actionLogProbs?.length && arenaConfig.enablePolicySelector) {
            const advantage = tdErr, entropy = Utils.entropyBonus(Utils.softmax(outputs.map(o => o * 10), 1));
            const policyLoss = Utils.policyGradientLoss(actionLogProbs, [advantage]);
            const totalLoss = policyLoss - this.entropyCoeff * entropy;
            this._trainingStats.policyEntropyHistory.push(entropy);
            if (this._trainingStats.policyEntropyHistory.length > 100) this._trainingStats.policyEntropyHistory.shift();
        }
        this._consolidateMemories(reward);
        if (arenaConfig.enableHebbian && reward > 1) {
            const correlation = Math.sign(reward);
            if (this._lastEmbedded?.length && this._lastHidden1?.length) this._hebbianUpdate(this._lastEmbedded, this._lastHidden1, correlation, 'embedding');
            if (this._lastHidden1?.length && this._lastHidden2?.length) this._hebbianUpdate(this._lastHidden1, this._lastHidden2, correlation, 'W1');
            if (this._lastHidden2?.length && this._lastOutput?.length) this._hebbianUpdate(this._lastHidden2, this._lastOutput, correlation, 'W2');
        }
        return { tdError: tdErr, avgTDError: this._trainingStats.tdErrorHistory.reduce((a,b)=>a+b,0)/Math.max(1,this._trainingStats.tdErrorHistory.length), avgPredictionError: Array.from(this._predictionErrors).reduce((a,b)=>a+b,0)/Math.max(1,this._predictionErrors.length) };
    }
    
    _updateEligibilityTraces(inputs, outputs) {
        const embedded = this._embedInputs(inputs), combined = [...embedded, ...this._memoryPermanent, ...this._memoryPredictive];
        for (let i = 0; i < this.inputDim; i++) for (let o = 0; o < this.embeddingDim; o++) {
            const idx = i * this.embeddingDim + o;
            this._eligibilityEmbedding[idx] = this.gamma * this.lambda * this._eligibilityEmbedding[idx] + Utils.safeNumber(inputs[i], 0) * Utils.safeNumber(this._lastHidden1?.[o], 0);
            this._eligibilityEmbedding[idx] = Utils.clamp(this._eligibilityEmbedding[idx], -10, 10);
        }
        for (let i = 0; i < combined.length; i++) for (let o = 0; o < this.hidden1; o++) {
            const idx = i * this.hidden1 + o;
            this._eligibilityW1[idx] = this.gamma * this.lambda * this._eligibilityW1[idx] + Utils.safeNumber(combined[i], 0) * Utils.safeNumber(this._lastHidden1?.[o], 0);
            this._eligibilityW1[idx] = Utils.clamp(this._eligibilityW1[idx], -10, 10);
        }
        if (this._lastHidden1?.length && this._lastHidden2?.length) for (let i = 0; i < this._lastHidden1.length; i++) for (let o = 0; o < this.hidden2; o++) {
            const idx = i * this.hidden2 + o;
            this._eligibilityW2[idx] = this.gamma * this.lambda * this._eligibilityW2[idx] + Utils.safeNumber(this._lastHidden1[i], 0) * Utils.safeNumber(this._lastHidden2[o], 0);
            this._eligibilityW2[idx] = Utils.clamp(this._eligibilityW2[idx], -10, 10);
        }
        if (this._lastHidden2?.length && this._lastOutput?.length) for (let i = 0; i < this._lastHidden2.length; i++) for (let o = 0; o < this.outputDim; o++) {
            const idx = i * this.outputDim + o;
            this._eligibilityW3[idx] = this.gamma * this.lambda * this._eligibilityW3[idx] + Utils.safeNumber(this._lastHidden2[i], 0) * Utils.safeNumber(this._lastOutput[o], 0);
            this._eligibilityW3[idx] = Utils.clamp(this._eligibilityW3[idx], -10, 10);
        }
    }
    
    _applyTDError(tdErr) {
        const alpha = this.lr * Math.sign(tdErr);
        for (let i = 0; i < this.inputDim * this.embeddingDim; i++) {
            const row = Math.floor(i / this.embeddingDim), col = i % this.embeddingDim;
            this._inputEmbedding[row][col] += alpha * this._eligibilityEmbedding[i];
            this._inputEmbedding[row][col] = Utils.clamp(this._inputEmbedding[row][col], -2, 2);
        }
        for (let i = 0; i < this._eligibilityW1.length; i++) {
            const row = Math.floor(i / this.hidden1), col = i % this.hidden1;
            this._W1[row][col] += alpha * this._eligibilityW1[i];
            this._W1[row][col] = Utils.clamp(this._W1[row][col], -2, 2);
        }
        for (let i = 0; i < this._eligibilityW2.length; i++) {
            const row = Math.floor(i / this.hidden2), col = i % this.hidden2;
            this._W2[row][col] += alpha * this._eligibilityW2[i];
            this._W2[row][col] = Utils.clamp(this._W2[row][col], -2, 2);
        }
        for (let i = 0; i < this._eligibilityW3.length; i++) {
            const row = Math.floor(i / this.outputDim), col = i % this.outputDim;
            this._W3[row][col] += alpha * this._eligibilityW3[i];
            this._W3[row][col] = Utils.clamp(this._W3[row][col], -2, 2);
        }
    }
    
    _consolidateMemories(reward) {
        if (!arenaConfig.enableConsolidation || reward < 2) return;
        for (let i = 0; i < this.memoryDim; i++) {
            if (this._predictionErrors[i] > 0.25) {
                this._consolidationBuffer.push({ index: i, value: this._memoryPredictive[i], error: this._predictionErrors[i], reward, priority: this._predictionErrors[i] * reward });
            }
        }
        if (this._consolidationBuffer.length > 0 && this._rng.next() < 0.1) {
            const totalPriority = this._consolidationBuffer.reduce((s, item) => s + item.priority, 0);
            if (totalPriority <= 0) return;
            let rand = this._rng.next() * totalPriority, selected = this._consolidationBuffer[0];
            for (const item of this._consolidationBuffer) { rand -= item.priority; if (rand <= 0) { selected = item; break; } }
            this._memoryPermanent[selected.index] = Utils.lerp(this._memoryPermanent[selected.index], selected.value, 0.3);
            if (this._rng.next() < 0.5) { const idx = this._consolidationBuffer.indexOf(selected); if (idx >= 0) this._consolidationBuffer.splice(idx, 1); }
        }
        if (this._consolidationBuffer.length > this._maxBuffer) { this._consolidationBuffer.sort((a, b) => b.priority - a.priority); this._consolidationBuffer.length = this._maxBuffer; }
    }
    
    updateDiagnostics(metrics = {}) {
        if (metrics.win !== undefined) this._trainingStats.winRate = Utils.lerp(this._trainingStats.winRate, metrics.win ? 1 : 0, 0.05);
        if (metrics.collected !== undefined) this._trainingStats.collectionRate = Utils.lerp(this._trainingStats.collectionRate, metrics.collected ? 1 : 0, 0.05);
        if (metrics.survival !== undefined) this._trainingStats.survivalTime = Utils.lerp(this._trainingStats.survivalTime, metrics.survival, 0.02);
        if (metrics.reward !== undefined) this._trainingStats.avgRewardPerStep = Utils.lerp(this._trainingStats.avgRewardPerStep, metrics.reward, 0.01);
        this._trainingStats.totalSteps++;
    }
    
    mutate(rate = 0.1, strength = 0.1) {
        if (!arenaConfig.enableEvolution) return 0;
        let mutations = 0;
        const mutateMat = (mat) => { if (!mat?.length) return; for (let i = 0; i < mat.length; i++) { if (!mat[i]?.length) continue; for (let j = 0; j < mat[i].length; j++) { if (this._rng.next() < rate) { mat[i][j] += (this._rng.next() * 2 - 1) * strength; mat[i][j] = Utils.clamp(mat[i][j], -2, 2); mutations++; } } } };
        mutateMat(this._inputEmbedding); mutateMat(this._W1); mutateMat(this._W2); mutateMat(this._W3);
        if (this._Wq) mutateMat(this._Wq); if (this._Wk) mutateMat(this._Wk); if (this._Wv) mutateMat(this._Wv); if (this._Wo) mutateMat(this._Wo);
        if (this._Wg) mutateMat(this._Wg); for (const ew1 of this._expertW1) mutateMat(ew1); for (const ew2 of this._expertW2) mutateMat(ew2);
        return mutations;
    }
    
    clone() {
        const clone = new NeuralNetwork({ inputDim: this.inputDim, embeddingDim: this.embeddingDim, hidden1: this.hidden1, hidden2: this.hidden2, outputDim: this.outputDim, memoryDim: this.memoryDim, seed: this.seed + '_clone_' + Date.now(), lr: this.lr, gamma: this.gamma, lambda: this.lambda, numHeads: this.numHeads, numExperts: this.numExperts, compactInputs: arenaConfig.compactInputs });
        clone._inputEmbedding = this._inputEmbedding.map(r => r?.slice() || []); clone._embeddingBias = this._embeddingBias?.slice() || [];
        clone._W1 = this._W1.map(r => r?.slice() || []); clone._W2 = this._W2.map(r => r?.slice() || []); clone._W3 = this._W3.map(r => r?.slice() || []);
        if (this._Wq) clone._Wq = this._Wq.map(r => r?.slice() || []); if (this._Wk) clone._Wk = this._Wk.map(r => r?.slice() || []); if (this._Wv) clone._Wv = this._Wv.map(r => r?.slice() || []); if (this._Wo) clone._Wo = this._Wo.map(r => r?.slice() || []);
        if (this._Wg) clone._Wg = this._Wg.map(r => r?.slice() || []); clone._expertW1 = this._expertW1.map(m => m.map(r => r?.slice() || [])); clone._expertW2 = this._expertW2.map(m => m.map(r => r?.slice() || []));
        clone._memoryPermanent = new Float32Array(this._memoryPermanent); clone._memoryPredictive = new Float32Array(this._memoryPredictive); clone._predictionErrors = new Float32Array(this._predictionErrors);
        clone._trainingStats = { ...this._trainingStats, tdErrorHistory: [...this._trainingStats.tdErrorHistory], predictionErrorHistory: [...this._trainingStats.predictionErrorHistory], policyEntropyHistory: [...this._trainingStats.policyEntropyHistory], loadBalanceHistory: [...this._trainingStats.loadBalanceHistory] };
        clone._eligibilityW1 = new Float32Array(this._eligibilityW1); clone._eligibilityW2 = new Float32Array(this._eligibilityW2); clone._eligibilityW3 = new Float32Array(this._eligibilityW3); clone._eligibilityEmbedding = new Float32Array(this._eligibilityEmbedding);
        return clone;
    }
    
    toJSON() { return { config: { inputDim: this.inputDim, embeddingDim: this.embeddingDim, hidden1: this.hidden1, hidden2: this.hidden2, outputDim: this.outputDim, memoryDim: this.memoryDim, seed: this.seed, lr: this.lr, gamma: this.gamma, lambda: this.lambda, numHeads: this.numHeads, numExperts: this.numExperts, compactInputs: arenaConfig.compactInputs }, inputEmbedding: this._inputEmbedding.map(r => r?.slice() || []), embeddingBias: this._embeddingBias?.slice() || [], W1: this._W1.map(r => r?.slice() || []), W2: this._W2.map(r => r?.slice() || []), W3: this._W3.map(r => r?.slice() || []), Wq: (this._Wq || []).map(r => r?.slice() || []), Wk: (this._Wk || []).map(r => r?.slice() || []), Wv: (this._Wv || []).map(r => r?.slice() || []), Wo: (this._Wo || []).map(r => r?.slice() || []), Wg: (this._Wg || []).map(r => r?.slice() || []), expertW1: this._expertW1.map(m => m.map(r => r?.slice() || [])), expertW2: this._expertW2.map(m => m.map(r => r?.slice() || [])), memoryPermanent: Array.from(this._memoryPermanent), memoryPredictive: Array.from(this._memoryPredictive), predictionErrors: Array.from(this._predictionErrors), trainingStats: this._trainingStats }; }
    
    static fromJSON(data) { if (!data?.config) return new NeuralNetwork({}); const nn = new NeuralNetwork(data.config); try { nn._inputEmbedding = (data.inputEmbedding || []).map(r => (r || []).slice()); nn._embeddingBias = (data.embeddingBias || new Array(nn.embeddingDim).fill(0)).slice(); nn._W1 = (data.W1 || []).map(r => (r || []).slice()); nn._W2 = (data.W2 || []).map(r => (r || []).slice()); nn._W3 = (data.W3 || []).map(r => (r || []).slice()); if (data.Wq) nn._Wq = (data.Wq || []).map(r => (r || []).slice()); if (data.Wk) nn._Wk = (data.Wk || []).map(r => (r || []).slice()); if (data.Wv) nn._Wv = (data.Wv || []).map(r => (r || []).slice()); if (data.Wo) nn._Wo = (data.Wo || []).map(r => (r || []).slice()); if (data.Wg) nn._Wg = (data.Wg || []).map(r => (r || []).slice()); if (data.expertW1) nn._expertW1 = data.expertW1.map(m => (m || []).map(r => (r || []).slice())); if (data.expertW2) nn._expertW2 = data.expertW2.map(m => (m || []).map(r => (r || []).slice())); nn._memoryPermanent = new Float32Array(data.memoryPermanent || new Array(nn.memoryDim).fill(0)); nn._memoryPredictive = new Float32Array(data.memoryPredictive || new Array(nn.memoryDim).fill(0)); nn._predictionErrors = new Float32Array(data.predictionErrors || new Array(nn.memoryDim).fill(0)); if (data.trainingStats) nn._trainingStats = { ...data.trainingStats }; } catch(e) { console.warn('NeuralNetwork.fromJSON: error', e); } return nn; }
    
    getActiveNeurons() { return [...this._activeNeurons]; }
    getGateProbs() { return this._lastGateProbs ? [...this._lastGateProbs] : null; }
    getActiveExperts() { return [...this._lastActiveExperts]; }
}

// ============================================================================
// CRITIC NETWORK ‚Äî VALUE ESTIMATION FOR ACTOR-CRITIC
// ============================================================================
class CriticNetwork {
    constructor(config = {}) {
        this.inputDim = config.inputDim ?? (arenaConfig.compactInputs ? arenaConfig.ARCH.INPUT_DIM_COMPACT : arenaConfig.ARCH.INPUT_DIM);
        this.hidden = config.hidden ?? arenaConfig.ARCH.CRITIC_HIDDEN;
        this.seed = config.seed ?? (arenaConfig.seed + '_CRITIC');
        this._rng = new SeededRNG(this.seed);
        this._W1 = this._rng.deriveWeights(this.inputDim, this.hidden, 0.3);
        this._W2 = this._rng.deriveWeights(this.hidden, 1, 0.1);
        this._b1 = this._rng.deriveVector(this.hidden, 0.1); this._b2 = 0;
        this.lr = config.lr ?? arenaConfig.learningRate; this.gamma = config.gamma ?? arenaConfig.gamma;
    }
    forward(inputs) {
        if (!Array.isArray(inputs) || inputs.length !== this.inputDim) inputs = new Array(this.inputDim).fill(0);
        const hidden = []; for (let o = 0; o < this.hidden; o++) { let sum = Utils.safeNumber(this._b1[o], 0); for (let i = 0; i < inputs.length; i++) sum += Utils.safeNumber(inputs[i], 0) * Utils.safeNumber(this._W1[i]?.[o], 0); hidden.push(Utils.leakyRelu(sum)); }
        let value = this._b2; for (let i = 0; i < this.hidden; i++) value += Utils.safeNumber(hidden[i], 0) * Utils.safeNumber(this._W2[i]?.[0], 0);
        return Utils.clamp(value, -10, 10);
    }
    update(inputs, reward, nextValue, alpha = null) {
        const currentValue = this.forward(inputs), tdErr = Utils.tdError(reward, currentValue, nextValue, this.gamma), lr = alpha ?? this.lr;
        const hidden = []; for (let o = 0; o < this.hidden; o++) { let sum = Utils.safeNumber(this._b1[o], 0); for (let i = 0; i < inputs.length; i++) sum += Utils.safeNumber(inputs[i], 0) * Utils.safeNumber(this._W1[i]?.[o], 0); hidden.push(Utils.leakyRelu(sum)); }
        for (let i = 0; i < this.hidden; i++) { this._W2[i][0] += lr * tdErr * Utils.safeNumber(hidden[i], 0); this._W2[i][0] = Utils.clamp(this._W2[i][0], -2, 2); }
        this._b2 += lr * tdErr;
        for (let i = 0; i < this.inputDim; i++) for (let o = 0; o < this.hidden; o++) { const grad = tdErr * Utils.safeNumber(this._W2[o]?.[0], 0) * (hidden[o] > 0 ? 1 : 0.01); this._W1[i][o] += lr * grad * Utils.safeNumber(inputs[i], 0); this._W1[i][o] = Utils.clamp(this._W1[i][o], -2, 2); }
        return { tdError: tdErr, value: currentValue };
    }
    clone() { const clone = new CriticNetwork({ inputDim: this.inputDim, hidden: this.hidden, seed: this.seed + '_clone', lr: this.lr, gamma: this.gamma }); clone._W1 = this._W1.map(r => r.slice()); clone._W2 = this._W2.map(r => r.slice()); clone._b1 = this._b1.slice(); clone._b2 = this._b2; return clone; }
    toJSON() { return { config: { inputDim: this.inputDim, hidden: this.hidden, seed: this.seed, lr: this.lr, gamma: this.gamma }, W1: this._W1.map(r => r.slice()), W2: this._W2.map(r => r.slice()), b1: this._b1.slice(), b2: this._b2 }; }
    static fromJSON(data) { if (!data?.config) return new CriticNetwork({}); const critic = new CriticNetwork(data.config); critic._W1 = (data.W1 || []).map(r => (r || []).slice()); critic._W2 = (data.W2 || []).map(r => (r || []).slice()); critic._b1 = (data.b1 || []).slice(); critic._b2 = data.b2 ?? 0; return critic; }
}

// ============================================================================
// POLICY SELECTOR ‚Äî LEARNABLE BEHAVIOR MODE SELECTION
// ============================================================================
class PolicySelector {
    constructor(config = {}) {
        this.contextDim = config.contextDim ?? arenaConfig.ARCH.POLICY_CONTEXT_DIM;
        this.skillEmbeddingDim = config.skillEmbeddingDim ?? arenaConfig.ARCH.POLICY_SKILL_DIM;
        this.hidden = config.hidden ?? arenaConfig.ARCH.POLICY_HIDDEN;
        this.numModes = config.numModes ?? arenaConfig.ARCH.POLICY_MODES;
        this.seed = config.seed ?? (arenaConfig.seed + '_POLICY');
        this._rng = new SeededRNG(this.seed);
        this._W1 = this._rng.deriveWeights(this.contextDim + this.skillEmbeddingDim, this.hidden, 0.2);
        this._W2 = this._rng.deriveWeights(this.hidden, this.numModes, 0.15);
        this._b1 = this._rng.deriveVector(this.hidden, 0.1);
        this.lr = config.lr ?? arenaConfig.learningRate * 0.6;
        this.entropyCoeff = config.entropyCoeff ?? arenaConfig.entropyCoeff;
        this._bias = new Array(this.numModes).fill(1);
    }
    forward(context, skillEmbedding) {
        const combined = [...(context || []), ...(skillEmbedding || [])], hidden = [];
        for (let o = 0; o < this.hidden; o++) { let sum = Utils.safeNumber(this._b1[o], 0); for (let i = 0; i < combined.length; i++) sum += Utils.safeNumber(combined[i], 0) * Utils.safeNumber(this._W1[i]?.[o], 0); hidden.push(Utils.leakyRelu(sum)); }
        const logits = []; for (let m = 0; m < this.numModes; m++) { let sum = 0; for (let i = 0; i < this.hidden; i++) sum += Utils.safeNumber(hidden[i], 0) * Utils.safeNumber(this._W2[i]?.[m], 0); logits.push(sum + Math.log(this._bias[m])); }
        const probs = Utils.softmax(logits, 0.8); return { logits, probs, hidden };
    }
    update(context, skillEmbedding, selectedMode, advantage, applyEntropy = true) {
        const { probs, hidden } = this.forward(context, skillEmbedding);
        const safeProb = Math.max(Utils.safeNumber(probs[selectedMode], 0), 1e-10), logProb = Math.log(safeProb), policyLoss = -logProb * advantage;
        let entropy = 0, entropyGrad = 0;
        if (applyEntropy && arenaConfig.entropyCoeff > 0) { entropy = Utils.entropyBonus(probs); entropyGrad = -probs.reduce((sum, p, i) => { const safeP = Math.max(p, 1e-10); return sum + (i === selectedMode ? 1 : 0) * (1 + Math.log(safeP)); }, 0); }
        const totalGrad = advantage - (applyEntropy ? arenaConfig.entropyCoeff * entropyGrad : 0), lr = this.lr * Math.sign(totalGrad);
        for (let i = 0; i < this.hidden; i++) for (let m = 0; m < this.numModes; m++) { const targetGrad = (m === selectedMode ? 1 : 0) - Utils.safeNumber(probs[m], 0); this._W2[i][m] += lr * totalGrad * targetGrad * Utils.safeNumber(hidden[i], 0); this._W2[i][m] = Utils.clamp(this._W2[i][m], -2, 2); }
        return { loss: policyLoss - (applyEntropy ? arenaConfig.entropyCoeff * entropy : 0), entropy, selectedProb: Utils.safeNumber(probs[selectedMode], 0) };
    }
    clone() { const clone = new PolicySelector({ contextDim: this.contextDim, skillEmbeddingDim: this.skillEmbeddingDim, hidden: this.hidden, numModes: this.numModes, seed: this.seed + '_clone', lr: this.lr }); clone._W1 = this._W1.map(r => r.slice()); clone._W2 = this._W2.map(r => r.slice()); clone._b1 = this._b1.slice(); clone._bias = this._bias.slice(); return clone; }
    toJSON() { return { config: { contextDim: this.contextDim, skillEmbeddingDim: this.skillEmbeddingDim, hidden: this.hidden, numModes: this.numModes, seed: this.seed, lr: this.lr }, W1: this._W1.map(r => r.slice()), W2: this._W2.map(r => r.slice()), b1: this._b1.slice(), bias: this._bias.slice() }; }
    static fromJSON(data) { if (!data?.config) return new PolicySelector({}); const ps = new PolicySelector(data.config); ps._W1 = (data.W1 || []).map(r => (r || []).slice()); ps._W2 = (data.W2 || []).map(r => (r || []).slice()); ps._b1 = (data.b1 || []).slice(); ps._bias = data.bias?.slice() || new Array(ps.numModes).fill(1); return ps; }
}

// ============================================================================
// BEHAVIOR ARBITER ‚Äî MODE SELECTION & TARGET CALCULATION
// ============================================================================
class BehaviorArbiter {
    constructor() { this.modes = ['hunt', 'flee', 'explore', 'combat', 'avoid', 'protect', 'heal']; }
    decode(outputs) { return { hunt: Utils.clamp(Utils.safeNumber(outputs?.[0], 0), 0, 1), flee: Utils.clamp(Utils.safeNumber(outputs?.[1], 0), 0, 1), explore: Utils.clamp(Utils.safeNumber(outputs?.[2], 0), 0, 1), combat: Utils.clamp(Utils.safeNumber(outputs?.[3], 0), 0, 1), avoid: Utils.clamp(Utils.safeNumber(outputs?.[4], 0), 0, 1), speed: Utils.clamp(Utils.safeNumber(outputs?.[5], 0), 0, 1), curiosity: Utils.clamp(Utils.safeNumber(outputs?.[6], 0), 0, 1), aggression: Utils.clamp(Utils.safeNumber(outputs?.[7], 0), 0, 1), memoryWeight: Utils.clamp(Utils.safeNumber(outputs?.[8], 0), 0, 1) }; }
    select(behaviors, context, skills = null, myStats = null, enemyStats = null) {
        const myPower = Utils.safeNumber(myStats?.damage, 3) * Utils.safeNumber(myStats?.maxHealth, 100), enemyPower = Utils.safeNumber(enemyStats?.damage, 3) * Utils.safeNumber(enemyStats?.maxHealth, 100);
        if (enemyPower > myPower * 1.5 && Utils.safeNumber(context?.enemyDistance, 999) < 150) { behaviors.flee *= 3.0; behaviors.combat *= 0.1; }
        else if (myPower > enemyPower * 1.2 && Utils.safeNumber(context?.enemyDistance, 999) < 150) { behaviors.combat *= 2.5; behaviors.hunt *= 0.5; }
        else if (Utils.safeNumber(context?.health, 1) < 0.3) { behaviors.flee *= 3.0; behaviors.combat *= 0.1; }
        else if (Utils.safeNumber(context?.enemyDistance, 999) < 100 && Utils.safeNumber(context?.health, 1) > 0.3) { behaviors.combat *= 2.0; }
        else { behaviors.combat *= 0.1; }
        if (Utils.safeNumber(context?.wallDistance, 999) < 2.5) { behaviors.avoid *= 2.0; } else { behaviors.avoid *= 0.3; }
        if (skills) { const skillMap = { 'hunt': Utils.safeNumber(skills.hunting, 0.5), 'flee': Utils.safeNumber(skills.fleeing, 0.5), 'explore': Utils.safeNumber(skills.exploring, 0.5), 'combat': Utils.safeNumber(skills.combat, 0.5), 'avoid': Utils.safeNumber(skills.avoiding, 0.5) }; for (const mode of this.modes) { const skill = skillMap[mode]; if (skill !== undefined) behaviors[mode] *= (0.6 + skill * 0.8); } }
        const scores = this.modes.map(m => Utils.safeNumber(behaviors[m], 0)), mode = this.modes[Utils.argmax(scores)];
        return { mode, behaviors };
    }
    calculateTarget(mode, behaviors, agent, world, networkOutputs = null) {
        const { points, enemies, walls } = world || {};
        switch (mode) {
            case 'hunt': {
                let targets = (points || []).filter(p => p && !p.collected);
                if (agent?.permanent?.memory?.lastFoodPos && Utils.safeNumber(behaviors?.memoryWeight, 0) > 0.5) { const memAge = (world?.step || 0) - (agent.permanent.memory.lastFoodStep || 0); if (memAge < 100) targets = [...targets, { x: agent.permanent.memory.lastFoodPos.x, y: agent.permanent.memory.lastFoodPos.y, value: 1, type: 'remembered' }]; }
                if (networkOutputs?.length >= 12) { const dirBiasX = Utils.tanh(networkOutputs[9] || 0) * 30, dirBiasY = Utils.tanh(networkOutputs[10] || 0) * 30, priorityMod = Utils.safeNumber(networkOutputs[11] || 0.5, 0.5) * 2; targets.forEach(t => { t.x += dirBiasX * priorityMod * 0.15; t.y += dirBiasY * priorityMod * 0.15; }); targets.sort((a, b) => { const distA = Math.max(0, Utils.dist(agent, a) - priorityMod * 10), distB = Math.max(0, Utils.dist(agent, b) - priorityMod * 10); return distA - distB; }); } else { targets.sort((a, b) => Utils.dist(agent, a) - Utils.dist(agent, b)); }
                return targets[0] || { x: Utils.clamp((agent?.x || 400) + Utils.rand(-100, 100), 25, 795), y: Utils.clamp((agent?.y || 300) + Utils.rand(-75, 75), 25, 575) };
            }
            case 'flee': { const threats = (enemies || []).filter(e => e && e.id !== agent?.id && e.alive); if (!threats.length) return { x: Utils.clamp((agent?.x || 400) + Utils.rand(-80, 80), 25, 795), y: Utils.clamp((agent?.y || 300) + Utils.rand(-60, 60), 25, 575) }; let threat = threats.reduce((n, e) => Utils.dist(agent, e) < Utils.dist(agent, n) ? e : n); if (agent?.predictive?.predictedEnemy && Utils.safeNumber(agent.predictive?.confidence, 0) > 0.7) threat = { ...threat, ...agent.predictive.predictedEnemy }; const away = Utils.normalize((agent?.x || 0) - threat.x, (agent?.y || 0) - threat.y); if (networkOutputs?.length >= 12) return { x: (agent?.x || 0) + (away.x + Utils.tanh(networkOutputs[9] || 0) * 0.3) * 40, y: (agent?.y || 0) + (away.y + Utils.safeNumber(networkOutputs[10] || 0, 0) * 0.3) * 40 }; return { x: (agent?.x || 0) + away.x * 40, y: (agent?.y || 0) + away.y * 40 }; }
            case 'explore': { if (Utils.safeNumber(behaviors?.curiosity, 0) > 0.7 && agent?.permanent?.memory?.unvisited?.length) return agent.permanent.memory.unvisited[Utils.randInt(0, agent.permanent.memory.unvisited.length - 1)]; if (networkOutputs?.length >= 12) return { x: Utils.clamp((agent?.x || 0) + Utils.tanh(networkOutputs[9] || 0) * 120, 25, 795), y: Utils.clamp((agent?.y || 0) + Utils.tanh(networkOutputs[10] || 0) * 90, 25, 575) }; return { x: Utils.clamp((agent?.x || 0) + Utils.rand(-120, 120), 25, 795), y: Utils.clamp((agent?.y || 0) + Utils.rand(-90, 90), 25, 575) }; }
            case 'combat': { const targets = (enemies || []).filter(e => e && e.id !== agent?.id && e.alive); if (!targets.length) return { x: agent?.x || 0, y: agent?.y || 0 }; let target = targets.reduce((n, e) => Utils.dist(agent, e) < Utils.dist(agent, n) ? e : n); if (agent?.predictive?.predictedEnemy && Utils.safeNumber(agent.predictive?.confidence, 0) > 0.65) target = { ...target, ...agent.predictive.predictedEnemy }; return target; }
            case 'avoid': { const nearWalls = (walls || []).filter(w => w && Utils.dist(agent, w) < 30); if (!nearWalls.length) return { x: agent?.x || 0, y: agent?.y || 0 }; const wall = nearWalls.reduce((n, w) => Utils.dist(agent, w) < Utils.dist(agent, n) ? w : n); const toWall = Utils.normalize(wall.x - (agent?.x || 0), wall.y - (agent?.y || 0)); const tangent = { x: -toWall.y, y: toWall.x }; if (networkOutputs?.length >= 12 && Utils.safeNumber(networkOutputs[9], 0) < 0) return { x: (agent?.x || 0) - tangent.x * 25, y: (agent?.y || 0) - tangent.y * 25 }; return { x: (agent?.x || 0) + tangent.x * 25, y: (agent?.y || 0) + tangent.y * 25 }; }
            case 'protect': { const weakTeammate = (world?.agents || []).find(a => a?.alive && a?.team === agent?.team && a?.health < a?.stats?.maxHealth * 0.3); if (weakTeammate) { const enemies = (world?.agents || []).filter(e => e?.alive && e?.team !== agent?.team && Utils.dist(e, weakTeammate) < 50); if (enemies.length > 0) { const enemy = enemies[0]; return { x: weakTeammate.x + (weakTeammate.x - enemy.x) * 0.3, y: weakTeammate.y + (weakTeammate.y - enemy.y) * 0.3 }; } return { x: weakTeammate.x + Utils.rand(-10, 10), y: weakTeammate.y + Utils.rand(-10, 10) }; } return { x: agent?.x || 0, y: agent?.y || 0 }; }
            case 'heal': { const injured = (world?.agents || []).find(a => a?.alive && a?.team === agent?.team && a?.health < a?.stats?.maxHealth * 0.6 && a?.id !== agent?.id); if (injured) return { x: injured.x, y: injured.y }; return { x: agent?.x || 0, y: agent?.y || 0 }; }
            default: return { x: agent?.x || 0, y: agent?.y || 0 };
        }
    }
}

// ============================================================================
// SMART POINT ‚Äî DYNAMIC COLLECTIBLES
// ============================================================================
class SmartPoint {
    constructor(x, y, type = 'normal') { this.x = x; this.y = y; this.type = type; this.collected = false; this.value = type === 'rare' ? 20 : (type === 'scared' ? 8 : 5); this.fleeRadius = type === 'scared' ? 7 : 0; this.color = type === 'rare' ? '#ffaa00' : (type === 'scared' ? '#ff66cc' : '#00ff9d'); this.radius = type === 'rare' ? 6 : 4; this.vx = 0; this.vy = 0; }
    update(nearestAgent, dt) { if (this.collected) return; if (this.type === 'scared' && nearestAgent && Utils.dist(this, nearestAgent) < this.fleeRadius) { const away = Utils.normalize(this.x - nearestAgent.x, this.y - nearestAgent.y); this.vx = Utils.lerp(this.vx, away.x * 1.5, 0.1); this.vy = Utils.lerp(this.vy, away.y * 1.5, 0.1); } else { this.vx = Utils.lerp(this.vx, Utils.rand(-0.3, 0.3), 0.02); this.vy = Utils.lerp(this.vy, Utils.rand(-0.3, 0.3), 0.02); } this.x += this.vx * dt; this.y += this.vy * dt; this.x = Utils.clamp(this.x, 20, 800); this.y = Utils.clamp(this.y, 20, 580); }
    draw(ctx) { if (this.collected) return; ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fill(); if (this.type === 'rare') { ctx.strokeStyle = '#ffdd44'; ctx.lineWidth = 2; ctx.stroke(); } }
}

// ============================================================================
// PROJECTILE ‚Äî RANGED COMBAT
// ============================================================================
class Projectile {
    constructor(x, y, vx, vy, owner, damage = 3, life = 80) { this.x = x; this.y = y; this.vx = vx; this.vy = vy; this.owner = owner; this.damage = damage; this.life = life; this.alive = true; this.radius = 3; }
    update(dt) { this.x += this.vx * dt * 8; this.y += this.vy * dt * 8; this.life -= dt; if (this.life <= 0) this.alive = false; }
    draw(ctx) { if (!this.alive) return; ctx.fillStyle = '#ffdd44'; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fill(); }
}

// ============================================================================
// ENEMY PREDICTOR ‚Äî ADVERSARY BEHAVIOR MODELING
// ============================================================================
class EnemyPredictor {
    constructor() { this.history = []; this.maxHistory = 50; this.patterns = { movingRight: 0, movingLeft: 0, movingDown: 0, movingUp: 0, fleeing: 0, aggressive: 0, unpredictable: 0 }; }
    recordMove(action, distance, health, aggression) { this.history.push({ action: { ...action }, distance, health, aggression, time: Date.now() }); if (this.history.length > this.maxHistory) this.history.shift(); }
    predictNextAction() { if (this.history.length < 5) return 'unpredictable'; const recent = this.history.slice(-5); const avgX = recent.reduce((s, m) => s + Utils.safeNumber(m.action?.fx, 0), 0) / recent.length; const avgY = recent.reduce((s, m) => s + Utils.safeNumber(m.action?.fy, 0), 0) / recent.length; const avgAgg = recent.reduce((s, m) => s + Utils.safeNumber(m.action?.aggression, 0.5), 0) / recent.length; if (Math.abs(avgAgg) > 0.7) return avgAgg > 0 ? 'aggressive' : 'fleeing'; if (Math.abs(avgX) > 0.6) return avgX > 0 ? 'movingRight' : 'movingLeft'; if (Math.abs(avgY) > 0.6) return avgY > 0 ? 'movingDown' : 'movingUp'; return 'unpredictable'; }
    getWeakpoints() { if (this.history.length < 5) return []; return this.history.slice(-10).filter(m => Utils.safeNumber(m.health, 1) < 0.5).map(m => ({ direction: m.action, health: m.health })); }
}

// ============================================================================
// STRATEGY MEMORY ‚Äî WINNING TACTICS STORAGE
// ============================================================================
class StrategyMemory {
    constructor() { this.winningStrategies = []; this.fightHistory = {}; this.maxStrategies = 20; }
    recordFight(opponentId, won, weights, tactics, accuracy) { if (!this.fightHistory[opponentId]) this.fightHistory[opponentId] = { wins: 0, losses: 0, lastTactics: null, bestAccuracy: 0 }; const hist = this.fightHistory[opponentId]; if (won) { hist.wins++; hist.lastTactics = tactics; hist.bestAccuracy = Math.max(hist.bestAccuracy, accuracy || 0); } else { hist.losses++; } }
    saveWinningStrategy(weights, opponentId, tactics, accuracy) { if (accuracy <= 0.65) return; this.winningStrategies.push({ weights: Utils.deepClone(weights), against: opponentId, tactics, winRate: accuracy, timestamp: Date.now() }); if (this.winningStrategies.length > this.maxStrategies) { this.winningStrategies.sort((a, b) => a.winRate - b.winRate); this.winningStrategies.shift(); } }
    loadSimilarStrategy(opponentId) { const strategies = this.winningStrategies.filter(s => s.against === opponentId); return strategies.length > 0 ? strategies[strategies.length - 1] : null; }
}

// ============================================================================
// AGENT ‚Äî COMPLETE NEURAL ENTITY WITH SOCIAL MEMORY
// ============================================================================
class Agent {
    constructor(id, x, y, color, seed) {
        this.id = id; this.x = x; this.y = y; this.color = color; this.vx = 0; this.vy = 0; this.alive = true;
        this.stats = { maxHealth: 100, damage: 3, fireRate: 15, dodgeChance: 0.0 };
        this.health = this.stats.maxHealth; this.lastMutationType = null; this.seed = seed;
        this.numExperts = arenaConfig.ARCH.NUM_EXPERTS;
        const useCompact = arenaConfig.compactInputs;
        this.net = new NeuralNetwork({ inputDim: useCompact ? arenaConfig.ARCH.INPUT_DIM_COMPACT : arenaConfig.ARCH.INPUT_DIM, embeddingDim: useCompact ? arenaConfig.ARCH.EMBEDDING_DIM_COMPACT : arenaConfig.ARCH.EMBEDDING_DIM, hidden1: arenaConfig.ARCH.HIDDEN1, hidden2: arenaConfig.ARCH.HIDDEN2, outputDim: arenaConfig.ARCH.OUTPUT_DIM, memoryDim: arenaConfig.ARCH.MEMORY_DIM, seed: seed + '_NET', lr: arenaConfig.learningRate, gamma: arenaConfig.gamma, lambda: arenaConfig.lambda, numHeads: arenaConfig.ARCH.NUM_HEADS, numExperts: this.numExperts, compactInputs: useCompact });
        this.critic = new CriticNetwork({ inputDim: useCompact ? arenaConfig.ARCH.INPUT_DIM_COMPACT : arenaConfig.ARCH.INPUT_DIM, hidden: arenaConfig.ARCH.CRITIC_HIDDEN, seed: seed + '_CRITIC', lr: arenaConfig.learningRate, gamma: arenaConfig.gamma });
        this.policySelector = new PolicySelector({ contextDim: arenaConfig.ARCH.POLICY_CONTEXT_DIM, skillEmbeddingDim: arenaConfig.ARCH.POLICY_SKILL_DIM, hidden: arenaConfig.ARCH.POLICY_HIDDEN, numModes: arenaConfig.ARCH.POLICY_MODES, seed: seed + '_POLICY', lr: arenaConfig.learningRate * 0.6 });
        this.experts = []; for (let i = 0; i < this.numExperts; i++) { this.experts.push(new NeuralNetwork({ inputDim: useCompact ? arenaConfig.ARCH.INPUT_DIM_COMPACT : arenaConfig.ARCH.INPUT_DIM, embeddingDim: useCompact ? arenaConfig.ARCH.EMBEDDING_DIM_COMPACT : arenaConfig.ARCH.EMBEDDING_DIM, hidden1: arenaConfig.ARCH.HIDDEN1, hidden2: arenaConfig.ARCH.HIDDEN2, outputDim: arenaConfig.ARCH.OUTPUT_DIM, memoryDim: arenaConfig.ARCH.MEMORY_DIM, seed: seed + '_EXP_' + i, lr: arenaConfig.learningRate, gamma: arenaConfig.gamma, lambda: arenaConfig.lambda, numHeads: arenaConfig.ARCH.NUM_HEADS, compactInputs: useCompact })); }
        this.arbiter = new BehaviorArbiter(); this.mode = 'explore'; this.target = { x, y }; this.speed = 1; this.stuckCounter = 0; this.lastPos = { x, y }; this.cumulativeReward = 0;
        this.skillEmbedding = [0.3, 0.4, 0.2, 0.5, 0.6];
        this.permanent = { skills: { hunting: 0.3 + Math.random() * 0.2, fleeing: 0.4 + Math.random() * 0.2, combat: 0.2 + Math.random() * 0.2, exploring: 0.5, avoiding: 0.6 }, strategies: { huntPattern: 'direct', fleeDirection: 'away', combatStyle: 'direct' }, preferences: { foodType: 'any', enemyType: 'any', territory: 'any' }, muscleMemory: new Float32Array(16).fill(0), memory: { lastFoodPos: null, lastFoodStep: 0, visited: new Set(), unvisited: [] } };
        this.predictive = { shortTerm: { positions: [], actions: [], results: [], enemyHistory: [], foodHistory: [] }, patterns: { enemyMovement: null, foodSpawn: null, dangerZones: new Map() }, predictions: { enemyPos: { x: 0, y: 0 }, foodPos: { x: 0, y: 0 }, collision: false, success: 0.5 }, confidence: 0.5, predictionError: 0 };
        this.enemyPredictor = new EnemyPredictor(); this.strategyMemory = new StrategyMemory(); this.currentTactic = 'aggressive'; this.fightStartTime = 0; this.fightOpponent = null; this.attackCooldown = 0; this.attackRange = 35; this.wins = 0; this.mutations = 0; this.generation = 1; this.trail = []; this.lastDecision = null; this._lastWorld = null;
        this.learningBuffer = { states: [], actions: [], rewards: [], nextStates: [], dones: [], values: [], maxBuffer: 32 };
        this.team = null; this.teamRole = null; this.healPower = 3;
        this.socialMemory = { team: { id: null, trust: 0.7 }, individuals: new Map(), otherTeams: new Map(), reputation: 0, fame: 0, allies: new Set(), enemies: new Set(), lastCooperation: new Map() };
        this.lastAttacker = null; this.willRespawn = true;
    }
    getInputs(world) {
        const inputs = [], maxDist = Math.sqrt(820 ** 2 + 600 ** 2), useCompact = arenaConfig.compactInputs;
        if (useCompact) {
            const points = (world?.points || []).filter(p => p && !p.collected).map(p => ({ ...p, d: Utils.dist(this, p) })).sort((a, b) => a.d - b.d).slice(0, 5);
            for (const p of points) { inputs.push(Utils.clamp((p.x - this.x) / maxDist, -1, 1), Utils.clamp((p.y - this.y) / maxDist, -1, 1), Utils.clamp((100 - p.d) / 100, 0, 1)); }
            const enemies = (world?.agents || []).filter(e => e && e.id !== this.id && e.alive).map(e => ({ ...e, d: Utils.dist(this, e) })).sort((a, b) => a.d - b.d)[0];
            if (enemies) { inputs.push(Utils.clamp((enemies.x - this.x) / maxDist, -1, 1), Utils.clamp((enemies.y - this.y) / maxDist, -1, 1), Utils.clamp((150 - enemies.d) / 150, 0, 1), enemies.health / enemies.stats.maxHealth); } else { inputs.push(0, 0, 0, 0); }
            const walls = (world?.walls || []).map(w => ({ ...w, d: Utils.dist(this, w) })).sort((a, b) => a.d - b.d)[0];
            if (walls) { inputs.push(Utils.clamp((walls.x - this.x) / maxDist, -1, 1), Utils.clamp((walls.y - this.y) / maxDist, -1, 1), Utils.clamp((60 - walls.d) / 60, 0, 1)); } else { inputs.push(0, 0, 0); }
            inputs.push(Utils.clamp((400 - this.x) / 400, -1, 1), Utils.clamp((300 - this.y) / 300, -1, 1), this.health / this.stats.maxHealth, Utils.clamp(this.cumulativeReward / 20, -1, 1));
            while (inputs.length < 25) inputs.push(0); return inputs.map(v => Utils.safeNumber(v, 0));
        }
        const points = (world?.points || []).filter(p => p && !p.collected).map(p => ({ ...p, d: Utils.dist(this, p) })).sort((a, b) => a.d - b.d).slice(0, 5);
        for (let i = 0; i < 5; i++) { const p = points[i]; if (p) { const los = Utils.hasLineOfSight(this, p, world?.walls || []) ? 1 : 0; inputs.push(Utils.clamp((p.x - this.x) / maxDist, -1, 1), Utils.clamp((p.y - this.y) / maxDist, -1, 1), Utils.clamp((100 - p.d) / 100, 0, 1), los); } else { inputs.push(0, 0, 0, 0); } }
        const enemies = (world?.agents || []).filter(e => e && e.id !== this.id && e.alive).map(e => ({ ...e, d: Utils.dist(this, e) })).sort((a, b) => a.d - b.d).slice(0, 5);
        for (let i = 0; i < 5; i++) { const e = enemies[i]; if (e) { const los = Utils.hasLineOfSight(this, e, world?.walls || []) ? 1 : 0; inputs.push(Utils.clamp((e.x - this.x) / maxDist, -1, 1), Utils.clamp((e.y - this.y) / maxDist, -1, 1), Utils.clamp((120 - e.d) / 120, 0, 1), los); } else { inputs.push(0, 0, 0, 0); } }
        const walls = (world?.walls || []).map(w => ({ ...w, d: Utils.dist(this, w) })).sort((a, b) => a.d - b.d).slice(0, 3);
        for (let i = 0; i < 3; i++) { const w = walls[i]; if (w) { inputs.push(Utils.clamp((w.x - this.x) / maxDist, -1, 1), Utils.clamp((w.y - this.y) / maxDist, -1, 1), Utils.clamp((60 - w.d) / 60, 0, 1)); } else { inputs.push(0, 0, 0); } }
        inputs.push(Utils.clamp((400 - this.x) / 400, -1, 1), Utils.clamp((300 - this.y) / 300, -1, 1), this.health / this.stats.maxHealth, Utils.clamp((world?.step || 0) / 2000, 0, 1), Utils.clamp((world?.points || []).filter(p => p && !p.collected && Utils.dist(this, p) < 120).length / 15, 0, 1), Utils.clamp((world?.agents || []).filter(e => e && e.id !== this.id && e.alive && Utils.dist(this, e) < 160).length / 10, 0, 1), Utils.clamp(Math.min(this.x, 820 - this.x, this.y, 600 - this.y) / 100, 0, 1), Utils.clamp(this.cumulativeReward / 20, -1, 1));
        while (inputs.length < arenaConfig.ARCH.INPUT_DIM) inputs.push(0); if (inputs.length > arenaConfig.ARCH.INPUT_DIM) inputs.length = arenaConfig.ARCH.INPUT_DIM;
        return inputs.map(v => Utils.safeNumber(v, 0));
    }
    selectBehavior(world, networkOutput) {
        const enemies = (world?.agents || []).filter(e => e && e.id !== this.id && e.alive);
        const context = [ enemies.length > 0 ? Utils.clamp(Utils.dist(this, enemies[0]) / 200, 0, 1) : 1, (world?.walls || []).length ? Utils.clamp(Math.min(...(world.walls.map(w => Utils.dist(this, w)))) / 60, 0, 1) : 0, this.health / this.stats.maxHealth, Utils.clamp(Utils.safeNumber(networkOutput?.[5], 0.5), 0, 1), Utils.clamp(Utils.safeNumber(networkOutput?.[6], 0.5), 0, 1), Utils.clamp(Utils.safeNumber(networkOutput?.[7], 0.5), 0, 1), this.permanent.skills.hunting, this.permanent.skills.fleeing ];
        const skillEmbedding = [this.permanent.skills.hunting, this.permanent.skills.fleeing, this.permanent.skills.combat, this.permanent.skills.exploring, this.permanent.skills.avoiding];
        const { probs } = this.policySelector.forward(context, skillEmbedding);
        const modeIdx = Utils.argmax(probs), modes = ['hunt', 'flee', 'explore', 'combat', 'avoid'], selectedMode = modes[modeIdx];
        if (this.lastDecision?.advantage !== undefined && arenaConfig.enablePolicySelector) { this.policySelector.update(context, skillEmbedding, modeIdx, this.lastDecision.advantage); }
        return { mode: selectedMode, modeProbs: probs };
    }
    decide(world) {
        this._lastWorld = { agents: (world?.agents || []).map(a => a ? { id: a.id, x: a.x, y: a.y, alive: a.alive, health: a.health, stats: { ...a.stats }, team: a.team } : null).filter(a => a), walls: (world?.walls || []).map(w => w ? { x: w.x, y: w.y } : null).filter(w => w), step: world?.step || 0 };
        this.updatePredictiveMemory(world);
        const inputs = this.getInputs(world), gateRes = this.net.forward(inputs), output = gateRes.output;
        const { mode, modeProbs } = this.selectBehavior(world, output); this.mode = mode;
        const behaviors = { speed: Utils.clamp(Utils.safeNumber(output?.[5], 0), 0, 1), curiosity: Utils.clamp(Utils.safeNumber(output?.[6], 0), 0, 1), aggression: Utils.clamp(Utils.safeNumber(output?.[7], 0), 0, 1), memoryWeight: Utils.clamp(Utils.safeNumber(output?.[8], 0), 0, 1) };
        const enemies = (world?.agents || []).filter(e => e && e.id !== this.id && e.alive), enemy = enemies.length > 0 ? enemies[0] : null;
        const context = { enemyDistance: enemy ? Utils.dist(this, enemy) : 999, wallDistance: (world?.walls || []).length ? Math.min(...world.walls.map(w => Utils.dist(this, w))) : 999, health: this.health / this.stats.maxHealth };
        let target = this.arbiter.calculateTarget(mode, behaviors, this, { points: world?.points || [], agents: world?.agents || [], walls: world?.walls || [] }, output);
        if (!target || typeof target.x !== 'number' || !isFinite(target.x) || typeof target.y !== 'number' || !isFinite(target.y)) { target = { x: Utils.clamp(this.x + Utils.rand(-50, 50), 30, 790), y: Utils.clamp(this.y + Utils.rand(-50, 50), 30, 570) }; }
        this.target = target;
        const confidenceMod = this.predictive.confidence > 0.7 ? 1.1 : (this.predictive.confidence < 0.4 ? 0.9 : 1);
        this.speed = Utils.lerp(this.speed, behaviors.speed * 2.5 * confidenceMod + 0.5, 0.08);
        if (mode === 'hunt' && behaviors.memoryWeight > 0.5) { const nearby = (world?.points || []).filter(p => p && !p.collected && Utils.dist(this, p) < 20); if (nearby.length && !this.permanent.memory.lastFoodPos) { this.permanent.memory.lastFoodPos = { ...nearby[0] }; this.permanent.memory.lastFoodStep = world?.step || 0; } }
        const cell = `${Math.floor(this.x / 25)},${Math.floor(this.y / 25)}`; if (!this.permanent.memory.visited.has(cell)) { this.permanent.memory.visited.add(cell); if (this.permanent.memory.unvisited.length > 60) this.permanent.memory.unvisited.shift(); this.permanent.memory.unvisited.push({ x: this.x + Utils.rand(-40, 40), y: this.y + Utils.rand(-30, 30) }); }
        if (this.team !== null && arenaConfig.gameMode.type === 'tournament') { const team = world.teams?.get(this.team); if (team?.members?.length > 1) { this._applyTeamBehavior(world, team, output); } }
        this.lastDecision = { mode, behaviors, inputs, output, modeProbs, value: this.critic.forward(inputs), nextValue: null };
        return { target: this.target, speed: this.speed, mode, behaviors, inputs, output };
    }
    _applyTeamBehavior(world, team, neuralOutput) {
        const teammates = team.members.filter(m => m.alive && m.id !== this.id); if (!teammates.length) return;
        const nearbyFood = (world.points || []).filter(p => !p.collected && teammates.some(tm => Utils.dist(tm, p) < 80));
        if (nearbyFood.length > 0 && this.permanent.skills.hunting > 0.5) { const bestFood = nearbyFood.reduce((best, f) => (f.value || 5) > (best.value || 5) ? f : best); const nearbyAllies = teammates.filter(tm => Utils.dist(tm, bestFood) < 60).length; if (nearbyAllies >= 2) { neuralOutput[0] = Math.min(1, neuralOutput[0] + 0.3); this.target = bestFood; this._recordCooperation('hunt', true); } }
        const threatened = teammates.filter(tm => { const enemies = world.agents.filter(a => a.alive && a.team !== this.team && Utils.dist(a, tm) < 50); return tm.health < tm.stats.maxHealth * 0.5 && enemies.length > 0; });
        if (threatened.length > 0 && (this.teamRole === 'tank' || this.teamRole === 'fighter')) { const mostThreatened = threatened.reduce((worst, t) => t.health / t.stats.maxHealth < worst.health / worst.stats.maxHealth ? t : worst); neuralOutput[3] = Math.min(1, neuralOutput[3] + 0.4); this.target = mostThreatened; this.currentTactic = 'protect'; this._recordCooperation('defend', true); }
        const allies = teammates.filter(tm => Utils.dist(tm, this) < 40); if (allies.length > 0 && neuralOutput[3] > 0.7) { const enemies = world.agents.filter(a => a.alive && a.team !== this.team); const bestEnemy = enemies.reduce((best, e) => Utils.dist(this, e) < Utils.dist(this, best) ? e : best, enemies[0]); if (bestEnemy && allies.some(a => Utils.dist(a, bestEnemy) < 30)) { neuralOutput[3] *= 0.5; neuralOutput[1] = Math.min(1, neuralOutput[1] + 0.2); } }
        const leader = teammates.find(tm => tm.teamRole === 'leader' && tm.alive); if (leader && this.teamRole !== 'leader' && Utils.dist(this, leader) > 100) { if (Math.random() < 0.3) { this.target = { x: leader.x + Utils.rand(-20, 20), y: leader.y + Utils.rand(-20, 20) }; neuralOutput[2] = Math.min(1, neuralOutput[2] + 0.2); } }
    }
    _recordCooperation(action, success) { const timestamp = Date.now(); this.socialMemory.lastCooperation.set(action, { success, timestamp }); }
    move(target, speed, walls, dt, networkOutputs = null) {
        const desired = Utils.normalize(target.x - this.x, target.y - this.y), wallRep = this.getWallRepulsion(walls); let finalDir;
        if (wallRep.strength > 0.8) { const tangent = { x: -wallRep.y, y: wallRep.x }, noise = Utils.rand(-0.3, 0.3); finalDir = { x: tangent.x + noise, y: tangent.y + noise }; const mag = Math.hypot(finalDir.x, finalDir.y) || 1; finalDir.x /= mag; finalDir.y /= mag; }
        else { finalDir = { x: Utils.lerp(desired.x, wallRep.x, wallRep.strength * 0.6), y: Utils.lerp(desired.y, wallRep.y, wallRep.strength * 0.6) }; const mag = Math.hypot(finalDir.x, finalDir.y); if (mag < 0.1) finalDir = desired; else { finalDir.x /= mag; finalDir.y /= mag; } }
        if (this.currentTactic && this.currentTactic !== 'adaptive') finalDir = this.executeTactic(finalDir, target, walls);
        if (networkOutputs?.length >= 14) { const neuralModX = Utils.tanh(networkOutputs[12] || 0) * 0.2, neuralModY = Utils.tanh(networkOutputs[13] || 0) * 0.2; finalDir.x = Utils.clamp(finalDir.x + neuralModX, -1, 1); finalDir.y = Utils.clamp(finalDir.y + neuralModY, -1, 1); const mag = Math.hypot(finalDir.x, finalDir.y) || 1; finalDir.x /= mag; finalDir.y /= mag; }
        const minSpeed = 0.3, actualSpeed = Math.max(speed, minSpeed);
        this.vx = Utils.lerp(this.vx, finalDir.x * actualSpeed, 0.15); this.vy = Utils.lerp(this.vy, finalDir.y * actualSpeed, 0.15);
        if (Math.abs(this.vx) < 0.02) this.vx = finalDir.x * minSpeed; if (Math.abs(this.vy) < 0.02) this.vy = finalDir.y * minSpeed;
        this.x += this.vx * dt; this.y += this.vy * dt;
        if (this.x < 20) { this.x = 20; this.vx *= -0.4; } if (this.x > 800) { this.x = 800; this.vx *= -0.4; }
        if (this.y < 20) { this.y = 20; this.vy *= -0.4; } if (this.y > 580) { this.y = 580; this.vy *= -0.4; }
        for (const w of walls) { if (Utils.dist(this, w) < 15) { const push = Utils.normalize(this.x - w.x, this.y - w.y); this.x += push.x * 0.6; this.y += push.y * 0.6; this.vx *= -0.25; this.vy *= -0.25; } }
    }
    executeTactic(direction, target, walls) {
        const tactic = this.currentTactic; let tacticDir = { ...direction };
        const enemies = (typeof window !== 'undefined' && window.arenaGame?.world?.agents) ? window.arenaGame.world.agents.filter(e => e && e.id !== this.id && e.alive) : [];
        if (enemies.length > 0) { const enemy = enemies[0], dist = Utils.dist(this, enemy); if (tactic === 'kite' && dist < 50) { const angle = Math.atan2(direction.y, direction.x) + Math.PI / 2; tacticDir = { x: Math.cos(angle) * 0.8, y: Math.sin(angle) * 0.8 }; } else if (tactic === 'dodge' && dist < 40) { const angle = Math.atan2(direction.y, direction.x) + (Math.random() > 0.5 ? 1 : -1) * Math.PI / 3; tacticDir = { x: Math.cos(angle), y: Math.sin(angle) }; } else if (tactic === 'defensive' && dist < 30) { const away = Utils.normalize(this.x - enemy.x, this.y - enemy.y); tacticDir = { x: away.x * 0.8, y: away.y * 0.8 }; } else if (dist < 25) { const away = Utils.normalize(this.x - enemy.x, this.y - enemy.y); tacticDir = { x: away.x, y: away.y }; } }
        const mag = Math.hypot(tacticDir.x, tacticDir.y) || 1; tacticDir.x /= mag; tacticDir.y /= mag; return tacticDir;
    }
    getWallRepulsion(walls) { let repulsion = { x: 0, y: 0 }; for (const w of walls) { const d = Utils.dist(this, w); if (d < 40) { const force = (40 - d) / 40, away = Utils.normalize(this.x - w.x, this.y - w.y); repulsion.x += away.x * force; repulsion.y += away.y * force; } } const mag = Math.hypot(repulsion.x, repulsion.y); return mag > 0 ? { x: repulsion.x / mag, y: repulsion.y / mag, strength: Utils.clamp(mag, 0, 1) } : { x: 0, y: 0, strength: 0 }; }
    calculateReward(world, decision) {
        let reward = 0;
        for (const p of (world?.points || [])) { if (p && !p.collected) { const d = Utils.dist(this, p); if (d < 18) { p.collected = true; reward += p.value; } } }
        const veryNear = (world?.points || []).find(p => p && !p.collected && Utils.dist(this, p) < 10); if (veryNear) { veryNear.collected = true; reward += veryNear.value; }
        const newCell = `${Math.floor(this.x / 25)},${Math.floor(this.y / 25)}`; if (!this.permanent.memory.visited.has(newCell)) reward += 0.06;
        if (decision?.target) { const prevDist = Utils.dist(this.lastPos, decision.target), currDist = Utils.dist({ x: this.x, y: this.y }, decision.target); if (currDist < prevDist - 0.5) reward += 0.02; }
        const moved = Math.hypot(this.x - this.lastPos.x, this.y - this.lastPos.y); if (moved < 0.6) { this.stuckCounter++; if (this.stuckCounter > 15) reward -= 0.1; } else { this.stuckCounter = 0; }
        if (Math.min(this.x, 820 - this.x, this.y, 600 - this.y) < 12) reward -= 0.03;
        reward -= (1 - this.health / this.stats.maxHealth) * 0.12;
        this.lastPos = { x: this.x, y: this.y }; this.cumulativeReward += reward; return reward;
    }
    learn(reward, decision, nextInputs = null) {
        if (!decision || !arenaConfig.enableTraining) return;
        const currentValue = decision.value, nextValue = nextInputs ? this.critic.forward(nextInputs) : 0;
        const criticResult = this.critic.update(decision.inputs, reward, nextValue);
        const tdResult = this.net.tdLearn(decision.inputs, decision.output, reward, currentValue, nextValue, decision.modeProbs ? Utils.logSoftmax(decision.modeProbs.map(p => Math.log(Math.max(p, 1e-10)) * 10), 1) : null);
        this.net.updateDiagnostics({ win: null, collected: reward >= 5, survival: this.health / this.stats.maxHealth, reward });
        if (reward > 3 && arenaConfig.enableSkillEvolution) this.updatePermanentSkills(reward, decision.mode, arenaConfig.skillGrowthRate);
        if (reward > 4) this.updateMuscleMemory(decision.output, reward);
        this.learningBuffer.states.push(decision.inputs); this.learningBuffer.actions.push(decision.output); this.learningBuffer.rewards.push(reward); this.learningBuffer.values.push(currentValue);
        if (this.learningBuffer.states.length >= this.learningBuffer.maxBuffer) this._batchLearn();
    }
    _batchLearn() {
        if (!arenaConfig.enableTraining) { this._clearLearningBuffer(); return; }
        const advantages = Utils.computeGAE(this.learningBuffer.rewards, this.learningBuffer.values, 0, this.net.gamma, this.net.lambda);
        for (let t = 0; t < advantages.length; t++) {
            if (this.lastDecision?.modeProbs && arenaConfig.enablePolicySelector) {
                const modeIdx = ['hunt', 'flee', 'explore', 'combat', 'avoid'].indexOf(this.mode);
                if (modeIdx >= 0) {
                    const enemies = (this._lastWorld?.agents || []).filter(e => e && e.id !== this.id && e.alive);
                    const context = [ enemies.length > 0 ? Utils.clamp(Utils.dist(this, enemies[0]) / 200, 0, 1) : 1, (this._lastWorld?.walls || []).length ? Utils.clamp(Math.min(...this._lastWorld.walls.map(w => Utils.dist(this, w))) / 60, 0, 1) : 0, this.health / this.stats.maxHealth, Utils.clamp(Utils.safeNumber(this.lastDecision.output?.[5], 0.5), 0, 1), Utils.clamp(Utils.safeNumber(this.lastDecision.output?.[6], 0.5), 0, 1), Utils.clamp(Utils.safeNumber(this.lastDecision.output?.[7], 0.5), 0, 1), this.permanent.skills.hunting, this.permanent.skills.fleeing ];
                    this.policySelector.update(context, this.skillEmbedding, modeIdx, advantages[t]);
                }
            }
        }
        this._clearLearningBuffer();
    }
    _clearLearningBuffer() { this.learningBuffer = { states: [], actions: [], rewards: [], nextStates: [], dones: [], values: [], maxBuffer: 32 }; this._lastWorld = null; }
    updatePermanentSkills(reward, mode, skillGrowthRate) {
        if (reward <= 3 || !arenaConfig.enableSkillEvolution) return;
        const skillMap = { 'hunt': 'hunting', 'flee': 'fleeing', 'combat': 'combat', 'explore': 'exploring', 'avoid': 'avoiding' }, skillKey = skillMap[mode];
        if (skillKey && this.permanent.skills[skillKey] !== undefined) {
            const correlations = { hunting: { combat: 0.4, exploring: 0.2 }, combat: { hunting: 0.4, fleeing: -0.3 }, fleeing: { avoiding: 0.3, exploring: 0.1 }, exploring: { hunting: 0.2, avoiding: 0.1 }, avoiding: { fleeing: 0.3, exploring: 0.1 } };
            const growth = skillGrowthRate * reward * 0.1;
            this.permanent.skills[skillKey] = Utils.clamp(this.permanent.skills[skillKey] + growth, 0, 1);
            if (correlations[skillKey]) { for (const [related, corr] of Object.entries(correlations[skillKey])) { if (this.permanent.skills[related] !== undefined) { const relatedGrowth = growth * corr * 0.5; this.permanent.skills[related] = Utils.clamp(this.permanent.skills[related] + relatedGrowth, 0, 1); } } }
            this.skillEmbedding = [this.permanent.skills.hunting, this.permanent.skills.fleeing, this.permanent.skills.combat, this.permanent.skills.exploring, this.permanent.skills.avoiding];
        }
    }
    updateMuscleMemory(outputs, reward) { if (reward < 4) return; for (let i = 0; i < Math.min(16, outputs.length); i++) { const diff = Math.abs(outputs[i] - this.permanent.muscleMemory[i]); if (diff > 0.12 && Math.abs(outputs[i]) > 0.4) { this.permanent.muscleMemory[i] = Utils.lerp(this.permanent.muscleMemory[i], outputs[i], 0.06); } } }
    updatePredictiveMemory(world) {
        this.predictive.shortTerm.positions.push({ x: this.x, y: this.y }); if (this.predictive.shortTerm.positions.length > 20) this.predictive.shortTerm.positions.shift();
        const enemies = (world?.agents || []).filter(e => e && e.id !== this.id && e.alive);
        if (enemies.length > 0) { const enemy = enemies[0]; this.predictive.shortTerm.enemyHistory.push({ x: enemy.x, y: enemy.y }); if (this.predictive.shortTerm.enemyHistory.length > 5) this.predictive.shortTerm.enemyHistory.shift(); const hist = this.predictive.shortTerm.enemyHistory; if (hist.length >= 2) { const [prev, last] = [hist[hist.length - 2], hist[hist.length - 1]]; const dx = last.x - prev.x, dy = last.y - prev.y; this.predictive.predictions.enemyPos = { x: last.x + dx * 0.75, y: last.y + dy * 0.75 }; const error = Utils.dist(enemy, this.predictive.predictions.enemyPos); this.predictive.predictionError = Utils.lerp(this.predictive.predictionError, error / 50, 0.1); const accuracy = Math.max(0, 1 - error / 100); this.predictive.confidence = Utils.lerp(this.predictive.confidence, accuracy, 0.05); } } else { this.predictive.confidence = Utils.lerp(this.predictive.confidence, 0.5, 0.02); }
        const nearbyFood = (world?.points || []).filter(p => p && !p.collected && Utils.dist(this, p) < 80); if (nearbyFood.length > 0) { const food = nearbyFood[0]; this.predictive.shortTerm.foodHistory.push({ x: food.x, y: food.y }); if (this.predictive.shortTerm.foodHistory.length > 3) this.predictive.shortTerm.foodHistory.shift(); if (this.predictive.shortTerm.foodHistory.length >= 2) { const avgX = this.predictive.shortTerm.foodHistory.reduce((s, f) => s + f.x, 0) / this.predictive.shortTerm.foodHistory.length, avgY = this.predictive.shortTerm.foodHistory.reduce((s, f) => s + f.y, 0) / this.predictive.shortTerm.foodHistory.length; this.predictive.predictions.foodPos = { x: avgX, y: avgY }; } }
    }
    selectCombatTactic(enemyDistance, enemyHealth, myHealth, enemyPrediction) { if (enemyPrediction === 'fleeing') return 'aggressive'; if (enemyPrediction === 'aggressive') return myHealth < 0.4 ? 'dodge' : 'kite'; if (enemyHealth < 0.3) return 'aggressive'; if (myHealth < 0.3) return 'defensive'; if (enemyDistance < 20) return 'bait'; return 'adaptive'; }
    decideCombatAction(enemy, world) { const distance = Utils.dist(this, enemy), prediction = this.enemyPredictor.predictNextAction(); this.currentTactic = this.selectCombatTactic(distance, enemy.health / enemy.stats.maxHealth, this.health / this.stats.maxHealth, prediction); this.fightOpponent = enemy.id; this.fightStartTime = Date.now(); return this.currentTactic; }
    getLearningMetrics() { return { avgTDError: this.net._trainingStats.tdErrorHistory.reduce((a,b)=>a+b,0)/Math.max(1,this.net._trainingStats.tdErrorHistory.length), avgPredictionError: Array.from(this.net._predictionErrors).reduce((a,b)=>a+b,0)/Math.max(1,this.net._predictionErrors.length), avgPolicyEntropy: this.net._trainingStats.policyEntropyHistory.reduce((a,b)=>a+b,0)/Math.max(1,this.net._trainingStats.policyEntropyHistory.length), winRate: this.net._trainingStats.winRate, collectionRate: this.net._trainingStats.collectionRate, survivalTime: this.net._trainingStats.survivalTime, totalSteps: this.net._trainingStats.totalSteps }; }
    evolve(mutationRate = 0.1) { if (!arenaConfig.enableEvolution) return 0; const mutations = this.net.mutate(mutationRate, 0.15); if (this.critic?._W1) { this.critic._W1.forEach(row => { if (!row) return; row.forEach((v, i) => { if (this.net._rng.next() < mutationRate) { row[i] += (this.net._rng.next() * 2 - 1) * 0.15; row[i] = Utils.clamp(row[i], -2, 2); } }); }); } this.mutations += mutations; return mutations; }
    reset(x, y) { this.x = x; this.y = y; this.vx = 0; this.vy = 0; this.health = this.stats.maxHealth; this.stuckCounter = 0; this.lastPos = { x, y }; this.cumulativeReward = 0; this.mode = 'explore'; this.target = { x, y }; this.trail = []; this.predictive.confidence = 0.5; this.predictive.predictionError = 0; this.attackCooldown = 0; this._clearLearningBuffer(); this.predictive.shortTerm = { positions: [], actions: [], results: [], enemyHistory: [], foodHistory: [] }; }
    draw(ctx, showVision = false, showTrail = true) {
        if (showTrail && this.trail.length > 1) { ctx.beginPath(); ctx.moveTo(this.trail[0].x, this.trail[0].y); for (let i = 1; i < this.trail.length; i++) { const t = this.trail[i], alpha = 1 - t.age / 80; ctx.strokeStyle = this.color + Math.floor(alpha * 40).toString(16).padStart(2, '0'); ctx.lineTo(t.x, t.y); } ctx.stroke(); }
        let drawColor = this.color; if (this.lastMutationType === 'dmg') drawColor = '#ff4444'; else if (this.lastMutationType === 'spd') drawColor = '#4444ff'; else if (this.lastMutationType === 'hp') drawColor = '#44ff44'; else if (this.lastMutationType === 'dod') drawColor = '#aa88ff';
        ctx.fillStyle = drawColor; ctx.beginPath(); ctx.arc(this.x, this.y, 11, 0, Math.PI * 2); ctx.fill();
        ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(this.x + this.vx * 7, this.y + this.vy * 7); ctx.stroke();
        const modeColors = { hunt: '#00ff9d', flee: '#ff5577', explore: '#00d4ff', combat: '#ffaa00', avoid: '#aa88ff', protect: '#44ff44', heal: '#00ff9d' };
        ctx.strokeStyle = modeColors[this.mode] || '#888'; ctx.lineWidth = 2.5; ctx.beginPath(); ctx.arc(this.x, this.y, 15, 0, Math.PI * 2); ctx.stroke();
        ctx.fillStyle = this.predictive.confidence > 0.7 ? '#00ff9d' : (this.predictive.confidence < 0.4 ? '#ff5577' : '#ffaa00'); ctx.beginPath(); ctx.arc(this.x + 14, this.y - 14, 3, 0, Math.PI * 2); ctx.fill();
        if (this.health < this.stats.maxHealth) { ctx.fillStyle = '#222'; ctx.fillRect(this.x - 14, this.y - 20, 28, 4); ctx.fillStyle = this.health > this.stats.maxHealth / 2 ? '#00ff9d' : '#ff5577'; ctx.fillRect(this.x - 14, this.y - 20, 28 * (this.health / this.stats.maxHealth), 4); }
        ctx.fillStyle = '#fff'; ctx.font = '9px monospace'; ctx.textAlign = 'center';
        ctx.fillText(`HP:${Math.round(this.stats.maxHealth)} DMG:${this.stats.damage}`, this.x, this.y - 25);
        ctx.fillText(`SPD:${this.stats.fireRate} DOD:${Math.round(this.stats.dodgeChance * 100)}%`, this.x, this.y - 16);
        ctx.textAlign = 'left';
        if (showVision && this.mode === 'hunt') { ctx.strokeStyle = 'rgba(0,255,157,0.25)'; ctx.fillStyle = 'rgba(0,255,157,0.08)'; ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.arc(this.x, this.y, 70, Math.atan2(this.vy, this.vx) - 0.5, Math.atan2(this.vy, this.vx) + 0.5); ctx.closePath(); ctx.fill(); ctx.stroke(); }
        ctx.strokeStyle = 'rgba(255,255,255,0.35)'; ctx.setLineDash([4, 3]); ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(this.target.x, this.target.y); ctx.stroke(); ctx.setLineDash([]);
        if (this.trail.length === 0 || this.trail[this.trail.length - 1].age > 4) { this.trail.push({ x: this.x, y: this.y, age: 0 }); if (this.trail.length > 35) this.trail.shift(); }
        this.trail.forEach(t => t.age++);
    }
    getDebugInfo() {
        const metrics = this.getLearningMetrics();
        return { mode: this.mode, target: `${Math.round(this.target.x)},${Math.round(this.target.y)}`, speed: this.speed.toFixed(2), aggro: this.lastDecision?.behaviors?.aggression?.toFixed(2) || '‚Äî', memory: (this.permanent.memory.visited.size / 100).toFixed(2), neurons: this.net.getActiveNeurons().slice(0, 3).join(','), reward: this.cumulativeReward.toFixed(2), stuck: this.stuckCounter, confidence: this.predictive.confidence.toFixed(2), predError: metrics.avgPredictionError.toFixed(3), health: `${Math.round(this.health)}/${this.stats.maxHealth}`, mutations: this.mutations, generation: this.generation, tdError: metrics.avgTDError.toFixed(4), policyEntropy: metrics.avgPolicyEntropy.toFixed(3), winRate: metrics.winRate.toFixed(2), collectionRate: metrics.collectionRate.toFixed(2), gate0: this.net.getGateProbs()?.[0]?.toFixed(3) || '‚Äî', gate1: this.net.getGateProbs()?.[1]?.toFixed(3) || '‚Äî', expert0: this.net.getActiveExperts()?.[0] || '‚Äî', expert1: this.net.getActiveExperts()?.[1] || '‚Äî', loadBal: Utils.computeLoadBalance(this.net._lastGateProbs || []).toFixed(3), hebbian: arenaConfig.enableHebbian ? 'ON' : 'OFF', team: this.team !== null ? `T${this.team}` : '‚Äî', role: this.teamRole || '‚Äî', trust: this.socialMemory?.team?.trust?.toFixed(2) || '‚Äî', reputation: this.socialMemory?.reputation?.toFixed(2) || '‚Äî' };
    }
    clone() {
        const agent = new Agent(this.id, this.x, this.y, this.color, this.seed + '_clone_' + Date.now());
        agent.net = this.net.clone(); agent.critic = this.critic.clone(); agent.policySelector = this.policySelector.clone(); agent.experts = this.experts.map(e => e.clone());
        agent.health = this.health; agent.stats = { ...this.stats }; agent.lastMutationType = this.lastMutationType; agent.cumulativeReward = this.cumulativeReward; agent.wins = this.wins; agent.mutations = this.mutations; agent.generation = this.generation + 1;
        agent.permanent = { skills: { ...this.permanent.skills }, strategies: { ...this.permanent.strategies }, preferences: { ...this.permanent.preferences }, muscleMemory: new Float32Array(this.permanent.muscleMemory), memory: { lastFoodPos: this.permanent.memory.lastFoodPos ? { ...this.permanent.memory.lastFoodPos } : null, lastFoodStep: this.permanent.memory.lastFoodStep || 0, visited: new Set(this.permanent.memory.visited), unvisited: this.permanent.memory.unvisited.map(p => ({ ...p })) } };
        agent.predictive = { shortTerm: { positions: [], actions: [], results: [], enemyHistory: [], foodHistory: [] }, patterns: { enemyMovement: null, foodSpawn: null, dangerZones: new Map() }, predictions: { enemyPos: { x: 0, y: 0 }, foodPos: { x: 0, y: 0 }, collision: false, success: 0.5 }, confidence: this.predictive.confidence, predictionError: this.predictive.predictionError };
        agent.enemyPredictor = new EnemyPredictor(); agent.strategyMemory = new StrategyMemory(); agent.currentTactic = this.currentTactic; agent.fightStartTime = this.fightStartTime; agent.fightOpponent = this.fightOpponent; agent.attackCooldown = this.attackCooldown; agent.attackRange = this.attackRange;
        agent.trail = []; agent.lastDecision = null; agent._lastWorld = null; agent.learningBuffer = { states: [], actions: [], rewards: [], nextStates: [], dones: [], values: [], maxBuffer: 32 };
        agent.skillEmbedding = this.skillEmbedding.slice(); agent.team = this.team; agent.teamRole = this.teamRole; agent.healPower = this.healPower;
        agent.socialMemory = { team: { ...this.socialMemory.team }, individuals: new Map(this.socialMemory.individuals), otherTeams: new Map(this.socialMemory.otherTeams), reputation: this.socialMemory.reputation, fame: this.socialMemory.fame, allies: new Set(this.socialMemory.allies), enemies: new Set(this.socialMemory.enemies), lastCooperation: new Map(this.socialMemory.lastCooperation) };
        agent.lastAttacker = this.lastAttacker; agent.willRespawn = this.willRespawn; return agent;
    }
    toJSON() { return { id: this.id, seed: this.seed, x: this.x, y: this.y, health: this.health, stats: this.stats, lastMutationType: this.lastMutationType, cumulativeReward: this.cumulativeReward, wins: this.wins, mutations: this.mutations, generation: this.generation, net: this.net.toJSON(), critic: this.critic.toJSON(), policySelector: this.policySelector.toJSON(), experts: this.experts ? this.experts.map(e => e.toJSON()) : [], permanent: { skills: this.permanent.skills, strategies: this.permanent.strategies, preferences: this.permanent.preferences, muscleMemory: Array.from(this.permanent.muscleMemory), memory: { lastFoodPos: this.permanent.memory.lastFoodPos, lastFoodStep: this.permanent.memory.lastFoodStep, visited: Array.from(this.permanent.memory.visited).slice(0, 100), unvisited: this.permanent.memory.unvisited.slice(0, 30) } }, predictive: { confidence: this.predictive.confidence, predictionError: this.predictive.predictionError }, skillEmbedding: this.skillEmbedding.slice(), strategyMemory: { winningStrategies: this.strategyMemory.winningStrategies.slice(0, 5), fightHistory: this.strategyMemory.fightHistory }, trainingStats: this.net._trainingStats, team: this.team, teamRole: this.teamRole, healPower: this.healPower, socialMemory: { team: this.socialMemory.team, individuals: Array.from(this.socialMemory.individuals.entries()).slice(0, 20), otherTeams: Array.from(this.socialMemory.otherTeams.entries()).slice(0, 10), reputation: this.socialMemory.reputation, fame: this.socialMemory.fame, allies: Array.from(this.socialMemory.allies).slice(0, 10), enemies: Array.from(this.socialMemory.enemies).slice(0, 10) }, lastAttacker: this.lastAttacker, willRespawn: this.willRespawn }; }
    static fromJSON(data, color) {
        const agent = new Agent(data.id, data.x, data.y, color, data.seed);
        agent.net = NeuralNetwork.fromJSON(data.net); if (data.critic) agent.critic = CriticNetwork.fromJSON(data.critic); if (data.policySelector) agent.policySelector = PolicySelector.fromJSON(data.policySelector); if (data.experts?.length) agent.experts = data.experts.map(e => NeuralNetwork.fromJSON(e));
        agent.health = data.health ?? 100; agent.stats = data.stats || { maxHealth: 100, damage: 3, fireRate: 15, dodgeChance: 0.0 }; agent.lastMutationType = data.lastMutationType || null; agent.cumulativeReward = data.cumulativeReward ?? 0; agent.wins = data.wins ?? 0; agent.mutations = data.mutations ?? 0; agent.generation = data.generation ?? 1;
        if (data.permanent) { agent.permanent.skills = { ...(data.permanent.skills || agent.permanent.skills) }; agent.permanent.strategies = { ...(data.permanent.strategies || agent.permanent.strategies) }; agent.permanent.preferences = { ...(data.permanent.preferences || agent.permanent.preferences) }; if (data.permanent.muscleMemory) agent.permanent.muscleMemory = new Float32Array(data.permanent.muscleMemory); if (data.permanent.memory) { agent.permanent.memory.lastFoodPos = data.permanent.memory.lastFoodPos; agent.permanent.memory.lastFoodStep = data.permanent.memory.lastFoodStep || 0; agent.permanent.memory.visited = new Set(data.permanent.memory.visited || []); agent.permanent.memory.unvisited = data.permanent.memory.unvisited || []; } }
        if (data.strategyMemory) { agent.strategyMemory.winningStrategies = data.strategyMemory.winningStrategies || []; agent.strategyMemory.fightHistory = data.strategyMemory.fightHistory || {}; } if (data.predictive) { agent.predictive.confidence = data.predictive.confidence ?? 0.5; agent.predictive.predictionError = data.predictive.predictionError ?? 0; } if (data.skillEmbedding) agent.skillEmbedding = data.skillEmbedding.slice(); if (data.trainingStats) agent.net._trainingStats = { ...data.trainingStats };
        agent.team = data.team ?? null; agent.teamRole = data.teamRole || null; agent.healPower = data.healPower ?? 3;
        if (data.socialMemory) { agent.socialMemory.team = data.socialMemory.team || { id: null, trust: 0.7 }; agent.socialMemory.individuals = new Map(data.socialMemory.individuals || []); agent.socialMemory.otherTeams = new Map(data.socialMemory.otherTeams || []); agent.socialMemory.reputation = data.socialMemory.reputation ?? 0; agent.socialMemory.fame = data.socialMemory.fame ?? 0; agent.socialMemory.allies = new Set(data.socialMemory.allies || []); agent.socialMemory.enemies = new Set(data.socialMemory.enemies || []); agent.socialMemory.lastCooperation = new Map(data.socialMemory.lastCooperation || []); }
        agent.lastAttacker = data.lastAttacker || null; agent.willRespawn = data.willRespawn ?? true; return agent;
    }
}

// ============================================================================
// WORLD ‚Äî MULTI-AGENT SIMULATION ENVIRONMENT
// ============================================================================
class World {
    constructor(width, height) { this.logicalWidth = width; this.logicalHeight = height; this.step = 0; this.episode = 0; this.points = []; this.walls = []; this.agents = []; this.teams = new Map(); this.projectiles = []; }
    reset() { this.step = 0; this.points = []; this.walls = []; for (let i = 0; i < 40; i++) this.points.push(new SmartPoint(35 + Utils.rand(0, 750), 35 + Utils.rand(0, 530), 'normal')); for (let i = 0; i < 8; i++) this.points.push(new SmartPoint(35 + Utils.rand(0, 750), 35 + Utils.rand(0, 530), 'scared')); for (let i = 0; i < 2; i++) this.points.push(new SmartPoint(35 + Utils.rand(0, 750), 35 + Utils.rand(0, 530), 'rare')); for (let i = 0; i < 12; i++) this.walls.push({ x: 60 + Utils.rand(0, 700), y: 60 + Utils.rand(0, 460) }); this.projectiles = []; }
    spawnAgents() {
        const cfg = arenaConfig.gameMode, { type, tournament } = cfg; this.agents = []; this.teams = new Map();
        if (type === 'freeforall') { const count = tournament.teamCount * tournament.agentsPerTeam; for (let i = 0; i < count; i++) { const agent = this._createAgent(`ffa_${i}`, i, null); this.agents.push(agent); } return; }
        if (type === 'tournament') {
            const teamCount = tournament.teamCount, basePerTeam = tournament.agentsPerTeam;
            const totalAgents = tournament.allowUneven ? Utils.randInt(teamCount * (basePerTeam - 2), teamCount * (basePerTeam + 2)) : teamCount * basePerTeam;
            const unassigned = []; for (let i = 0; i < totalAgents; i++) { const agent = this._createAgent(`agent_${i}`, i, null); unassigned.push(agent); }
            if (tournament.dynamicTeams && unassigned.length > 2) { this._assignTeamsByEmpathy(unassigned, teamCount); } else { for (let i = 0; i < unassigned.length; i++) { const teamId = i % teamCount; this._assignAgentToTeam(unassigned[i], teamId); } }
            if (tournament.format === '1v1') { this.teams.forEach((members, teamId) => { if (members.length > 1) { const toRemove = members.slice(1); toRemove.forEach(a => { const idx = this.agents.indexOf(a); if (idx >= 0) this.agents.splice(idx, 1); }); members.length = 1; } }); } else if (tournament.format === '2v2') { this.teams.forEach(members => { if (members.length > 2) members.length = 2; }); }
            return;
        }
        if (type === 'survival') { const count = tournament.teamCount * tournament.agentsPerTeam; for (let i = 0; i < count; i++) { const agent = this._createAgent(`survival_${i}`, i, null); agent.team = null; this.agents.push(agent); } }
    }
    _createAgent(id, index, teamId) {
        const cfg = arenaConfig.gameMode, color = teamId !== null ? cfg.colors[teamId % cfg.colors.length] : `hsl(${index * 37 % 360}, 70%, 50%)`;
        const seed = `${arenaConfig.seed}_${id}_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
        const agent = new Agent(id, 100 + (index % 12) * 60, 80 + Math.floor(index / 12) * 45, color, seed);
        agent.stats.maxHealth = 100 + Utils.randInt(-20, 40); agent.stats.damage = 3 + Utils.randInt(-1, 3); agent.stats.fireRate = 12 + Utils.randInt(-3, 5); agent.stats.dodgeChance = Utils.rand(0, 0.2);
        const roles = ['scout', 'fighter', 'tank', 'support', 'leader']; agent.teamRole = roles[index % roles.length];
        const archetype = Utils.randInt(0, 4); if (archetype === 0) { agent.permanent.skills.hunting = 0.7; agent.permanent.skills.combat = 0.6; } else if (archetype === 1) { agent.permanent.skills.fleeing = 0.7; agent.permanent.skills.avoiding = 0.6; } else if (archetype === 2) { agent.permanent.skills.exploring = 0.7; } else if (archetype === 3) { agent.permanent.skills.combat = 0.7; agent.permanent.skills.fleeing = 0.3; } else { agent.permanent.skills.hunting = 0.5; agent.permanent.skills.exploring = 0.5; }
        agent.socialMemory = { team: { id: teamId, trust: 0.7 }, individuals: new Map(), otherTeams: new Map(), reputation: 0, fame: 0, allies: new Set(), enemies: new Set(), lastCooperation: new Map() }; return agent;
    }
    _assignTeamsByEmpathy(agents, teamCount) {
        agents.forEach((a, i) => { a._tempTeam = i % teamCount; });
        for (let iteration = 0; iteration < 3; iteration++) {
            for (const agent of agents) {
                const teamScores = {};
                for (let t = 0; t < teamCount; t++) {
                    let score = 0; const teammates = agents.filter(a => a._tempTeam === t && a.id !== agent.id);
                    for (const tm of teammates) { const record = agent.socialMemory.individuals.get(tm.id); if (record) { score += record.trust * 2; if (record.lastCooperation?.success) score += 1; } const archetypeCompat = { 'fighter': { 'tank': 1, 'support': 1, 'fighter': -0.5 }, 'tank': { 'fighter': 1, 'support': 1, 'tank': -0.3 }, 'support': { 'tank': 1, 'fighter': 1, 'support': 0.5 }, 'scout': { 'leader': 0.5, 'support': 0.3 } }; const compat = archetypeCompat[agent.teamRole]?.[tm.teamRole]; if (compat !== undefined) score += compat; }
                    teamScores[t] = score;
                }
                const bestTeam = Object.keys(teamScores).reduce((a, b) => teamScores[a] > teamScores[b] ? a : b);
                if (Math.random() < 0.7) agent._tempTeam = parseInt(bestTeam);
            }
        }
        for (const agent of agents) { this._assignAgentToTeam(agent, agent._tempTeam); delete agent._tempTeam; }
    }
    _assignAgentToTeam(agent, teamId) { agent.team = teamId; agent.color = arenaConfig.gameMode.colors[teamId % arenaConfig.gameMode.colors.length]; if (!this.teams.has(teamId)) { this.teams.set(teamId, { id: teamId, members: [], color: agent.color, trust: 0.7, alliances: new Set(), enemies: new Set() }); } this.teams.get(teamId).members.push(agent); this.agents.push(agent); }
    update(dt) {
        this.step++; if (!this.agents?.length || this.agents.length < 2) { console.error('World.update: Invalid agents array'); return { pointsLeft: 0, episode: this.episode }; }
        const validAgents = this.agents.filter(a => a?.alive), nearest = validAgents[0] || null;
        for (const p of this.points) { if (!p) continue; const nearestAgent = validAgents.reduce((n, a) => !n || Utils.dist(p, a) < Utils.dist(p, n) ? a : n, null); p.update(nearest?.alive ? nearest : null, dt); }
        for (const agent of this.agents) { if (!agent || !agent.alive) continue; const enemies = this.agents.filter(e => e && e.id !== agent.id && e.alive); if (enemies.length > 0) { const enemy = enemies[0], distance = Utils.dist(agent, enemy); if (distance < 150) { agent.enemyPredictor.recordMove(agent.lastDecision?.behaviors || {}, distance, enemy.health / enemy.stats.maxHealth, agent.lastDecision?.behaviors?.aggression || 0.5); if (distance < 100) agent.decideCombatAction(enemy, this); } } const decision = agent.decide(this); agent.move(decision.target, decision.speed, this.walls, dt, decision.output); agent.attackCooldown = Math.max(0, (agent.attackCooldown || 0) - 1);
            if (arenaConfig.enableFighting) { const opponents = this.agents.filter(e => e && e.id !== agent.id && e.alive); if (opponents.length > 0) { const enemy = opponents[0], dist = Utils.dist(agent, enemy), range = agent.attackRange || 35; if (dist <= range) { if ((agent.attackCooldown || 0) <= 0) { const aggression = agent.lastDecision?.behaviors?.aggression || 0.5, skill = agent.permanent?.skills?.combat || 0.3, baseDmg = agent.stats.damage, damage = Math.floor(Utils.clamp(baseDmg * (0.8 + aggression * 0.4) * (0.7 + skill * 0.6), 1, 10)), dodgeRoll = Math.random(); if (dodgeRoll < enemy.stats.dodgeChance) Logger.log(`üõ°Ô∏è ${enemy.id.toUpperCase()} —É–∫–ª–æ–Ω–∏–ª—Å—è!`, 'warn'); else { enemy.health -= damage; enemy.lastAttacker = agent.id; Logger.log(`${agent.id.toUpperCase()} ‚Üí ${enemy.id.toUpperCase()} -${damage} HP`, 'info'); } agent.attackCooldown = agent.stats.fireRate; if (enemy.health <= 0) { enemy.health = 0; enemy.alive = false; Logger.log(`üè≥Ô∏è ${enemy.id.toUpperCase()} –ø–æ–≤–µ—Ä–∂–µ–Ω ${agent.id.toUpperCase()}`, 'success'); } } } else if (arenaConfig.enableRanged && (agent.attackCooldown || 0) <= 0) { const aggr = agent.lastDecision?.behaviors?.aggression || 0.4; if (aggr > 0.3 && dist > 50 && dist < 200) { const dir = Utils.normalize(enemy.x - agent.x, enemy.y - agent.y), speed = 10 + Math.random() * 4, dmg = Math.floor(Utils.clamp(agent.stats.damage * 0.5 * (0.8 + aggr * 0.8), 1, 5)), p = new Projectile(agent.x + dir.x * 12, agent.y + dir.y * 12, dir.x * speed, dir.y * speed, agent.id, dmg, 80); this.projectiles.push(p); agent.attackCooldown = agent.stats.fireRate + 5; Logger.log(`${agent.id.toUpperCase()} —Å—Ç—Ä–µ–ª—è–µ—Ç –ø–æ ${enemy.id.toUpperCase()} (-${dmg} HP)`, 'info'); } } } }
            const reward = agent.calculateReward(this, decision), nextInputs = agent.getInputs(this); agent.learn(reward, decision, nextInputs);
        }
        for (const p of this.projectiles) { if (!p?.alive) continue; p.update(dt); for (const w of this.walls) { if (Utils.dist(p, w) < 14 + p.radius) { p.alive = false; break; } } if (!p.alive) continue; for (const e of this.agents) { if (!e || !e.alive || e.id === p.owner) continue; if (Utils.dist(p, e) < 15) { const dodgeRoll = Math.random(); if (dodgeRoll < e.stats.dodgeChance) Logger.log(`üõ°Ô∏è ${e.id.toUpperCase()} —É–∫–ª–æ–Ω–∏–ª—Å—è –æ—Ç –ø—É–ª–∏!`, 'warn'); else { e.health -= p.damage; e.lastAttacker = p.owner; Logger.log(`üéØ ${p.owner.toUpperCase()} ‚Üí ${e.id.toUpperCase()} -${p.damage} HP`, 'info'); } p.alive = false; if (e.health <= 0) { e.health = 0; e.alive = false; Logger.log(`üè≥Ô∏è ${e.id.toUpperCase()} —É–±–∏—Ç ${p.owner.toUpperCase()}`, 'success'); } break; } } }
        this.projectiles = this.projectiles.filter(p => p?.alive);
        const deadAgents = this.agents.filter(a => a && !a.alive); if (deadAgents.length > 0) { this.episode++; Logger.log(`üìä –≠–ø–∏–∑–æ–¥ ${this.episode} –∑–∞–≤–µ—Ä—à–µ–Ω`, 'info'); for (const deadAgent of deadAgents) { const killer = this.agents.find(a => a?.id === deadAgent.lastAttacker && a.alive); if (killer) { this._updateSocialMemory(deadAgent, killer); } if (arenaConfig.enableEvolution && deadAgent.generation < 50) { const idx = this.agents.findIndex(a => a?.id === deadAgent.id); if (idx >= 0) { const child = this._createAgent(deadAgent.id, idx, deadAgent.team); const cfg = arenaConfig.gameMode.tournament; if (cfg.mutationMode === 'individual') { this._mutateAgent(child, deadAgent, 0.15); } else if (cfg.mutationMode === 'team' && killer?.team === deadAgent.team) { const bestInTeam = this._getBestInTeam(deadAgent.team); if (bestInTeam) { this._inheritFromAgent(child, bestInTeam, 0.6); this._mutateAgent(child, bestInTeam, 0.1); } } else if (cfg.mutationMode === 'global') { const globalBest = this._getGlobalBest(); if (globalBest) { this._inheritFromAgent(child, globalBest, 0.5); this._mutateAgent(child, globalBest, 0.2); } } child.socialMemory = { team: { ...deadAgent.socialMemory.team }, individuals: new Map(Array.from(deadAgent.socialMemory.individuals).map(([k, v]) => [k, { ...v, trust: v.trust * 0.8 }])), otherTeams: new Map(Array.from(deadAgent.socialMemory.otherTeams).map(([k, v]) => [k, { ...v, trust: v.trust * 0.9 }])), reputation: deadAgent.socialMemory.reputation * 0.7, fame: deadAgent.socialMemory.fame * 0.5, allies: new Set(deadAgent.socialMemory.allies), enemies: new Set(deadAgent.socialMemory.enemies), lastCooperation: new Map(deadAgent.socialMemory.lastCooperation) }; child.generation = deadAgent.generation + 1; child.reset(100 + Math.random() * 600, 80 + Math.random() * 400); child.alive = true; this.agents[idx] = child; Logger.log(`üß¨ ${child.id} –≤–æ–∑—Ä–æ–∂–¥—ë–Ω (Gen ${child.generation}, —Ä–æ–ª—å: ${child.teamRole})`, 'success'); } } } }
        const active = (this.points || []).filter(p => p && !p.collected).length; if (active < 22 && this.step % 40 === 0) { const types = ['normal', 'normal', 'normal', 'scared', 'rare']; this.points.push(new SmartPoint(35 + Utils.rand(0, 750), 35 + Utils.rand(0, 530), types[Utils.randInt(0, types.length - 1)])); }
        return { pointsLeft: (this.points || []).filter(p => p && !p.collected).length, episode: this.episode };
    }
    _updateSocialMemory(dead, killer) { const deadRecord = dead.socialMemory.individuals.get(killer.id) || { fights: 0, trust: 0 }; deadRecord.fights++; deadRecord.trust = Math.max(-1, deadRecord.trust - 0.4); dead.socialMemory.individuals.set(killer.id, deadRecord); dead.socialMemory.enemies.add(killer.id); const killerRecord = killer.socialMemory.individuals.get(dead.id) || { fights: 0, trust: 0 }; killerRecord.fights++; killerRecord.trust = Math.min(1, killerRecord.trust + 0.2); killer.socialMemory.individuals.set(dead.id, killerRecord); if (dead.team !== killer.team) { this.teams.get(dead.team)?.members.forEach(m => { if (!m.alive || m.id === dead.id) return; const teamRec = m.socialMemory.otherTeams.get(killer.team) || { trust: 0, wars: 0 }; teamRec.trust = Math.max(-1, teamRec.trust - 0.15); teamRec.wars = (teamRec.wars || 0) + 1; m.socialMemory.otherTeams.set(killer.team, teamRec); m.socialMemory.enemies.add(killer.id); }); this.teams.get(killer.team)?.members.forEach(m => { if (!m.alive) return; m.socialMemory.reputation = Math.min(1, m.socialMemory.reputation + 0.05); m.socialMemory.fame = Math.min(1, m.socialMemory.fame + 0.1); }); } }
    _mutateAgent(child, parent, rate) { if (arenaConfig.enableEvolution) { child.net.mutate(rate * 0.8, 0.15); } const statKeys = ['maxHealth', 'damage', 'fireRate', 'dodgeChance'], toMutate = statKeys.sort(() => Math.random() - 0.5).slice(0, Utils.randInt(3, 5)); for (const key of toMutate) { const mutation = 1 + (Math.random() * 0.4 - 0.2); if (key === 'dodgeChance') { child.stats[key] = Math.min(0.5, Math.max(0, child.stats[key] * mutation)); } else if (key === 'fireRate') { child.stats[key] = Math.max(5, Math.round(child.stats[key] * mutation)); } else { child.stats[key] = Math.max(1, Math.round(child.stats[key] * mutation)); } } for (const skill of Object.keys(child.permanent.skills)) { child.permanent.skills[skill] = Utils.clamp(child.permanent.skills[skill] + (Math.random() * 0.1 - 0.05), 0, 1); } }
    _inheritFromAgent(child, parent, ratio) { const inheritMatrix = (c, p) => { for (let i = 0; i < c.length; i++) { if (Array.isArray(c[i])) { for (let j = 0; j < c[i].length; j++) { if (Math.random() < ratio) c[i][j] = p[i][j]; } } } }; inheritMatrix(child.net._W1, parent.net._W1); inheritMatrix(child.net._W2, parent.net._W2); inheritMatrix(child.net._W3, parent.net._W3); for (const key of Object.keys(parent.stats)) { if (Math.random() < ratio) { child.stats[key] = parent.stats[key]; } } for (const skill of Object.keys(parent.permanent.skills)) { if (Math.random() < ratio) { child.permanent.skills[skill] = parent.permanent.skills[skill]; } } }
    _getBestInTeam(teamId) { const team = this.teams.get(teamId); if (!team) return null; return team.members.filter(a => a.alive).sort((a, b) => (b.wins || 0) - (a.wins || 0) || (b.cumulativeReward || 0) - (a.cumulativeReward || 0))[0] || null; }
    _getGlobalBest() { return this.agents.filter(a => a.alive).sort((a, b) => (b.wins || 0) - (a.wins || 0) || (b.cumulativeReward || 0) - (a.cumulativeReward || 0))[0] || null; }
    resetEpisode() { this.points.forEach(p => { if (p) p.collected = false; }); this.agents.forEach(a => { if (a) { a.reset(100 + Math.random() * 600, 80 + Math.random() * 400); a.alive = true; } }); Logger.log(`üîÑ –ù–æ–≤—ã–π —ç–ø–∏–∑–æ–¥ ${this.episode} –Ω–∞—á–∞–ª—Å—è`, 'info'); }
    draw(ctx, vision = false, trail = true) { if (!ctx) return; ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height); const grad = ctx.createLinearGradient(0, 0, this.logicalWidth, this.logicalHeight); grad.addColorStop(0, '#0a0a15'); grad.addColorStop(1, '#1a1a2e'); ctx.fillStyle = grad; ctx.fillRect(0, 0, this.logicalWidth, this.logicalHeight); ctx.strokeStyle = 'rgba(50,50,90,0.25)'; ctx.lineWidth = 1; for (let x = 0; x < this.logicalWidth; x += 50) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, this.logicalHeight); ctx.stroke(); } for (let y = 0; y < this.logicalHeight; y += 50) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(this.logicalWidth, y); ctx.stroke(); } ctx.fillStyle = '#4a4a7a'; for (const w of this.walls) { ctx.beginPath(); ctx.arc(w.x, w.y, 14, 0, Math.PI * 2); ctx.fill(); ctx.strokeStyle = '#6a6a9a'; ctx.lineWidth = 2; ctx.stroke(); } for (const p of this.points) { if (p) p.draw(ctx); } for (const pr of this.projectiles || []) { if (pr) pr.draw(ctx); } for (const a of this.agents) { if (a) a.draw(ctx, vision, trail); } ctx.fillStyle = 'rgba(100,100,140,0.5)'; ctx.font = '10px monospace'; ctx.fillText(`Step: ${this.step} | Ep: ${this.episode}`, 12, this.logicalHeight - 12); }
}

// ============================================================================
// LOGGER ‚Äî SAFE CONSOLE OUTPUT
// ============================================================================
const Logger = Object.freeze({
    _escape: (str) => String(str).replace(/[&<>"']/g, m => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#039;' }[m])),
    _truncate: (str, max = 180) => str.length > max ? str.slice(0, max) + '‚Ä¶' : str,
    log: (msg, type = 'info') => {
        const safeMsg = Logger._escape(Logger._truncate(msg)), safeType = ['info', 'success', 'warn', 'error', 'learning', 'social'].includes(type) ? type : 'info';
        const logEl = document.getElementById('eventLog'); if (!logEl) { console.log(`[${safeType}] ${safeMsg}`); return; }
        const entry = document.createElement('div'); entry.className = `log-entry ${safeType}`; entry.textContent = `[${new Date().toLocaleTimeString()}] ${safeMsg}`;
        logEl.insertBefore(entry, logEl.firstChild); while (logEl.children.length > 60) logEl.removeChild(logEl.lastChild); logEl.scrollTop = 0;
    }
});

// ============================================================================
// GAME ENGINE ‚Äî MAIN CONTROLLER
// ============================================================================
class GameEngine {
    constructor() {
        this.canvas = document.getElementById('gameCanvas'); if (!this.canvas) { console.error('Canvas element not found'); alert('–û—à–∏–±–∫–∞: Canvas —ç–ª–µ–º–µ–Ω—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω!'); return; }
        this.ctx = this.canvas.getContext('2d'); if (!this.ctx) { console.error('Failed to get canvas context'); alert('–û—à–∏–±–∫–∞: –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∫–æ–Ω—Ç–µ–∫—Å—Ç canvas!'); return; }
        this.settings = { ...arenaConfig }; this.logicalWidth = arenaConfig.ARCH.LOGICAL_WIDTH; this.logicalHeight = arenaConfig.ARCH.LOGICAL_HEIGHT;
        this.resize(); this.scaleX = this.canvas.width / this.logicalWidth; this.scaleY = this.canvas.height / this.logicalHeight;
        this.world = new World(this.logicalWidth, this.logicalHeight); this.running = false; this.lastTime = 0; this.fps = 60; this.vision = false; this.debug = false; this.showMetrics = true; this.professionalMode = false;
        this.selectedAgent = null; this.rafId = null; this._onResize = this._onResize.bind(this); this._onClick = this._onClick.bind(this); this._onKey = this._onKey.bind(this);
        this.setupEvents(); this.init();
    }
    resize() { const parent = this.canvas?.parentElement; if (!parent) return; this.canvas.width = parent.clientWidth; this.canvas.height = parent.clientHeight; this.scaleX = this.canvas.width / this.logicalWidth; this.scaleY = this.canvas.height / this.logicalHeight; }
    _onResize() { this.resize(); }
    setupEvents() {
        window.addEventListener('resize', this._onResize);
        const handlePointer = (e) => { const rect = this.canvas.getBoundingClientRect(), scaleX = this.canvas.width / rect.width, scaleY = this.canvas.height / rect.height, clientX = e.touches?.[0]?.clientX ?? e.clientX, clientY = e.touches?.[0]?.clientY ?? e.clientY, x = (clientX - rect.left) * scaleX, y = (clientY - rect.top) * scaleY; this._onClick({ x, y }); };
        this.canvas.addEventListener('click', handlePointer); this.canvas.addEventListener('touchend', handlePointer); this.canvas.addEventListener('touchstart', (e) => e.preventDefault(), { passive: false });
        document.addEventListener('keydown', this._onKey); this.canvas.setAttribute('tabindex', '0'); this.canvas.setAttribute('role', 'application'); this.canvas.setAttribute('aria-label', 'AI Arena simulation canvas');
        const bindClick = (id, handler) => { const btn = document.getElementById(id); if (btn) btn.onclick = handler; };
        bindClick('btnStart', () => this.toggle()); bindClick('btnReset', () => this.reset()); bindClick('btnSave', () => this.save()); bindClick('btnLoad', () => this.load()); bindClick('btnExport', () => this.exportWeights());
        bindClick('btnImport', () => document.getElementById('fileImport')?.click()); bindClick('btnPretrain', () => document.getElementById('filePretrain')?.click());
        bindClick('btnDebug', () => this.toggleDebug()); bindClick('btnVision', () => { this.vision = !this.vision; this.updateBtns(); }); bindClick('btnMetrics', () => { this.showMetrics = !this.showMetrics; this.updateBtns(); });
        bindClick('btnToggleProfessional', () => this.toggleProfessional());
        const fileImport = document.getElementById('fileImport'), filePretrain = document.getElementById('filePretrain');
        if (fileImport) fileImport.onchange = (e) => this.importWeights(e); if (filePretrain) filePretrain.onchange = (e) => this.importPretrained(e);
        const bindSlider = (id, key, displayId) => { const slider = document.getElementById(id), display = document.getElementById(displayId); if (!slider || !display) return; slider.oninput = (e) => { const value = parseFloat(e.target.value); this.settings[key] = value; display.textContent = value; if (this.world?.agents) { this.world.agents.forEach(a => { if (a?.net) { a.net.lr = this.settings.learningRate; a.net.lambda = this.settings.lambda; a.net.gamma = this.settings.gamma; a.net.entropyCoeff = this.settings.entropyCoeff; } if (a?.critic) a.critic.lr = this.settings.learningRate; if (a?.policySelector) a.policySelector.lr = this.settings.learningRate * 0.6; }); } }; };
        bindSlider('learningRate', 'learningRate', 'learningRateValue'); bindSlider('lambda', 'lambda', 'lambdaValue'); bindSlider('gamma', 'gamma', 'gammaValue'); bindSlider('entropyCoeff', 'entropyCoeff', 'entropyValue'); bindSlider('mutationRate', 'mutationRate', 'mutationRateValue'); bindSlider('skillGrowth', 'skillGrowthRate', 'skillGrowthValue');
        const bindToggle = (id, key) => { const toggle = document.getElementById(id); if (toggle) toggle.onchange = (e) => { this.settings[key] = e.target.checked; }; };
        bindToggle('enableTraining', 'enableTraining'); bindToggle('enableCritic', 'enableCritic'); bindToggle('enablePolicySelector', 'enablePolicySelector'); bindToggle('enableEvolution', 'enableEvolution'); bindToggle('enableSkillEvolution', 'enableSkillEvolution'); bindToggle('enableMoE', 'enableMoE'); bindToggle('enableConsolidation', 'enableConsolidation'); bindToggle('enableFighting', 'enableFighting'); bindToggle('enableRanged', 'enableRanged'); bindToggle('enableVisualization', 'enableVisualization'); bindToggle('enableHebbian', 'enableHebbian');
        bindToggle('compactInputs', 'compactInputs'); bindToggle('enableWeightInheritance', 'enableWeightInheritance'); bindToggle('showWeights', 'showWeights'); bindToggle('showGradients', 'showGradients'); bindToggle('showAttention', 'showAttention'); bindToggle('showMoEGate', 'showMoEGate'); bindToggle('showMemory', 'showMemory');
        const modeSelect = document.getElementById('gameModeType'); if (modeSelect) { modeSelect.onchange = (e) => { arenaConfig.gameMode.type = e.target.value; document.getElementById('tournamentSettings').style.display = e.target.value === 'tournament' ? 'block' : 'none'; this.reset(); }; }
        const bindTournamentSetting = (id, path, defaultVal) => { const el = document.getElementById(id); if (!el) return; el.onchange = (e) => { const value = e.target.type === 'checkbox' ? e.target.checked : e.target.type === 'number' ? parseInt(e.target.value) : e.target.value; let obj = arenaConfig.gameMode.tournament; const keys = path.split('.'); for (let i = 0; i < keys.length - 1; i++) obj = obj[keys[i]]; obj[keys[keys.length - 1]] = value; if (arenaConfig.gameMode.type === 'tournament') this.reset(); }; let obj = arenaConfig.gameMode.tournament; const keys = path.split('.'); for (let i = 0; i < keys.length - 1; i++) obj = obj[keys[i]]; el.value = obj[keys[keys.length - 1]]; if (el.type === 'checkbox') el.checked = obj[keys[keys.length - 1]]; };
        bindTournamentSetting('tournamentFormat', 'format', 'team'); bindTournamentSetting('teamCountInput', 'teamCount', 4); bindTournamentSetting('agentsPerTeamInput', 'agentsPerTeam', 5); bindTournamentSetting('allowUnevenTeams', 'allowUneven', true); bindTournamentSetting('dynamicTeams', 'dynamicTeams', true); bindTournamentSetting('individualMutation', 'mutationMode', 'individual');
    }
    _onKey(e) { if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code)) e.preventDefault(); switch (e.key) { case ' ': e.preventDefault(); this.toggle(); break; case '1': this.selectedAgent = this.world?.agents?.[0]; this.updateDebugPanel(); break; case '2': this.selectedAgent = this.world?.agents?.[1]; this.updateDebugPanel(); break; case 'Tab': e.preventDefault(); const focusable = document.querySelectorAll('button, input, select, [tabindex="0"]'), idx = Array.from(focusable).indexOf(document.activeElement); focusable[(idx + 1) % focusable.length]?.focus(); break; case 'Escape': if (this.debug) { this.debug = false; this.updateDebugPanel(); } break; } }
    _onClick({ x, y }) { if (!this.debug) return; const lx = x / this.scaleX, ly = y / this.scaleY; let nearest = null, minD = 25; for (const a of this.world?.agents || []) { if (!a) continue; const d = Math.hypot(a.x - lx, a.y - ly); if (d < minD) { minD = d; nearest = a; } } this.selectedAgent = nearest; if (nearest) Logger.log(`üîç –í—ã–±—Ä–∞–Ω –∞–≥–µ–Ω—Ç ${nearest.id}`, 'info'); this.updateDebugPanel(); }
    init() { this.world.reset(); this.world.spawnAgents(); if (!this.world.agents?.length || this.world.agents.length < 2) { console.error('Failed to initialize agents'); alert('–û—à–∏–±–∫–∞: –Ω–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å –∞–≥–µ–Ω—Ç–æ–≤!'); return; } this.world.agents.forEach(a => { if (!a) return; a.net.lr = this.settings.learningRate; a.net.lambda = this.settings.lambda; a.net.gamma = this.settings.gamma; if (a.critic) a.critic.lr = this.settings.learningRate; if (a.policySelector) a.policySelector.lr = this.settings.learningRate * 0.6; }); this.updateStats(); this.updateMetrics(); if (this.world.agents[0] && this.world.agents[1]) this.world.draw(this.ctx, false, true); Logger.log('üöÄ AI ARENA v4.1.0 PROFESSIONAL –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞', 'success'); Logger.log(`üîß –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞: ${arenaConfig.compactInputs ? '25‚Üí16‚Üí48‚Üí36‚Üí16' : '57‚Üí24‚Üí48‚Üí36‚Üí16'} + RNN(16) –ø–∞–º—è—Ç—å`, 'success'); Logger.log('üß† –û–±—É—á–µ–Ω–∏–µ: TD(Œª)+Actor-Critic+LearnablePolicy+MoE+Hebbian', 'success'); Logger.log('üîë –î–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –æ—Ç –∫–ª—é—á–∞', 'success'); Logger.log('‚ö° –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏: –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ, spatial hashing, early-exit', 'success'); Logger.log('üë• Multi-Agent: –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–µ –∫–æ–º–∞–Ω–¥—ã, —ç–º–ø–∞—Ç–∏—è, —Å–æ—Ü–∏–∞–ª—å–Ω—ã–µ —Å–≤—è–∑–∏', 'success'); }
    toggle() { this.running = !this.running; const btn = document.getElementById('btnStart'); if (btn) { btn.textContent = this.running ? '‚è∏ –ü–∞—É–∑–∞' : '‚ñ∂ –°—Ç–∞—Ä—Ç'; btn.className = this.running ? 'btn-danger' : 'btn-primary'; btn.setAttribute('aria-pressed', String(this.running)); } Logger.log(this.running ? '‚ñ∂ –°–∏–º—É–ª—è—Ü–∏—è –∑–∞–ø—É—â–µ–Ω–∞' : '‚è∏ –ü–∞—É–∑–∞', 'info'); if (this.running) { this.lastTime = performance.now(); this.loop(); } }
    reset() { this.running = false; const btn = document.getElementById('btnStart'); if (btn) { btn.textContent = '‚ñ∂ –°—Ç–∞—Ä—Ç'; btn.className = 'btn-primary'; btn.setAttribute('aria-pressed', 'false'); } this.world = new World(this.logicalWidth, this.logicalHeight); this.world.reset(); this.world.spawnAgents(); this.world.agents?.forEach(a => { if (!a) return; a.net.lr = this.settings.learningRate; a.net.lambda = this.settings.lambda; a.net.gamma = this.settings.gamma; if (a.critic) a.critic.lr = this.settings.learningRate; if (a.policySelector) a.policySelector.lr = this.settings.learningRate * 0.6; }); Logger.log('üîÑ –°–∏–º—É–ª—è—Ü–∏—è —Å–±—Ä–æ—à–µ–Ω–∞', 'warn'); this.updateStats(); this.updateMetrics(); }
    loop() { if (!this.running) return; if (!this.ctx || !this.world) { console.error('Context or world lost'); this.running = false; return; } if (!this.world.agents?.length || this.world.agents.length < 2) { console.error('Invalid agents in world'); this.running = false; Logger.log('‚ùå –û—à–∏–±–∫–∞: –∞–≥–µ–Ω—Ç—ã –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –∏–ª–∏ –Ω–µ–≤–∞–ª–∏–¥–Ω—ã', 'error'); return; } const now = performance.now(), dt = Math.min((now - this.lastTime) / 16.67, 3), fps = Math.round(1000 / (now - this.lastTime + 0.001)); this.fps = fps; this.lastTime = now; const fpsEl = document.getElementById('fpsCounter'); if (fpsEl) fpsEl.textContent = `FPS: ${this.fps}`; try { const state = this.world.update(dt); this.world.draw(this.ctx, this.vision); this.updateStats(state); if (this.showMetrics) this.updateMetrics(); if (this.debug) this.updateDebugPanel(); if (this.professionalMode) this.updateProfessionalPanel(); } catch (e) { console.error('Loop error:', e); Logger.log(`‚ùå –û—à–∏–±–∫–∞ –≤ —Ü–∏–∫–ª–µ: ${e.message}`, 'error'); this.running = false; return; } this.rafId = requestAnimationFrame(() => this.loop()); }
    updateStats(state = null) { if (!state) { if (!this.world?.agents?.length || this.world.agents.length < 2) return; state = { pointsLeft: this.world.points?.filter(p => p && !p.collected).length || 0, episode: this.world.episode }; } const { pointsLeft, episode } = state; const aliveAgents = this.world.agents.filter(a => a?.alive); const episodeEl = document.getElementById('episodeStat'), stepEl = document.getElementById('stepStat'), dotsEl = document.getElementById('dotsStat'), obstaclesEl = document.getElementById('obstaclesStat'), agentCountEl = document.getElementById('agentCountBadge'); if (episodeEl) episodeEl.textContent = episode; if (stepEl) stepEl.textContent = this.world.step; if (dotsEl) dotsEl.textContent = pointsLeft; if (obstaclesEl) obstaclesEl.textContent = this.world.walls.length; if (agentCountEl) agentCountEl.textContent = aliveAgents.length;
        if (aliveAgents.length > 0) { const avgFit = aliveAgents.reduce((s, a) => s + a.cumulativeReward, 0) / aliveAgents.length, bestFit = Math.max(...aliveAgents.map(a => a.cumulativeReward)), fitnessEl = document.getElementById('fitnessStat'), bestFitnessEl = document.getElementById('bestFitnessStat'); if (fitnessEl) fitnessEl.textContent = avgFit.toFixed(1); if (bestFitnessEl) bestFitnessEl.textContent = bestFit.toFixed(1); const progressEl = document.getElementById('episodeProgress'); if (progressEl) { progressEl.style.width = `${(episode % 10) * 10}%`; progressEl.setAttribute('aria-valuenow', String((episode % 10) * 10)); } }
        const agentsList = document.getElementById('agentsList'); if (agentsList && aliveAgents.length <= 10) { agentsList.innerHTML = aliveAgents.slice(0, 10).map(a => `<div class="agent-card" style="border-left-color:${a.color}"><div class="agent-header"><span style="color:${a.color}">‚óè</span> ${a.id} <span class="role-badge">${a.teamRole || '‚Äî'}</span></div><div class="health-bar"><div class="health-fill ${a.health < a.stats.maxHealth * 0.3 ? 'low' : ''}" style="width:${(a.health / a.stats.maxHealth) * 100}%"></div></div><div class="agent-stats"><span>HP:${Math.round(a.health)}</span><span>W:${a.wins}</span><span>G:${a.generation}</span></div></div>`).join('') || '<div style="color:var(--text-muted)">–ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –∞–≥–µ–Ω—Ç–æ–≤</div>'; }
        if (arenaConfig.gameMode.type === 'tournament' && this.world?.teams) {
            let alliances = 0, wars = 0, coop = 0, betrayals = 0; const reputationMap = new Map();
            this.world.agents?.forEach(a => { if (!a?.alive) return; reputationMap.set(a.id, { name: a.id, rep: a.socialMemory.reputation, fame: a.socialMemory.fame }); a.socialMemory.otherTeams?.forEach((record) => { if (record.trust > 0.5) alliances++; if (record.trust < -0.5) wars++; }); a.socialMemory.lastCooperation?.forEach((rec) => { if (Date.now() - rec.timestamp < 10000) { if (rec.success) coop++; else betrayals++; } }); });
            const allianceEl = document.getElementById('allianceCount'), warEl = document.getElementById('warCount'), coopEl = document.getElementById('coopCount'), betrayalEl = document.getElementById('betrayalCount');
            if (allianceEl) allianceEl.textContent = Math.floor(alliances / 2); if (warEl) warEl.textContent = Math.floor(wars / 2); if (coopEl) coopEl.textContent = coop; if (betrayalEl) betrayalEl.textContent = betrayals;
            const topRep = Array.from(reputationMap.values()).sort((a, b) => b.rep - a.rep).slice(0, 3); const repEl = document.getElementById('topReputation');
            if (repEl) { repEl.innerHTML = topRep.map((r, i) => `<div>${i+1}. ${r.name.slice(0,10)}: <b style="color:${r.rep>0?'#00ff9d':'#ff5577'}">${r.rep.toFixed(2)}</b></div>`).join('') || '<div style="color:var(--text-muted)">–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö</div>'; }
            const teamsEl = document.getElementById('teamsList'); if (teamsEl) { teamsEl.innerHTML = Array.from(this.world.teams.values()).map(team => { const alive = team.members.filter(m => m?.alive).length; const avgRep = team.members.reduce((s, m) => s + (m?.socialMemory?.reputation || 0), 0) / (team.members.length || 1); return `<div class="legend-item"><div class="legend-color" style="background:${team.color}"></div><span>–ö–æ–º–∞–Ω–¥–∞ ${team.id}: ${alive}/${team.members.length} üèÜ ${avgRep.toFixed(1)}</span></div>`; }).join('') || '<div style="color:var(--text-muted)">–ù–µ—Ç –∫–æ–º–∞–Ω–¥</div>'; }
        }
    }
    updateMetrics() { if (!this.showMetrics || !this.world?.agents?.length || this.world.agents.length < 2) return; const aliveAgents = this.world.agents.filter(a => a?.alive); if (aliveAgents.length === 0) return; const avgTD = aliveAgents.reduce((s, a) => s + a.getLearningMetrics().avgTDError, 0) / aliveAgents.length, avgPred = aliveAgents.reduce((s, a) => s + a.getLearningMetrics().avgPredictionError, 0) / aliveAgents.length, avgEnt = aliveAgents.reduce((s, a) => s + a.getLearningMetrics().avgPolicyEntropy, 0) / aliveAgents.length, avgWin = aliveAgents.reduce((s, a) => s + a.getLearningMetrics().winRate, 0) / aliveAgents.length, avgColl = aliveAgents.reduce((s, a) => s + a.getLearningMetrics().collectionRate, 0) / aliveAgents.length, avgSurv = aliveAgents.reduce((s, a) => s + a.getLearningMetrics().survivalTime, 0) / aliveAgents.length;
        const tdEl = document.getElementById('metricTDError'), predEl = document.getElementById('metricPredError'), entEl = document.getElementById('metricEntropy'), winEl = document.getElementById('metricWinRate'), collEl = document.getElementById('metricCollection'), survEl = document.getElementById('metricSurvival');
        if (tdEl) { tdEl.textContent = avgTD.toFixed(4); tdEl.className = `metric-value${avgTD < 0.5 ? ' good' : avgTD > 2 ? ' degrading' : ''}`; } if (predEl) { predEl.textContent = avgPred.toFixed(3); predEl.className = `metric-value${avgPred < 0.3 ? ' good' : avgPred > 0.7 ? ' degrading' : ''}`; } if (entEl) { entEl.textContent = avgEnt.toFixed(3); entEl.className = `metric-value${avgEnt > 0.1 && avgEnt < 0.8 ? ' good' : ''}`; } if (winEl) winEl.textContent = avgWin.toFixed(2); if (collEl) collEl.textContent = avgColl.toFixed(2); if (survEl) survEl.textContent = avgSurv.toFixed(2);
        const progressTDEl = document.getElementById('progressTD'), progressEntropyEl = document.getElementById('progressEntropy'), progressPredEl = document.getElementById('progressPred'); if (progressTDEl) { const w = Utils.clamp(100 - avgTD * 20, 0, 100); progressTDEl.style.width = `${w}%`; progressTDEl.setAttribute('aria-valuenow', String(Math.round(w))); } if (progressEntropyEl) { const w = Utils.clamp(avgEnt * 100, 0, 100); progressEntropyEl.style.width = `${w}%`; progressEntropyEl.setAttribute('aria-valuenow', String(Math.round(w))); } if (progressPredEl) { const w = Utils.clamp(100 - avgPred * 100, 0, 100); progressPredEl.style.width = `${w}%`; progressPredEl.setAttribute('aria-valuenow', String(Math.round(w))); }
    }
    updateDebugPanel() { const panel = document.getElementById('debugPanel'), isActive = this.debug && this.selectedAgent; panel.classList.toggle('active', isActive); panel.hidden = !isActive; if (!isActive || !this.selectedAgent) return; const info = this.selectedAgent.getDebugInfo(), setDebugValue = (id, value) => { const el = document.getElementById(id); if (el) el.textContent = value; };
        setDebugValue('dbgMode', info.mode); setDebugValue('dbgTarget', info.target); setDebugValue('dbgSpeed', info.speed); setDebugValue('dbgAggro', info.aggro); setDebugValue('dbgMemory', info.memory); setDebugValue('dbgNeurons', info.neurons); setDebugValue('dbgReward', info.reward); setDebugValue('dbgStuck', info.stuck); setDebugValue('dbgConf', info.confidence); setDebugValue('dbgTDErr', info.tdError); setDebugValue('dbgEntropy', info.policyEntropy); setDebugValue('dbgPredErr', info.predError); setDebugValue('dbgWinRate', info.winRate); setDebugValue('dbgCollection', info.collectionRate); setDebugValue('dbgGate0', info.gate0); setDebugValue('dbgGate1', info.gate1); setDebugValue('dbgExpert0', info.expert0); setDebugValue('dbgExpert1', info.expert1); setDebugValue('dbgLoadBal', info.loadBal); setDebugValue('dbgHebbian', info.hebbian); setDebugValue('dbgTeam', info.team); setDebugValue('dbgRole', info.role); setDebugValue('dbgTrust', info.trust); setDebugValue('dbgReputation', info.reputation);
        const confBar = document.getElementById('dbgConfBar'), confVal = document.getElementById('dbgConfVal'); if (confBar) { const w = (this.selectedAgent.predictive.confidence || 0.5) * 100; confBar.style.width = `${w}%`; confBar.setAttribute('aria-valuenow', String(Math.round(w))); } if (confVal) confVal.textContent = info.confidence;
    }
    updateProfessionalPanel() { if (!this.professionalMode || !this.selectedAgent) return; const showWeights = document.getElementById('showWeights')?.checked, showAttention = document.getElementById('showAttention')?.checked; const weightSample = document.getElementById('weightSample'), attentionSample = document.getElementById('attentionSample'); if (showWeights && weightSample && this.selectedAgent.net._W1?.[0]?.[0] !== undefined) { const sample = this.selectedAgent.net._W1[0].slice(0, 20).map(v => `<span class="weight-value ${v > 0.1 ? 'weight-pos' : v < -0.1 ? 'weight-neg' : 'weight-zero'}">${v.toFixed(3)}</span>`).join(' '); weightSample.innerHTML = sample; weightSample.style.display = 'block'; } else if (weightSample) { weightSample.style.display = 'none'; } if (showAttention && attentionSample && this.selectedAgent.net._lastAttentionWeights?.[0]?.[0] !== undefined) { const sample = this.selectedAgent.net._lastAttentionWeights[0].slice(0, 10).map(v => `<span class="weight-value ${v > 0.1 ? 'weight-pos' : v < -0.1 ? 'weight-neg' : 'weight-zero'}">${v.toFixed(3)}</span>`).join(' '); attentionSample.innerHTML = sample; attentionSample.style.display = 'block'; } else if (attentionSample) { attentionSample.style.display = 'none'; } }
    toggleDebug() { this.debug = !this.debug; const btn = document.getElementById('btnDebug'); if (btn) { btn.classList.toggle('active', this.debug); btn.setAttribute('aria-pressed', String(this.debug)); } this.updateDebugPanel(); Logger.log(`üîç Debug ${this.debug ? '–≤–∫–ª—é—á—ë–Ω' : '–≤—ã–∫–ª—é—á–µ–Ω'}`, this.debug ? 'success' : 'info'); }
    toggleProfessional() { this.professionalMode = !this.professionalMode; const btn = document.getElementById('btnToggleProfessional'), content = document.getElementById('professionalContent'); if (btn) { btn.textContent = this.professionalMode ? 'üî¨ Professional Mode: ON' : 'üî¨ –í–∫–ª—é—á–∏—Ç—å Professional Mode'; btn.classList.toggle('active', this.professionalMode); btn.setAttribute('aria-pressed', String(this.professionalMode)); document.body.classList.toggle('professional-mode', this.professionalMode); } if (content) { content.style.display = this.professionalMode ? 'block' : 'none'; } Logger.log(`‚ö° Professional Mode ${this.professionalMode ? '–∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω' : '–¥–µ–∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω'}`, this.professionalMode ? 'success' : 'info'); if (this.professionalMode) this.updateProfessionalPanel(); }
    updateBtns() { const visionBtn = document.getElementById('btnVision'), metricsBtn = document.getElementById('btnMetrics'); if (visionBtn) { visionBtn.classList.toggle('active', this.vision); visionBtn.setAttribute('aria-pressed', String(this.vision)); } if (metricsBtn) { metricsBtn.classList.toggle('active', this.showMetrics); metricsBtn.setAttribute('aria-pressed', String(this.showMetrics)); } }
    save() { try { const data = { version: '4.1.0', timestamp: Date.now(), settings: this.settings, world: { episode: this.world.episode, step: this.world.step, points: this.world.points.map(p => ({ x: p.x, y: p.y, type: p.type, collected: p.collected })), walls: this.world.walls.map(w => ({ x: w.x, y: w.y })) }, agents: this.world.agents.map(a => a ? a.toJSON() : null).filter(a => a) }; localStorage.setItem('aiArenaV4.1.0Save', JSON.stringify(data)); Logger.log('üíæ –°–æ—Ö—Ä–∞–Ω–µ–Ω–æ (v4.1.0 Professional)', 'success'); } catch (e) { if (e.name === 'QuotaExceededError') Logger.log('üíæ –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω–æ: –ø—Ä–µ–≤—ã—à–µ–Ω –ª–∏–º–∏—Ç —Ö—Ä–∞–Ω–∏–ª–∏—â–∞', 'error'); else Logger.log(`‚ùå –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è: ${e.message}`, 'error'); } }
    load() { try { const raw = localStorage.getItem('aiArenaV4.1.0Save'); if (!raw) { Logger.log('‚ùå –ù–µ—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–π v4.1.0', 'error'); return; } const data = JSON.parse(raw); if (data.version !== '4.1.0') { Logger.log('‚ö†Ô∏è –¢—Ä–µ–±—É–µ—Ç—Å—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ v4.1.0', 'warn'); return; } this.settings = { ...this.settings, ...data.settings }; document.getElementById('learningRate').value = this.settings.learningRate; document.getElementById('lambda').value = this.settings.lambda; document.getElementById('gamma').value = this.settings.gamma; document.getElementById('entropyCoeff').value = this.settings.entropyCoeff; document.getElementById('mutationRate').value = this.settings.mutationRate; document.getElementById('skillGrowth').value = this.settings.skillGrowthRate; document.getElementById('learningRateValue').textContent = this.settings.learningRate; document.getElementById('lambdaValue').textContent = this.settings.lambda; document.getElementById('gammaValue').textContent = this.settings.gamma; document.getElementById('entropyValue').textContent = this.settings.entropyCoeff; document.getElementById('mutationRateValue').textContent = this.settings.mutationRate; document.getElementById('skillGrowthValue').textContent = this.settings.skillGrowthRate; this.world.episode = data.world?.episode || 0; this.world.step = data.world?.step || 0; this.world.points = data.world?.points?.map(p => Object.assign(new SmartPoint(p.x, p.y, p.type), { collected: p.collected })) || []; this.world.walls = data.world?.walls || []; this.world.agents = data.agents?.map((a, i) => a ? Agent.fromJSON(a, arenaConfig.gameMode.colors[i % arenaConfig.gameMode.colors.length]) : null).filter(a => a) || []; this.world.agents.forEach(a => { if (!a) return; a.net.lr = this.settings.learningRate; a.net.lambda = this.settings.lambda; a.net.gamma = this.settings.gamma; if (a.critic) a.critic.lr = this.settings.learningRate; if (a.policySelector) a.policySelector.lr = this.settings.learningRate * 0.6; }); Logger.log('üìÇ –ó–∞–≥—Ä—É–∂–µ–Ω–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ v4.1.0', 'success'); this.updateStats({ pointsLeft: this.world.points?.filter(p => p && !p.collected).length || 0, episode: this.world.episode }); this.updateMetrics(); } catch (e) { Logger.log(`‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏: ${e.message}`, 'error'); } }
    exportWeights() { try { const data = { version: '4.1.0', timestamp: Date.now(), agents: this.world.agents.map(a => a ? a.toJSON() : null).filter(a => a) }, blob = new Blob([JSON.stringify(data)], { type: 'application/json' }), url = URL.createObjectURL(blob), a = document.createElement('a'); a.href = url; a.download = `arena-v4.1.0-agents-${Date.now()}.json`; a.click(); URL.revokeObjectURL(url); Logger.log('üì§ –ê–≥–µ–Ω—Ç—ã —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω—ã', 'success'); } catch (e) { Logger.log(`‚ùå –û—à–∏–±–∫–∞ —ç–∫—Å–ø–æ—Ä—Ç–∞: ${e.message}`, 'error'); } }
    importWeights(e) { const file = e.target.files?.[0]; if (!file) return; if (file.size > 10 * 1024 * 1024) { Logger.log('‚ùå –§–∞–π–ª —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π (–º–∞–∫—Å. 10MB)', 'error'); e.target.value = ''; return; } const reader = new FileReader(); reader.onload = (ev) => { try { const result = ev.target?.result; if (typeof result !== 'string') throw new Error('Invalid file content'); const data = JSON.parse(result); if (data.version !== '4.1.0') throw new Error('–¢—Ä–µ–±—É–µ—Ç—Å—è —Ñ–æ—Ä–º–∞—Ç v4.1.0'); if (!data.agents?.length) throw new Error('–ù–µ–≤–µ—Ä–Ω–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ —Ñ–∞–π–ª–∞'); this.world.agents = data.agents.map((a, i) => a ? Agent.fromJSON(a, arenaConfig.gameMode.colors[i % arenaConfig.gameMode.colors.length]) : null).filter(a => a); this.world.agents.forEach(a => { if (!a) return; a.net.lr = this.settings.learningRate; a.net.lambda = this.settings.lambda; a.net.gamma = this.settings.gamma; if (a.critic) a.critic.lr = this.settings.learningRate; if (a.policySelector) a.policySelector.lr = this.settings.learningRate * 0.6; }); Logger.log('üì• –ê–≥–µ–Ω—Ç—ã –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω—ã', 'success'); } catch (err) { Logger.log(`‚ùå –û—à–∏–±–∫–∞ –∏–º–ø–æ—Ä—Ç–∞: ${err.message}`, 'error'); } finally { e.target.value = ''; } }; reader.readAsText(file); }
    importPretrained(e) { const file = e.target.files?.[0]; if (!file) return; if (file.size > 10 * 1024 * 1024) { Logger.log('‚ùå –§–∞–π–ª —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π (–º–∞–∫—Å. 10MB)', 'error'); e.target.value = ''; return; } const reader = new FileReader(); reader.onload = (ev) => { try { const result = ev.target?.result; if (typeof result !== 'string') throw new Error('Invalid file content'); const data = JSON.parse(result); if (!data.agents?.length) throw new Error('–ù–µ–≤–µ—Ä–Ω–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ —Ñ–∞–π–ª–∞'); this.world.agents = data.agents.map((a, i) => a ? Agent.fromJSON(a, arenaConfig.gameMode.colors[i % arenaConfig.gameMode.colors.length]) : null).filter(a => a); this.world.agents.forEach(a => { if (!a) return; a.net.lr = this.settings.learningRate; a.net.lambda = this.settings.lambda; a.net.gamma = this.settings.gamma; if (a.critic) a.critic.lr = this.settings.learningRate; if (a.policySelector) a.policySelector.lr = this.settings.learningRate * 0.6; }); Logger.log('üì• Pretrained weights –∑–∞–≥—Ä—É–∂–µ–Ω—ã', 'success'); } catch (err) { Logger.log(`‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ pretrain: ${err.message}`, 'error'); } finally { e.target.value = ''; } }; reader.readAsText(file); }
    destroy() { if (this.rafId) { cancelAnimationFrame(this.rafId); this.rafId = null; } window.removeEventListener('resize', this._onResize); document.removeEventListener('keydown', this._onKey); if (this.canvas) { this.canvas.removeEventListener('click', this._onClick); this.canvas.removeEventListener('touchend', this._onClick); } this.running = false; }
}

// ============================================================================
// GLOBAL INITIALIZATION
// ============================================================================
window.arenaGame = null;
if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', initArena); else initArena();
function initArena() { try { window.arenaGame = new GameEngine(); if (window.arenaGame) console.log('‚úÖ AI Arena v4.1.0 initialized'); } catch (e) { console.error('‚ùå Failed to initialize AI Arena:', e); console.error('Stack:', e.stack); alert('–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏: ' + e.message); } }
window.addEventListener('beforeunload', () => { if (window.arenaGame) { window.arenaGame.destroy(); window.arenaGame = null; } });

// ============================================================================
// AUDIT VERIFICATION ‚Äî RUN ON LOAD
// ============================================================================
if (typeof window !== 'undefined') { window.addEventListener('load', () => { setTimeout(() => { try { const nn = new NeuralNetwork({ seed: 'audit_test' }), h1 = new Array(48).fill(0).map((_, i) => Math.sin(i * 0.1)), attnResult = nn._selfAttention(h1); console.assert(attnResult.length === 48, 'Attention output dimension mismatch'); console.assert(attnResult.every(v => isFinite(v)), 'Attention produced invalid values'); const inputs = new Array(arenaConfig.compactInputs ? 25 : 57).fill(0).map((_, i) => i * 0.01), forwardResult = nn.forward(inputs); console.assert(forwardResult.gateProbs?.length === 4, 'Gate probs missing'); console.assert(forwardResult.loadBalanceLoss !== undefined, 'Load balance loss missing'); const ps = new PolicySelector({ seed: 'audit_test' }), context = [0.5, 0.3, 0.8, 0.2, 0.6, 0.4, 0.7, 0.1], skills = [0.3, 0.4, 0.2, 0.5, 0.6], { probs } = ps.forward(context, skills), policyResult = ps.update(context, skills, 2, 0.5); console.assert(policyResult.entropy !== undefined, 'Entropy not computed'); console.assert(policyResult.loss !== undefined, 'Loss not returned'); Logger.log('‚úÖ All audit fixes verified: attention, MoE, policy, Hebbian, multi-agent', 'success'); } catch (e) { Logger.log(`‚ùå Audit verification failed: ${e.message}`, 'error'); } }, 1000); }); }
</script>
</body>
</html>



              <script>
                              // –í –∫–æ–Ω—Å–æ–ª–∏ –ø–æ—Å–ª–µ –∑–∞–ø—É—Å–∫–∞:
const agents = window.arenaGame.world.agents.filter(a => a?.alive);
console.log(`üë• –ê–≥–µ–Ω—Ç–æ–≤: ${agents.length}`);
console.log(`üéØ –ö–æ–º–∞–Ω–¥: ${new Set(agents.map(a=>a?.team)).size}`);
console.log(`üß† –í–µ—Å–∞ –º–µ–Ω—è—é—Ç—Å—è: ${agents[0]?.net?._W1?.[0]?.[0] !== undefined}`);
console.log(`ü§ù –°–æ—Ü–ø–∞–º—è—Ç—å: ${agents[0]?.socialMemory?.individuals?.size !== undefined}`);
console.log(`‚ö° Professional: ${arenaConfig.professionalMode}`);
console.log(`üîÄ Compact mode: ${arenaConfig.compactInputs}`);
console.log(`üé≠ –≠–∫—Å–ø–µ—Ä—Ç—ã: ${agents[0]?.net?.getActiveExperts?.()?.join(', ')}`);


              </script>
                        </body>
                        </html>
