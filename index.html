<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline'; connect-src 'self'; img-src 'self'; font-src 'self'; base-uri 'self'; form-action 'self';">
    <meta name="description" content="AI Arena v5.0.1 Professional ‚Äî CORTEX2BRAIN Universal Neural Engine [FULLY INTEGRATED]">
    <meta name="theme-color" content="#0a0a15">
    <meta name="robots" content="noindex">
    <title>üéÆ AI Arena v5.0.1 Professional ‚Äî CORTEX2BRAIN Integrated [PRO]</title>
    <style>
        :root {
            --bg: #0a0a15; --bg-gradient-start: #0a0a15; --bg-gradient-end: #1a1a2e;
            --panel: #121225; --panel-alpha: rgba(18, 18, 37, 0.95);
            --text: #e0e0ff; --text-dim: #b0b0d0; --text-muted: #707090;
            --primary: #00f2ff; --primary-dark: #00c4d4; --accent: #ff0066;
            --success: #00ff9d; --warning: #ffaa00; --danger: #ff4444;
            --border: #2a2a45; --border-light: #3a3a5a;
            --purple: #aa88ff; --yellow: #ffdd44; --pink: #ff66cc; --cyan: #00d4ff;
            --stat-str: #ff4444; --stat-spd: #4444ff; --stat-hp: #44ff44; --stat-dod: #aa88ff;
            --learning-good: #00ff9d; --learning-bad: #ff5577; --learning-neutral: #ffaa00;
            --mode-combat-bg: rgba(255, 170, 0, 0.15); --mode-combat-text: #ffaa00;
            --mode-flee-bg: rgba(255, 68, 68, 0.15); --mode-flee-text: #ff4444;
            --mode-explore-bg: rgba(0, 242, 255, 0.15); --mode-explore-text: #00f2ff;
            --mode-hunt-bg: rgba(170, 136, 255, 0.15); --mode-hunt-text: #aa88ff;
            --mode-avoid-bg: rgba(255, 221, 68, 0.15); --mode-avoid-text: #ffdd44;
            --team-blue: #00d4ff; --team-red: #ff5577; --team-green: #00ff9d; --team-yellow: #ffdd44;
            --sidebar-width: 440px; --header-height: 48px; --panel-radius: 12px;
            --btn-radius: 8px; --input-radius: 6px; --card-radius: 10px;
            --transition-fast: 150ms ease; --transition-normal: 250ms ease;
            --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.3); --shadow-md: 0 4px 8px rgba(0, 0, 0, 0.4);
            --z-canvas: 1; --z-sidebar: 10; --z-header: 100; --z-modal: 1000;
        }
        @supports not (--css: variables) {
            body { background: #0a0a15; color: #e0e0ff; }
            .sidebar { background: #121225; }
            .panel { background: rgba(0, 0, 0, 0.3); border-color: #2a2a45; }
        }
        *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }
        html { font-size: 16px; -webkit-text-size-adjust: 100%; scroll-behavior: smooth; }
        body {
            background: linear-gradient(135deg, var(--bg-gradient-start) 0%, var(--bg-gradient-end) 100%);
            color: var(--text); font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            font-size: 0.875rem; line-height: 1.4; overflow: hidden; user-select: none;
            touch-action: manipulation; text-rendering: optimizeLegibility;
            -webkit-font-smoothing: antialiased;
        }
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
            .winner-banner { animation: none !important; }
        }
        :focus-visible { outline: 2px solid var(--primary); outline-offset: 2px; }
        button:focus-visible, input:focus-visible, select:focus-visible {
            outline: 2px solid var(--primary); outline-offset: 2px;
            box-shadow: 0 0 0 4px rgba(0, 242, 255, 0.2);
        }
        .skip-link { position: absolute; top: -40px; left: 0; background: var(--primary); color: #000; padding: 0.5rem 1rem; z-index: var(--z-modal); border-radius: 0 0 4px 4px; }
        .skip-link:focus { top: 0; }
        .container {
            display: grid; grid-template-columns: 1fr var(--sidebar-width);
            grid-template-rows: var(--header-height) 1fr; grid-template-areas: "header header" "canvas sidebar";
            height: 100vh; width: 100vw;
        }
        .header {
            grid-area: header; background: var(--panel); border-bottom: 1px solid var(--border);
            padding: 0.5rem 1rem; display: flex; justify-content:space-between; align-items: center;
            z-index: var(--z-header);
        }
        .header h1 { font-size: 1rem; font-weight: 700; color: var(--primary); display: flex; align-items: center; gap: 0.5rem; margin: 0; }
        .version-badge { background: var(--accent); color: #fff; padding: 0.125rem 0.375rem; border-radius: 0.25rem; font-size: 0.625rem; font-weight: 600; }
        .fps-counter { font-family: monospace; color: var(--success); font-weight: 700; font-size: 0.875rem; background: rgba(0, 255, 157, 0.1); padding: 0.25rem 0.5rem; border-radius: 0.375rem; min-width: 70px; text-align: center; }
        #gameCanvas { grid-area: canvas; width: 100%; height: 100%; display: block; cursor: crosshair; touch-action: none; }
        .sidebar {
            grid-area: sidebar; background: var(--panel); border-left: 1px solid var(--border);
            padding: 0.625rem; overflow-y: auto; display: flex; flex-direction: column; gap: 0.5rem;
            scrollbar-width: thin; scrollbar-color: var(--border) var(--bg);
        }
        .sidebar::-webkit-scrollbar { width: 0.25rem; }
        .sidebar::-webkit-scrollbar-track { background: var(--bg); }
        .sidebar::-webkit-scrollbar-thumb { background: var(--border); border-radius: 0.125rem; }
        .panel {
            background: var(--panel-alpha); border: 1px solid var(--border); border-radius: var(--panel-radius);
            padding: 0.5rem; backdrop-filter: blur(4px);
        }
        .panel-title { color: var(--primary); font-size: 0.75rem; font-weight: 700; margin-bottom: 0.375rem; display: flex; align-items: center; gap: 0.3125rem; padding-bottom: 0.25rem; border-bottom: 1px solid var(--border); text-transform: uppercase; letter-spacing: 0.5px; }
        .stat-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.25rem; }
        .stat { background: rgba(0, 0, 0, 0.2); padding: 0.25rem 0.375rem; border-radius: 0.375rem; font-size: 0.625rem; border: 1px solid transparent; }
        .stat:hover { border-color: var(--border-light); background: rgba(0, 0, 0, 0.25); }
        .stat-label { color: var(--text-dim); display: block; margin-bottom: 0.0625rem; font-size: 0.5625rem; }
        .stat-value { color: var(--primary); font-weight: 700; font-family: monospace; font-size: 0.6875rem; }
        .stat-value.good { color: var(--success); } .stat-value.bad { color: var(--danger); }
        .control-group { margin-bottom: 0.375rem; }
        .control-label { display: flex; justify-content: space-between; align-items: center; font-size: 0.6875rem; margin-bottom: 0.125rem; color: var(--text-dim); }
        input[type="range"] { width: 100%; height: 0.25rem; background: var(--border); border-radius: 0.125rem; appearance: none; cursor: pointer; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 0.75rem; height: 0.75rem; background: var(--primary); border-radius: 50%; cursor: pointer; border: 2px solid var(--bg); }
        select { width: 100%; padding: 0.375rem 0.5rem; background: rgba(0, 0, 0, 0.3); border: 1px solid var(--border); border-radius: var(--input-radius); color: var(--text); font-size: 0.6875rem; cursor: pointer; }        .btn-group { display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.25rem; margin-top: 0.25rem; }
        .btn-group-3 { display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.25rem; margin-top: 0.25rem; }
        .btn-group-4 { display: grid; grid-template-columns: repeat(4, 1fr); gap: 0.25rem; margin-top: 0.25rem; }
        button {
            padding: 0.375rem 0.5rem; border: none; border-radius: var(--btn-radius); font-weight: 700;
            cursor: pointer; font-size: 0.6875rem; background: var(--border); color: var(--text);
            min-height: 2rem; transition: all var(--transition-fast); text-transform: uppercase; letter-spacing: 0.5px;
            display: flex; align-items: center; justify-content: center; gap: 0.25rem; position: relative; overflow: hidden;
        }
        button:hover:not(:disabled) { background: var(--border-light); }
        button:active { transform: translateY(1px); }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-primary { background: var(--primary); color: #000; }
        .btn-danger { background: var(--danger); color: #fff; }
        .btn-success { background: var(--success); color: #000; }
        .btn-secondary { background: var(--border); color: var(--text); }
        .btn-toggle.active { background: var(--accent); color: #fff; }
        .toggle { display: flex; align-items: center; gap: 0.25rem; font-size: 0.6875rem; margin-bottom: 0.1875rem; color: var(--text-dim); cursor: pointer; user-select: none; }
        .toggle input { accent-color: var(--primary); width: 0.875rem; height: 0.875rem; cursor: pointer; }
        .log {
            background: #000; border: 1px solid var(--border); border-radius: 0.5rem; padding: 0.375rem;
            height: 5.625rem; overflow-y: auto; font-size: 0.5625rem; font-family: monospace;
            word-break: break-word; white-space: pre-wrap;
        }
        .log-entry { margin-bottom: 0.125rem; padding-bottom: 0.125rem; border-bottom: 1px solid #111; line-height: 1.3; }
        .log-entry.info { color: var(--primary); } .log-entry.success { color: var(--success); }
        .log-entry.warn { color: var(--warning); } .log-entry.error { color: var(--danger); }
        .progress-bar { height: 0.25rem; background: rgba(0, 0, 0, 0.3); border-radius: 0.1875rem; overflow: hidden; margin-top: 0.1875rem; }
        .progress-fill { height: 100%; background: linear-gradient(90deg, var(--primary), var(--success)); transition: width var(--transition-normal); }

        /* TEAM-BASED AGENT CARDS */
        .agent-card {
            display: flex; flex-direction: column; gap: 0.25rem; padding: 0.375rem;
            background: rgba(0, 0, 0, 0.2); border-radius: var(--card-radius); margin-bottom: 0.375rem;
            border-left: 4px solid transparent; position: relative;
        }
        .agent-card.team-blue { border-left-color: var(--team-blue); background: rgba(0, 212, 255, 0.08); }
        .agent-card.team-red { border-left-color: var(--team-red); background: rgba(255, 85, 119, 0.08); }
        .agent-card.team-green { border-left-color: var(--team-green); background: rgba(0, 255, 157, 0.08); }
        .agent-card.team-yellow { border-left-color: var(--team-yellow); background: rgba(255, 221, 68, 0.08); }
        .agent-card.dead { opacity: 0.5; filter: grayscale(0.8); }
        .agent-card.dead::after {
            content: '‚ò†Ô∏è'; position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%); font-size: 2rem; opacity: 0.6;
        }
        .agent-header { display: flex; align-items: center; gap: 0.25rem; font-size: 0.6875rem; font-weight: 600; }
        .team-badge {
            display: inline-flex; align-items: center; padding: 0.0625rem 0.25rem;
            border-radius: 0.25rem; font-size: 0.5rem; font-weight: 600; margin-left: 0.25rem;
        }        .team-badge.blue { background: rgba(0, 212, 255, 0.3); color: var(--team-blue); border: 1px solid var(--team-blue); }
        .team-badge.red { background: rgba(255, 85, 119, 0.3); color: var(--team-red); border: 1px solid var(--team-red); }
        .team-badge.green { background: rgba(0, 255, 157, 0.3); color: var(--team-green); border: 1px solid var(--team-green); }
        .team-badge.yellow { background: rgba(255, 221, 68, 0.3); color: var(--team-yellow); border: 1px solid var(--team-yellow); }
        .health-bar { height: 0.25rem; background: rgba(0, 0, 0, 0.3); border-radius: 0.125rem; overflow: hidden; }
        .health-fill { height: 100%; background: linear-gradient(90deg, var(--success), var(--primary)); transition: width var(--transition-fast); }
        .agent-stats { display: flex; justify-content: space-between; font-size: 0.5625rem; color: var(--text-dim); flex-wrap: wrap; gap: 0.125rem; }
        .agent-stats b { color: var(--text); font-weight: 600; }
        .stat-badge {
            display: inline-flex; align-items: center; padding: 0.0625rem 0.1875rem;
            border-radius: 0.125rem; font-size: 0.5rem; font-weight: 600; margin-right: 0.125rem; border: 1px solid transparent;
        }
        .stat-badge.stat-hp { background: rgba(68, 255, 68, 0.15); color: var(--stat-hp); }
        .stat-badge.stat-str { background: rgba(255, 68, 68, 0.15); color: var(--stat-str); }
        .stat-badge.stat-spd { background: rgba(68, 68, 255, 0.15); color: var(--stat-spd); }
        .stat-badge.stat-dod { background: rgba(170, 136, 255, 0.15); color: var(--stat-dod); }
        .weapon-badge {
            display: inline-flex; align-items: center; gap: 0.125rem; padding: 0.0625rem 0.25rem;
            border-radius: 0.25rem; font-size: 0.5rem; font-weight: 600; margin-top: 0.125rem;
            background: rgba(255, 170, 0, 0.15); color: var(--warning); border: 1px solid var(--warning);
        }
        .skills-display { display: grid; grid-template-columns: repeat(5, 1fr); gap: 0.125rem; margin-top: 0.1875rem; }
        .skill-item { text-align: center; font-size: 0.5rem; }
        .skill-bar { height: 0.125rem; background: rgba(0, 0, 0, 0.3); border-radius: 0.0625rem; margin-top: 0.0625rem; overflow: hidden; }
        .skill-fill { height: 100%; transition: width var(--transition-normal); }
        .skill-combat .skill-fill { background: var(--warning); }
        .skill-flee .skill-fill { background: var(--danger); }
        .skill-explore .skill-fill { background: var(--primary); }
        .skill-avoid .skill-fill { background: var(--purple); }
        .mode-badge {
            display: inline-flex; align-items: center; padding: 0.0625rem 0.25rem;
            border-radius: 0.375rem; font-size: 0.5rem; font-weight: 600; margin-left: 0.25rem;
        }
        .mode-combat { background: var(--mode-combat-bg); color: var(--mode-combat-text); }
        .mode-flee { background: var(--mode-flee-bg); color: var(--mode-flee-text); }
        .mode-explore { background: var(--mode-explore-bg); color: var(--mode-explore-text); }
        .mode-hunt { background: var(--mode-hunt-bg); color: var(--mode-hunt-text); }
        .mode-avoid { background: var(--mode-avoid-bg); color: var(--mode-avoid-text); }
        .learning-metrics { display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.1875rem; margin-top: 0.25rem; }
        .metric-item { background: rgba(0, 0, 0, 0.2); padding: 0.1875rem 0.25rem; border-radius: 0.25rem; font-size: 0.5rem; }
        .metric-label { color: var(--text-dim); display: block; font-size: 0.4375rem; }
        .metric-value { color: var(--learning-good); font-weight: 600; font-family: monospace; }
        .learning-progress { display: flex; flex-direction: column; gap: 0.125rem; margin-top: 0.25rem; }
        .progress-row { display: flex; align-items: center; gap: 0.25rem; font-size: 0.5rem; }
        .progress-label { width: 4.375rem; color: var(--text-dim); flex-shrink: 0; }
        .progress-track { flex: 1; height: 0.1875rem; background: rgba(0, 0, 0, 0.3); border-radius: 0.125rem; overflow: hidden; }
        .progress-track.td .progress-fill { background: linear-gradient(90deg, var(--danger), var(--warning), var(--success)); }
        .progress-track.entropy .progress-fill { background: linear-gradient(90deg, var(--warning), var(--primary)); }
        .debug-panel {
            background: rgba(0, 0, 0, 0.4); border: 1px solid var(--border); border-radius: 0.5rem;            padding: 0.375rem; font-size: 0.5625rem; display: none;
        }
        .debug-panel.active { display: block; }
        .debug-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.125rem 0.25rem; }
        .debug-item { display: flex; justify-content: space-between; padding: 0.0625rem 0; }
        .debug-label { color: var(--text-dim); }
        .debug-value { color: var(--primary); font-weight: 600; font-family: monospace; }
        .separator { height: 1px; background: var(--border); margin: 0.375rem 0; }
        input[type="file"] { display: none; }

        /* TEAM STATUS PANEL */
        .team-status {
            display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.375rem;
            margin-top: 0.375rem; padding: 0.375rem; background: rgba(0,0,0,0.2);
            border-radius: 0.375rem;
        }
        .team-status-item {
            display: flex; align-items: center; gap: 0.25rem; justify-content: space-between;
            padding: 0.1875rem; border-radius: 0.25rem;
            background: rgba(0,0,0,0.3);
        }
        .team-status-item.blue { border-left: 2px solid var(--team-blue); }
        .team-status-item.red { border-left: 2px solid var(--team-red); }
        .team-status-item.green { border-left: 2px solid var(--team-green); }
        .team-status-item.yellow { border-left: 2px solid var(--team-yellow); }
        .team-status-count { font-weight: 700; font-size: 0.625rem; }
        .team-status-alive { color: var(--success); }
        .team-status-dead { color: var(--danger); }

        /* WINNER BANNER */
        .winner-banner {
            position: fixed; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            border: 3px solid var(--success);
            border-radius: 1rem;
            padding: 2rem 3rem;
            text-align: center;
            z-index: var(--z-modal);
            display: none;
            animation: winnerPop 0.5s ease-out;
            min-width: 300px;
        }
        .winner-banner.active { display: block; }
        .winner-banner h2 {
            color: var(--success); font-size: 1.5rem;
            margin-bottom: 0.5rem; text-transform: uppercase;
        }
        .winner-banner p { color: var(--text); font-size: 0.875rem; margin-bottom: 0.25rem; }
        .winner-banner .winner-team { font-size: 1.25rem; font-weight: 700; margin: 0.5rem 0; }        .winner-banner .winner-episode { color: var(--text-dim); font-size: 0.75rem; }
        @keyframes winnerPop {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }

        @media (max-width: 1100px) {
            .container { grid-template-columns: 1fr !important; grid-template-rows: var(--header-height) 1fr auto !important; grid-template-areas: "header" "canvas" "sidebar" !important; }
            .sidebar { border-left: none !important; border-top: 1px solid var(--border) !important; max-height: 45vh !important; }
        }
        @media (max-width: 600px) {
            :root { --sidebar-width: 100%; }
            .header { padding: 0.375rem 0.75rem; }
            .header h1 { font-size: 0.875rem; }
            .panel { padding: 0.375rem; }
            .stat-grid { grid-template-columns: repeat(2, 1fr); }
            .btn-group, .btn-group-3 { grid-template-columns: repeat(2, 1fr); }
            .learning-metrics { grid-template-columns: repeat(2, 1fr); }
            .debug-grid { grid-template-columns: 1fr; }
            .team-status { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <a href="#gameCanvas" class="skip-link">–ü–µ—Ä–µ–π—Ç–∏ –∫ —Å–∏–º—É–ª—è—Ü–∏–∏</a>

    <!-- WINNER BANNER -->
    <div class="winner-banner" id="winnerBanner" role="alert" aria-live="polite">
        <h2 id="winnerTitle">üèÜ –ü–û–ë–ï–î–ê!</h2>
        <div class="winner-team" id="winnerTeam">–°–ò–ù–ò–Ø –ö–û–ú–ê–ù–î–ê</div>
        <p id="winnerText">–ö–æ–º–∞–Ω–¥–∞ —É–Ω–∏—á—Ç–æ–∂–µ–Ω–∞</p>
        <p class="winner-episode" id="winnerEpisode">–≠–ø–∏–∑–æ–¥ 1</p>
    </div>

    <div class="container">
        <header class="header">
            <h1>üéÆ AI ARENA <span class="version-badge">v5.0.1 CORTEX2BRAIN [PRO]</span></h1>
            <div class="fps-counter" id="fpsCounter" aria-label="Frames per second">FPS: 60</div>
        </header>
        <canvas id="gameCanvas" role="application" aria-label="AI Arena simulation canvas" tabindex="0"></canvas>
        <aside class="sidebar">
            <!-- MODE SELECTOR -->
            <section class="panel">
                <h2 class="panel-title">üéÆ –†–ï–ñ–ò–ú –ò–ì–†–´</h2>
                <div class="control-group">
                    <label class="control-label"><span>–¢–∏–ø –º–∞—Ç—á–∞</span></label>
                    <select id="gameModeSelect" aria-label="–í—ã–±–æ—Ä —Ä–µ–∂–∏–º–∞ –∏–≥—Ä—ã">
                        <option value="1v1">‚öîÔ∏è –î—É—ç–ª—å (1v1)</option>
                        <option value="2v2">üë• –ö–æ–º–∞–Ω–¥–Ω—ã–π –±–æ–π (2v2)</option>
                        <option value="4way">üî• –í—Å–µ –ø—Ä–æ—Ç–∏–≤ –≤—Å–µ—Ö (4way)</option>                    </select>
                </div>
                <div class="team-status" id="teamStatus" aria-live="polite"></div>
            </section>

            <!-- AGENTS -->
            <section class="panel">
                <h2 class="panel-title">üë• –ë–û–ô–¶–´</h2>
                <div id="agentsContainer" aria-live="polite"></div>
            </section>

            <!-- WEAPONS -->
            <section class="panel">
                <h2 class="panel-title">‚öîÔ∏è –û–†–£–ñ–ò–ï</h2>
                <div id="weaponControls"></div>
                <div class="btn-group">
                    <button class="btn-success" id="btnApplyWeapons">‚úÖ –ü—Ä–∏–º–µ–Ω–∏—Ç—å</button>
                    <button class="btn-secondary" id="btnRandomWeapons">üé≤ –°–ª—É—á–∞–π–Ω–æ</button>
                </div>
            </section>

            <!-- STATS -->
            <section class="panel">
                <h2 class="panel-title">üìä –°–¢–ê–¢–ò–°–¢–ò–ö–ê</h2>
                <div class="stat-grid">
                    <div class="stat"><span class="stat-label">–≠–ø–∏–∑–æ–¥</span><span class="stat-value" id="episodeStat">0</span></div>
                    <div class="stat"><span class="stat-label">–®–∞–≥</span><span class="stat-value" id="stepStat">0</span></div>
                    <div class="stat"><span class="stat-label">–ë–æ–∏</span><span class="stat-value" id="totalFightsStat">0</span></div>
                    <div class="stat"><span class="stat-label">–ü–æ–±–µ–¥—ã</span><span class="stat-value" id="winsStat">0</span></div>
                </div>
                <div class="progress-bar"><div class="progress-fill" id="episodeProgress" style="width: 0%" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100"></div></div>
            </section>

            <!-- LEARNING -->
            <section class="panel">
                <h2 class="panel-title">üß† –û–ë–£–ß–ï–ù–ò–ï</h2>
                <div class="control-group">
                    <label class="control-label"><span>Learning Rate</span><span id="learningRateValue">0.005</span></label>
                    <input type="range" id="learningRate" min="0.001" max="0.05" step="0.001" value="0.005" aria-label="–°–∫–æ—Ä–æ—Å—Ç—å –æ–±—É—á–µ–Ω–∏—è">
                </div>
                <div class="control-group">
                    <label class="control-label"><span>TD Lambda</span><span id="lambdaValue">0.95</span></label>
                    <input type="range" id="lambda" min="0.8" max="0.99" step="0.01" value="0.95" aria-label="–ü–∞—Ä–∞–º–µ—Ç—Ä TD(Œª)">
                </div>
                <div class="control-group">
                    <label class="control-label"><span>Mutation</span><span id="mutationRateValue">0.1</span></label>
                    <input type="range" id="mutationRate" min="0.05" max="0.3" step="0.01" value="0.1" aria-label="–ß–∞—Å—Ç–æ—Ç–∞ –º—É—Ç–∞—Ü–∏–π">
                </div>
                <div class="control-group">
                    <label class="control-label"><span>Policy Temp</span><span id="policyTempValue">0.8</span></label>                    <input type="range" id="policyTemp" min="0.1" max="2.0" step="0.1" value="0.8" aria-label="–¢–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞ –ø–æ–ª–∏—Ç–∏–∫–∏">
                </div>
                <div class="separator"></div>
                <label class="toggle"><input type="checkbox" id="enableTraining" checked> TD(Œª) Learning</label>
                <label class="toggle"><input type="checkbox" id="enableEvolution" checked> Evolution</label>
                <label class="toggle"><input type="checkbox" id="enableFighting" checked> –ë–æ–∏</label>
                <label class="toggle"><input type="checkbox" id="enableRanged" checked> –î–∞–ª—å–Ω–∏–π –±–æ–π</label>
                <label class="toggle"><input type="checkbox" id="enableWeightInheritance" checked> –ù–∞—Å–ª–µ–¥–æ–≤–∞–Ω–∏–µ –≤–µ—Å–æ–≤</label>
                <label class="toggle"><input type="checkbox" id="enableTactical" checked> –¢–∞–∫—Ç–∏–∫–∞</label>
                <label class="toggle"><input type="checkbox" id="enableTeamwork" checked> –ö–æ–º–∞–Ω–¥–Ω–∞—è –∏–≥—Ä–∞</label>
                <label class="toggle"><input type="checkbox" id="enableDeepCognition" checked> Deep Cognition v5.0</label>
            </section>

            <!-- METRICS v5.0.1 -->
            <section class="panel">
                <h2 class="panel-title">üìà METRICS v5.0.1</h2>
                <div class="learning-metrics">
                    <div class="metric-item"><span class="metric-label">TD-Error</span><span class="metric-value" id="metricTDError">0.0000</span></div>
                    <div class="metric-item"><span class="metric-label">Win Rate</span><span class="metric-value" id="metricWinRate">0.00</span></div>
                    <div class="metric-item"><span class="metric-label">Damage</span><span class="metric-value" id="metricDamage">0.00</span></div>
                    <div class="metric-item"><span class="metric-label">Accuracy</span><span class="metric-value" id="metricAccuracy">0.00</span></div>
                    <div class="metric-item"><span class="metric-label">Learning Rate</span><span class="metric-value" id="currentLR">0.0050</span></div>
                    <div class="metric-item"><span class="metric-label">Empathy Acc</span><span class="metric-value" id="empathyAcc">0.00</span></div>
                    <div class="metric-item"><span class="metric-label">Memory Conf</span><span class="metric-value" id="memoryConf">0.50</span></div>
                    <div class="metric-item"><span class="metric-label">Expert Load</span><span class="metric-value" id="expertLoad">0.25/0.25/0.25/0.25</span></div>
                </div>
                <div class="progress-row" style="margin-top:0.375rem">
                    <span class="progress-label">Learning Curve</span>
                    <div class="progress-track"><div class="progress-fill" id="learningCurve" style="width: 0%"></div></div>
                </div>
            </section>

            <!-- CONTROLS -->
            <section class="panel">
                <h2 class="panel-title">üéÆ –£–ü–†–ê–í–õ–ï–ù–ò–ï</h2>
                <div class="btn-group">
                    <button class="btn-primary" id="btnStart" aria-pressed="false">‚ñ∂ –°—Ç–∞—Ä—Ç</button>
                    <button class="btn-danger" id="btnReset">üîÑ –°–±—Ä–æ—Å</button>
                    <button class="btn-success" id="btnSave">üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
                    <button class="btn-secondary" id="btnLoad">üìÇ –ó–∞–≥—Ä—É–∑–∏—Ç—å</button>
                </div>
                <div class="btn-group-3">
                    <button class="btn-toggle" id="btnDebug" aria-pressed="false">üîç Debug</button>
                    <button class="btn-toggle" id="btnVision" aria-pressed="false">üëÅÔ∏è Vision</button>
                    <button class="btn-secondary" id="btnExport">üì§ –≠–∫—Å–ø–æ—Ä—Ç</button>
                </div>
                <input type="file" id="fileImport" accept=".json" aria-label="–ò–º–ø–æ—Ä—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è">
            </section>

            <!-- LOG -->            <section class="panel">
                <h2 class="panel-title">üìù –õ–û–ì</h2>
                <div class="log" id="eventLog" role="log" aria-live="polite" aria-relevant="additions"></div>
            </section>

            <!-- DEBUG v5.0.1 -->
            <section class="debug-panel" id="debugPanel">
                <h3 style="margin-bottom: 0.25rem; font-weight: 600; color: var(--primary); font-size: 0.625rem;">üîç INSPECTOR v5.0.1</h3>
                <div class="debug-grid" id="debugGrid">
                    <div class="debug-item"><span class="debug-label">Mode</span><span class="debug-value" id="dbgMode">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">Weapon</span><span class="debug-value" id="dbgWeapon">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">Health</span><span class="debug-value" id="dbgHealth">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">Team</span><span class="debug-value" id="dbgTeam">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">Wins</span><span class="debug-value" id="dbgWins">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">TD-Error</span><span class="debug-value" id="dbgTDErr">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">Threat</span><span class="debug-value" id="dbgThreat">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">Flank</span><span class="debug-value" id="dbgFlank">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">LR</span><span class="debug-value" id="dbgLR">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">Empathy</span><span class="debug-value" id="dbgEmp">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">MemConf</span><span class="debug-value" id="dbgMemC">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">Imagination</span><span class="debug-value" id="dbgImag">‚Äî</span></div>
                </div>
            </section>
        </aside>
    </div>

<script>
/**
 * AI ARENA v5.0.1 Professional Edition ‚Äî CORTEX2BRAIN Fully Integrated Neural Engine
 * [FULL FEATURE SET: BehaviorArbiter, Emotion Modulation, Key-Derived Architecture, Stable Learning]
 * 
 * ARCHITECTURE:
 * ‚Ä¢ CORTEX2BRAIN v2.2.1 Core ‚Äî Universal neural architecture with real behavioral control
 * ‚Ä¢ BehaviorArbiter v1.0 ‚Äî 5-mode selection (hunt/flee/explore/combat/avoid) with emotion modulation
 * ‚Ä¢ GenericAdapter ‚Äî Maps game-specific inputs/outputs to cortex format
 * ‚Ä¢ SyncConnector ‚Äî Direct function-call integration for game loop
 * ‚Ä¢ Deterministic initialization via key-derived structural factors
 * ‚Ä¢ Zero-allocation mode via BufferPool with try-finally safety for 1M+ ops/sec
 * ‚Ä¢ Smoothed rewards + gradient clipping for stable learning (anti-jitter)
 * 
 * @version 5.0.1-CORTEX-INTEGRATED
 * @author AI Arena Project
 * @license MIT
 */
'use strict';

// ============================================================================
// CONFIGURATION CONSTANTS ‚Äî Immutable, frozen, documented
// ============================================================================
const CONFIG = Object.freeze({    VERSION: '5.0.1-CORTEX-INTEGRATED',
    PHYSICS: {
        AGENT_COLLISION_RADIUS: 20,
        AGENT_REPULSION_STRENGTH: 2.5,
        MAX_VELOCITY: 15,
        VELOCITY_DAMPING: 0.88,
        KNOCKBACK_MASS: 1.0,
        FRICTION_GROUND: 0.92,
        MOVE_ACCEL: 0.12,
        MIN_SPEED: 2.0,
        COLLISION_PUSH: 0.5,
        BOUNCE_STRENGTH: 0.6
    },
    CORTEX: {
        DIM_P: 32, DIM_A: 64, DIM_M: 144, DIM_C: 256, DIM_S: 32, DIM_D: 16,
        DIM_SENSOR: 64, NUM_HEADS: 4, HEAD_DIM: 16,
        M_WORK_START: 0, M_WORK_END: 48, M_PERM_START: 48, M_PERM_END: 96, M_PRED_START: 96, M_PRED_END: 144,
        DEFAULT_LR: 0.005, DEFAULT_GAMMA: 0.99, DEFAULT_LAMBDA: 0.95, DEFAULT_HEBBIAN: 0.002,
        TD_UPDATE_RANGE: { start: 64, end: 128 },
        MAX_GRAD: 0.3, VALUE_CLIP: 2.0
    },
    BEHAVIOR: {
        MODES: ['hunt', 'flee', 'explore', 'combat', 'avoid'],
        MODE_SWITCH_HYSTERESIS: 0.4,
        MODE_SWITCH_PROB: 0.05,
        EMOTION_WEIGHT: 0.4,
        LOGIT_WEIGHT: 0.4,
        CONTEXT_WEIGHT: 0.2,
        DEFAULT_TEMP: 0.8
    },
    LEARNING: {
        REWARD_SMOOTH_ALPHA: 0.15,
        REWARD_CLIP_MIN: -1.5,
        REWARD_CLIP_MAX: 2.5,
        MIN_CONFIDENCE_FOR_LEARN: 0.3,
        ANTI_JITTER_THRESHOLD: 15,
        ANTI_JITTER_PENALTY: 0.3
    },
    GAME: {
        LOGICAL_WIDTH: 820,
        LOGICAL_HEIGHT: 600,
        MODES: { DUEL: '1v1', TEAM: '2v2', FFA: '4way' },
        TEAM_COLORS: { blue: '#00d4ff', red: '#ff5577', green: '#00ff9d', yellow: '#ffdd44' },
        MAX_AGENTS: { '1v1': 2, '2v2': 4, '4way': 4 },
        WIN_CONDITIONS: { '1v1': 'lastStanding', '2v2': 'teamElimination', '4way': 'lastStanding' },
        TEAM_BONUS: 0.3,
        COORDINATION_RADIUS: 80
    },
    TACTICAL: {
        FLANK_BONUS: 0.30,        FRONT_PENALTY: 0.20,
        MIN_FLANK_COMMIT: 0.4,
        CIRCLE_STRENGTH: 0.25,
        RETREAT_HP_THRESHOLD: 0.4,
        THREAT_BUFFER_ANGLE: Math.PI * 0.1,
        DAMAGE_FRONT: 0.6,
        DAMAGE_FLANK: 1.0,
        DAMAGE_BACK: 1.8,
        TEAM_COORDINATION_BONUS: 0.15,
        ALLY_PROTECTION_BONUS: 0.2
    },
    MEMORY: {
        MAX_VISITED_CELLS: 500,
        LEARNING_BUFFER_MAX: 32,
        PREDICTIVE_HISTORY_MAX: 20,
        ENEMY_HISTORY_MAX: 5
    },
    EVOLUTION: {
        DEATH_PENALTY: 0,
        FLEE_PENALTY: -0.5,
        WIN_BONUS: 50,
        TEAM_WIN_BONUS: 100,
        LEARN_FROM_WINNER_RATE: 0.85,
        FORCED_COMBAT_AFTER_DEATH: 30,
        MUTATION_ON_DEATH: 0.2,
        COMBAT_SKILL_GROWTH: 0.15
    }
});

// ============================================================================
// BUFFER POOL ‚Äî Zero-allocation memory management with safety
// ============================================================================
class BufferPool {
    constructor(dimensions) {
        this.pools = new Map();
        for (const [name, dim] of Object.entries(dimensions)) {
            if (!Number.isInteger(dim) || dim <= 0) throw new Error(`Invalid dimension for ${name}: ${dim}`);
            this.pools.set(name, { dim, free: [], inUse: new Set(), stats: { acquired: 0, released: 0, created: 0 } });
        }
    }
    
    acquire(name) {
        const pool = this.pools.get(name);
        if (!pool) throw new Error(`Unknown buffer pool: ${name}`);
        const buf = pool.free.length > 0 ? pool.free.pop() : new Float32Array(pool.dim);
        pool.inUse.add(buf);
        pool.stats.acquired++;
        if (pool.free.length === 0) pool.stats.created++;
        return buf;
    }    
    release(name, buf) {
        const pool = this.pools.get(name);
        if (!pool || !pool.inUse.has(buf)) return false;
        buf.fill(0);
        pool.free.push(buf);
        pool.inUse.delete(buf);
        pool.stats.released++;
        return true;
    }
    
    releaseAll(acquired) {
        if (!this._bufferPool || !Array.isArray(acquired)) return;
        for (const {name, buf} of acquired) {
            this._bufferPool.release(name, buf);
        }
    }
    
    getStats(name) {
        if (name) {
            const pool = this.pools.get(name);
            return pool ? { dimension: pool.dim, inUse: pool.inUse.size, free: pool.free.length, total: pool.inUse.size + pool.free.length, stats: { ...pool.stats } } : null;
        }
        const result = {};
        for (const [poolName, pool] of this.pools) {
            result[poolName] = { dimension: pool.dim, inUse: pool.inUse.size, free: pool.free.length, total: pool.inUse.size + pool.free.length, stats: { ...pool.stats } };
        }
        return result;
    }
    
    preallocate(name, count) {
        const pool = this.pools.get(name);
        if (!pool) throw new Error(`Unknown buffer pool: ${name}`);
        for (let i = 0; i < count; i++) { pool.free.push(new Float32Array(pool.dim)); pool.stats.created++; }
    }
}

// ============================================================================
// SEEDED RNG ‚Äî Deterministic random number generation with crypto fallback
// ============================================================================
class SeededRNG {
    constructor(seed, cryptoMode = false) {
        this._baseSeed = String(seed || 'default');
        this._cryptoMode = cryptoMode && typeof crypto !== 'undefined' && crypto.subtle;
        this._state = null;
        this._initPromise = null;
        this._stepCounter = 0;
        if (this._cryptoMode) {
            this._initPromise = this._deriveCryptoSeed();
        } else {            this._state = this._hashString(this._baseSeed);
        }
    }
    
    async ready() {
        if (this._initPromise) await this._initPromise;
    }
    
    async _deriveCryptoSeed() {
        try {
            const enc = new TextEncoder();
            const salt = enc.encode('cortex2b_arena_v5.0.1');
            const keyMaterial = await crypto.subtle.importKey(
                'raw', enc.encode(this._baseSeed), 'PBKDF2', false, ['deriveBits']
            );
            const derivedBits = await crypto.subtle.deriveBits(
                { name: 'PBKDF2', salt, iterations: 10000, hash: 'SHA-256' },
                keyMaterial, 256
            );
            const arr = new Uint32Array(derivedBits);
            this._state = arr[0] ^ arr[1] ^ arr[2] ^ arr[3] ^ arr[4] ^ arr[5] ^ arr[6] ^ arr[7];
        } catch (e) {
            console.warn('[SeededRNG] Crypto mode failed, falling back:', e);
            this._cryptoMode = false;
            this._state = this._hashString(this._baseSeed);
        }
    }
    
    _hashString(str) {
        let h = str.split('').reduce((a, c, i) => {
            return ((a * 31 + c.charCodeAt(0)) ^ (i * 17 + 7919)) % 2147483647;
        }, str.length) || 12345;
        return (h * 0x2545F4914F6CDD1D) >>> 0;
    }
    
    next() {
        if (this._state === null) {
            throw new Error('SeededRNG not initialized. Call ready() first if cryptoMode=true');
        }
        let x = this._state;
        x ^= x << 13;
        x ^= x >>> 17;
        x ^= x << 5;
        this._state = x >>> 0;
        return (this._state * 0x2545F4914F6CDD1D) >>> 0 / 4294967296;
    }
    
    gaussian(mean = 0, std = 1) {
        const u1 = this.next();
        const u2 = this.next();        return Math.sqrt(-2 * Math.log(Math.max(u1, 1e-10))) * Math.cos(2 * Math.PI * u2) * std + mean;
    }
    
    int(min, max) {
        return Math.floor(this.next() * (max - min + 1)) + min;
    }
    
    choice(arr) {
        return arr?.length ? arr[this.int(0, arr.length - 1)] : undefined;
    }
    
    shuffle(arr) {
        const result = [...arr];
        for (let i = result.length - 1; i > 0; i--) {
            const j = this.int(0, i);
            [result[i], result[j]] = [result[j], result[i]];
        }
        return result;
    }
    
    getSeed() {
        return this._baseSeed;
    }
    
    getSimTime() {
        return this._stepCounter++;
    }
    
    reset() {
        this._state = this._cryptoMode ? null : this._hashString(this._baseSeed);
        this._stepCounter = 0;
    }
    
    // ‚úÖ Key-derived structural factor generator for personality diversity
    getStructuralFactors() {
        const keyHash = this._baseSeed.split('').reduce((h, c) => 
            ((h * 31 + c.charCodeAt(0)) ^ (h >>> 7)) >>> 0, 0x9e3779b9);
        
        return {
            W_P_scale: 0.25 + (keyHash % 100) / 1000,
            W_A_scale: 0.28 + ((keyHash >>> 8) % 100) / 1000,
            W_C_scale: 0.22 + ((keyHash >>> 16) % 100) / 1000,
            W_D_scale: 0.18 + ((keyHash >>> 24) % 100) / 1000,
            bias_offset: ((keyHash >>> 4) % 200 - 100) / 5000,
            perturbation_seed: keyHash
        };
    }
}

// ============================================================================// ADAPTER ‚Äî Generic input/output mapping for task-agnostic cortex
// ============================================================================
class Adapter {
    constructor() {
        if (this.constructor === Adapter) {
            throw new Error('Adapter is abstract');
        }
    }
    
    encode(externalInput) {
        throw new Error('encode() must be implemented');
    }
    
    decode(cortexOutput) {
        throw new Error('decode() must be implemented');
    }
    
    validate(cortexDims) {
        return true;
    }
    
    reconfigure(newConfig) {
        return this;
    }
    
    getMetadata() {
        return { type: this.constructor.name, timestamp: Date.now() };
    }
}

class GenericAdapter extends Adapter {
    constructor(config = {}) {
        super();
        this.inputMap = config.inputMap || new Map();
        this.outputMap = config.outputMap || new Map();
        this.taskSpec = config.taskSpec || null;
        this._validateMappings();
    }
    
    _validateMappings() {
        for (const [extName, mapping] of this.inputMap) {
            if (!Number.isInteger(mapping.index) || mapping.index < 0 || mapping.index >= 64) {
                throw new Error(`Invalid input mapping for "${extName}": index ${mapping.index}`);
            }
            if (!mapping.norm || typeof mapping.norm.min !== 'number') {
                throw new Error(`Invalid norm for input "${extName}"`);
            }
        }
        for (const [cortexIdx, mapping] of this.outputMap) {
            if (!Number.isInteger(cortexIdx) || cortexIdx < 0 || cortexIdx >= 16) {                throw new Error(`Invalid output mapping: index ${cortexIdx}`);
            }
            if (!mapping.norm || typeof mapping.norm.min !== 'number') {
                throw new Error(`Invalid norm for output ${cortexIdx}`);
            }
        }
    }
    
    encode(externalInput) {
        const output = new Float32Array(64);
        if (Array.isArray(externalInput) || externalInput instanceof Float32Array) {
            const len = Math.min(externalInput.length, 64);
            for (let i = 0; i < len; i++) {
                output[i] = this._clamp(Number(externalInput[i]) || 0, -1, 1);
            }
            return output;
        }
        for (const [extName, { index, norm }] of this.inputMap) {
            const raw = externalInput[extName];
            if (raw === undefined) continue;
            output[index] = this._normalize(raw, norm);
        }
        return output;
    }
    
    decode(cortexOutput) {
        const output = {};
        for (const [cortexIdx, { name, norm }] of this.outputMap) {
            if (cortexIdx < cortexOutput.length) {
                output[name] = this._denormalize(cortexOutput[cortexIdx], norm);
            }
        }
        return output;
    }
    
    _normalize(value, { min, max, type }) {
        const v = Number(value);
        if (!isFinite(v)) return 0;
        switch (type) {
            case 'boolean': return v ? 1 : -1;
            case 'categorical':
            case 'onehot': return this._clamp(v, -1, 1);
            case 'discrete': return ((v - min) / (max - min)) * 2 - 1;
            default: return this._clamp(((v - min) / (max - min)) * 2 - 1, -1, 1);
        }
    }
    
    _denormalize(value, { min, max, type }) {
        const v = this._clamp(Number(value) || 0, -1, 1);
        switch (type) {            case 'boolean': return v > 0;
            case 'categorical':
            case 'onehot': return Math.round(v);
            case 'discrete': return Math.round(((v + 1) / 2) * (max - min) + min);
            default: return ((v + 1) / 2) * (max - min) + min;
        }
    }
    
    reconfigure(newConfig) {
        if (newConfig.inputMap) this.inputMap = newConfig.inputMap;
        if (newConfig.outputMap) this.outputMap = newConfig.outputMap;
        if (newConfig.taskSpec) this.taskSpec = newConfig.taskSpec;
        this._validateMappings();
        return this;
    }
    
    getMetadata() {
        return {
            ...super.getMetadata(),
            inputMappings: this.inputMap.size,
            outputMappings: this.outputMap.size,
            taskSpec: this.taskSpec ? { ...this.taskSpec } : null
        };
    }
    
    _clamp(v, min, max) {
        return Math.max(min, Math.min(max, v));
    }
}

// ============================================================================
// CONNECTOR ‚Äî Sync integration for direct function-call game loop
// ============================================================================
class Connector {
    constructor() {
        if (this.constructor === Connector) {
            throw new Error('Connector is abstract');
        }
        this._handlers = new Map();
        this._connected = false;
    }
    
    async connect() {
        throw new Error('connect() must be implemented');
    }
    
    disconnect() {
        throw new Error('disconnect() must be implemented');
    }
        sendOutput(output) {
        throw new Error('sendOutput() must be implemented');
    }
    
    on(event, handler) {
        if (!this._handlers.has(event)) {
            this._handlers.set(event, []);
        }
        const handlers = this._handlers.get(event);
        handlers.push(handler);
        return () => {
            const idx = handlers.indexOf(handler);
            if (idx >= 0) handlers.splice(idx, 1);
        };
    }
    
    _emit(event, payload) {
        const handlers = this._handlers.get(event);
        if (handlers) {
            for (const handler of handlers) {
                try {
                    handler(payload);
                } catch (e) {
                    console.error(`[Connector] Error in ${event} handler:`, e);
                }
            }
        }
    }
    
    isConnected() {
        return this._connected;
    }
    
    getMetadata() {
        return { type: this.constructor.name, connected: this._connected, timestamp: Date.now() };
    }
}

class SyncConnector extends Connector {
    constructor() {
        super();
        this._inputCallback = null;
        this._outputCallback = null;
    }
    
    async connect() {
        this._connected = true;
        this._emit('status', { status: 'connected', type: 'sync' });
        return true;
    }    
    disconnect() {
        this._connected = false;
        this._inputCallback = null;
        this._outputCallback = null;
        this._emit('status', { status: 'disconnected' });
    }
    
    sendOutput(output) {
        if (this._outputCallback) {
            this._outputCallback(output);
        }
        this._emit('output', output);
    }
    
    setInputHandler(callback) {
        this._inputCallback = callback;
    }
    
    setOutputHandler(callback) {
        this._outputCallback = callback;
    }
    
    injectInput(input) {
        if (this._inputCallback) {
            this._inputCallback(input);
        }
        this._emit('input', input);
    }
    
    getMetadata() {
        return {
            ...super.getMetadata(),
            hasInputHandler: !!this._inputCallback,
            hasOutputHandler: !!this._outputCallback
        };
    }
}

// ============================================================================
// CORTEX2BRAIN v2.2.1 ‚Äî Universal Neural Architecture with Real Integration
// ============================================================================
class Cortex2Brain {
    constructor(config = {}) {
        this.DIM = Object.freeze({
            DIM_P: CONFIG.CORTEX.DIM_P,
            DIM_A: CONFIG.CORTEX.DIM_A,
            DIM_M: CONFIG.CORTEX.DIM_M,
            DIM_C: CONFIG.CORTEX.DIM_C,
            DIM_S: CONFIG.CORTEX.DIM_S,            DIM_D: CONFIG.CORTEX.DIM_D,
            DIM_SENSOR: CONFIG.CORTEX.DIM_SENSOR,
            NUM_HEADS: CONFIG.CORTEX.NUM_HEADS,
            HEAD_DIM: CONFIG.CORTEX.HEAD_DIM,
            M_WORK_START: CONFIG.CORTEX.M_WORK_START,
            M_WORK_END: CONFIG.CORTEX.M_WORK_END,
            M_PERM_START: CONFIG.CORTEX.M_PERM_START,
            M_PERM_END: CONFIG.CORTEX.M_PERM_END,
            M_PRED_START: CONFIG.CORTEX.M_PRED_START,
            M_PRED_END: CONFIG.CORTEX.M_PRED_END
        });
        
        this.config = {
            seed: config.seed || `cortex_${Date.now().toString(36)}_${Math.random().toString(36).slice(2, 8)}`,
            lr: this._clamp(config.lr ?? CONFIG.CORTEX.DEFAULT_LR, 0.001, 0.1),
            gamma: this._clamp(config.gamma ?? CONFIG.CORTEX.DEFAULT_GAMMA, 0.9, 0.999),
            lambda: this._clamp(config.lambda ?? CONFIG.CORTEX.DEFAULT_LAMBDA, 0.8, 0.99),
            hebbianRate: this._clamp(config.hebbianRate ?? CONFIG.CORTEX.DEFAULT_HEBBIAN, 0.001, 0.01),
            cryptoMode: !!config.cryptoMode,
            useBufferPool: !!config.useBufferPool,
            strictValidation: !!config.strictValidation,
            taskSpec: config.taskSpec || null,
            ...config
        };
        
        this.RATIOS = this._calculateRatios(this.config.taskSpec);
        this._rng = new SeededRNG(this.config.seed, this.config.cryptoMode);
        this._rngReady = !this.config.cryptoMode;
        this._bufferPool = null;
        if (this.config.useBufferPool) this._initBufferPool();
        
        this._initPromise = this.config.cryptoMode
            ? this._rng.ready().then(() => this._initialize())
            : Promise.resolve().then(() => this._initialize());
    }
    
    async ready() {
        await this._initPromise;
        return this;
    }
    
    _initialize() {
        this._initializeWeights();
        this._initializeStateVectors();
        this._initEligibilityTraces();
        this.predictionErrors = new Float32Array(this.DIM.DIM_SENSOR);
        this._stats = {
            tdErrorHistory: [],
            predictionErrorHistory: [],
            totalSteps: 0,            avgReward: 0,
            validationErrors: 0,
            bufferPoolStats: null
        };
        this.emotions = this._initializeEmotions();
        this.emotionConfig = {
            fear: { baseDuration: 180, intensityMultiplier: 2.0, satisfactionDecay: 0.02 },
            aggression: { baseDuration: 120, intensityMultiplier: 1.5, satisfactionDecay: 0.03 },
            frustration: { baseDuration: 240, intensityMultiplier: 2.5, satisfactionDecay: 0.01 },
            desperation: { baseDuration: 300, intensityMultiplier: 3.0, satisfactionDecay: 0.005 },
            confidence: { baseDuration: 150, intensityMultiplier: 1.2, satisfactionDecay: 0.04 },
            vengeance: { baseDuration: 360, intensityMultiplier: 3.5, satisfactionDecay: 0.003 }
        };
        this.emotionalState = { current: null, history: [], satisfaction: 0, momentum: {} };
        this.emotionDecay = 0.98;
        this.emotionInfluence = 0.35;
        this.personality = {
            traits: { bravery: 0.5, loyalty: 0.5, empathy: 0.5, curiosity: 0.5, patience: 0.5, aggression: 0.5 },
            values: { survival: 0.8, victory: 0.7, fairness: 0.4, loyalty: 0.6 }
        };
        this.step = 0;
        this.cumulativeReward = 0;
        this._lastInputs = null;
        this._lastOutputs = null;
        this._isReady = true;
        this._traceBuffer = null;
        this._traceBufferMax = 10;
        return this;
    }
    
    _initBufferPool() {
        const P_IN = this.DIM.DIM_SENSOR + this.DIM.DIM_C + this.DIM.DIM_S + 48;
        const A_IN = this.DIM.DIM_P + 48 + 64 + this.DIM.DIM_D;
        const MW_IN = this.DIM.DIM_P + this.DIM.DIM_A + 64;
        const MP_IN = this.DIM.DIM_C + 48;
        const MPD_IN = this.DIM.DIM_A + 64 + 48 + this.DIM.DIM_D;
        const C_IN = this.DIM.DIM_P + this.DIM.DIM_A + this.DIM.DIM_M + this.DIM.DIM_S + this.DIM.DIM_D + 1;
        const S_IN = this.DIM.DIM_P + 48 + 32 + this.DIM.DIM_D;
        const D_IN = this.DIM.DIM_C + this.DIM.DIM_S + 48;
        
        this._bufferPool = new BufferPool({
            pInput: P_IN, aInput: A_IN, mwInput: MW_IN, mpInput: MP_IN, mpdInput: MPD_IN,
            cInput: C_IN, sInput: S_IN, dInput: D_IN,
            pOut: this.DIM.DIM_P, aOut: this.DIM.DIM_A, mOut: this.DIM.DIM_M,
            cOut: this.DIM.DIM_C, sOut: this.DIM.DIM_S, dOut: this.DIM.DIM_D
        });
        
        for (const name of ['pInput', 'aInput', 'cInput', 'dInput']) {
            this._bufferPool.preallocate(name, 2);
        }    }
    
    get lr() { return this.config.lr; }
    set lr(v) { this.config.lr = this._clamp(v, 0.001, 0.1); }
    
    get gamma() { return this.config.gamma; }
    set gamma(v) { this.config.gamma = this._clamp(v, 0.9, 0.999); }
    
    get lambda() { return this.config.lambda; }
    set lambda(v) { this.config.lambda = this._clamp(v, 0.8, 0.99); }
    
    get hebbianRate() { return this.config.hebbianRate; }
    set hebbianRate(v) { this.config.hebbianRate = this._clamp(v, 0.001, 0.01); }
    
    _calculateRatios(taskSpec) {
        const defaults = { perception: 0.5, head: 0.25, memoryBlock: 0.75, cortex: 4.0, state: 0.5 };
        if (!taskSpec) return defaults;
        const { inputComplexity = 0.5, temporalDepth = 0.5, socialComplexity = 0.5 } = taskSpec;
        return {
            perception: this._clamp(0.3 + inputComplexity * 0.4, 0.3, 0.9),
            head: this._clamp(0.15 + temporalDepth * 0.2, 0.15, 0.4),
            memoryBlock: this._clamp(0.5 + socialComplexity * 0.5, 0.5, 1.0),
            cortex: this._clamp(2.0 + (inputComplexity + temporalDepth + socialComplexity) * 0.7, 2.0, 6.0),
            state: this._clamp(0.3 + socialComplexity * 0.4, 0.3, 0.8)
        };
    }
    
    validateAndNormalizeInputs(inputs) {
        let arr;
        if (inputs instanceof Float32Array) {
            arr = inputs;
        } else if (Array.isArray(inputs)) {
            arr = new Float32Array(inputs.map(v => this._safeNumber(v, 0)));
        } else {
            throw new Error(`Inputs must be Float32Array or number[], got ${typeof inputs}`);
        }
        
        if (this.config.strictValidation) {
            for (let i = 0; i < arr.length; i++) {
                if (!isFinite(arr[i])) {
                    this._stats.validationErrors++;
                    throw new Error(`Non-finite value at index ${i}: ${arr[i]}`);
                }
            }
        } else {
            for (let i = 0; i < arr.length; i++) {
                if (!isFinite(arr[i])) {
                    this._stats.validationErrors++;
                    arr[i] = 0;
                } else {                    arr[i] = this._clamp(arr[i], -1, 1);
                }
            }
        }
        return this._projectToCortexSensors(arr);
    }
    
    validateAndClampOutputs(outputs) {
        if (!outputs?.length) return [];
        const len = Math.min(outputs.length, this.DIM.DIM_D);
        const result = [];
        for (let i = 0; i < len; i++) {
            result.push(this._clamp(this._safeNumber(outputs[i], 0), -1, 1));
        }
        return result;
    }
    
    // ‚úÖ forward() with BufferPool try-finally safety
    forward(inputs, reward = 0, context = null) {
        if (!this._isReady) {
            throw new Error('Cortex2Brain not initialized. Call ready() first.');
        }
        
        const trace = this._traceBuffer ? { start: performance?.now?.() || Date.now(), layers: {} } : null;
        const x_t = this.validateAndNormalizeInputs(inputs);
        const r_t = this._safeNumber(reward, 0);
        this._lastInputs = Array.from(x_t);
        this.cumulativeReward = this._lerp(this.cumulativeReward, r_t, 0.1);
        
        const PERM_SIZE = this.DIM.M_PERM_END - this.DIM.M_PERM_START;
        const acquired = [];
        const acquire = (name) => {
            if (!this._bufferPool) return new Float32Array(this._bufferPool?.pools?.get(name)?.dim || 0);
            const buf = this._bufferPool.acquire(name);
            acquired.push({ name, buf });
            return buf;
        };
        
        try {
            const P_input = acquire('pInput');
            const A_inputs = [];
            for (let h = 0; h < this.DIM.NUM_HEADS; h++) {
                A_inputs.push(acquire('aInput'));
            }
            const M_work_input = acquire('mwInput');
            const M_perm_input = acquire('mpInput');
            const M_pred_input = acquire('mpdInput');
            const C_input = acquire('cInput');
            const S_input = acquire('sInput');
            const D_input = acquire('dInput');            
            // Build inputs
            const P_input_built = this._buildPInput(x_t, this.C_prev, this.S_prev, this._getMPerm(this.M_prev), this.RATIOS.perception, P_input);
            for (let h = 0; h < this.DIM.NUM_HEADS; h++) {
                this._buildAInput(this.P_prev, this._getMWork(this.M_prev), this.C_prev, this.D_prev, h, this.RATIOS.head, A_inputs[h]);
            }
            this._buildMWorkInput(this.P_prev, this.A_prev, this.C_prev, this.RATIOS.memoryBlock, M_work_input);
            this._buildMPermInput(this.C_prev, this._getMPerm(this.M_prev), this.RATIOS.memoryBlock, M_perm_input);
            this._buildMPredInput(this.A_prev, this.C_prev, this._getMWork(this.M_prev), this.D_prev, this.RATIOS.memoryBlock, M_pred_input);
            this._buildCInput(this.P_prev, this.A_prev, this.M_prev, this.S_prev, this.D_prev, r_t, this.RATIOS.cortex, C_input);
            this._buildSInput(this.P_prev, this._getMPerm(this.M_prev), this.C_prev, this.D_prev, this.RATIOS.state, S_input);
            this._buildDInput(this.C_prev, this.S_prev, this._getMPred(this.M_prev), D_input);
            
            if (trace) trace.layers.inputBuild = performance?.now?.() || Date.now();
            
            // Forward pass through layers
            const P_new = this._matrixMultiply(P_input_built, this.W_P, 'relu');
            for (let i = 0; i < this.DIM.DIM_P; i++) P_new[i] = this._leakyRelu(P_new[i] + this.b_P[i]);
            
            const A_new = new Float32Array(this.DIM.DIM_A);
            const gateProbs = this._softmax(this.W_gate, 1.0);
            for (let h = 0; h < this.DIM.NUM_HEADS; h++) {
                const headOut = this._matrixMultiply(A_inputs[h], this.W_A[h], 'relu');
                const gateWeight = gateProbs[h];
                for (let i = 0; i < this.DIM.HEAD_DIM; i++) {
                    A_new[h * this.DIM.HEAD_DIM + i] = this._leakyRelu(headOut[i] + this.b_A[h][i]) * gateWeight;
                }
            }
            
            const M_work_new = this._matrixMultiply(M_work_input, this.W_M_work, 'relu');
            for (let i = 0; i < PERM_SIZE; i++) M_work_new[i] = this._leakyRelu(M_work_new[i] + this.b_M_work[i]);
            
            const M_perm_new = this._matrixMultiply(M_perm_input, this.W_M_perm, 'relu');
            for (let i = 0; i < PERM_SIZE; i++) M_perm_new[i] = this._leakyRelu(M_perm_new[i] + this.b_M_perm[i]);
            
            const M_pred_new = this._matrixMultiply(M_pred_input, this.W_M_pred, 'relu');
            for (let i = 0; i < PERM_SIZE; i++) M_pred_new[i] = this._leakyRelu(M_pred_new[i] + this.b_M_pred[i]);
            
            const M_new = new Float32Array(this.DIM.DIM_M);
            for (let i = 0; i < PERM_SIZE; i++) {
                M_new[i] = M_work_new[i];
                M_new[PERM_SIZE + i] = M_perm_new[i];
                M_new[PERM_SIZE * 2 + i] = M_pred_new[i];
            }
            
            const C_new = this._matrixMultiply(C_input, this.W_C, 'relu');
            for (let i = 0; i < this.DIM.DIM_C; i++) C_new[i] = this._leakyRelu(C_new[i] + this.b_C[i]);
            
            const S_new = this._matrixMultiply(S_input, this.W_S, 'relu');
            for (let i = 0; i < this.DIM.DIM_S; i++) S_new[i] = this._leakyRelu(S_new[i] + this.b_S[i]);            
            const D_new = this._matrixMultiply(D_input, this.W_D, 'tanh');
            for (let i = 0; i < this.DIM.DIM_D; i++) D_new[i] = this._tanh(D_new[i] + this.b_D[i]);
            
            if (trace) trace.layers.forward = performance?.now?.() || Date.now();
            
            // Update state vectors
            this.P_prev.set(this.P); this.A_prev.set(this.A); this.M_prev.set(this.M);
            this.C_prev.set(this.C); this.S_prev.set(this.S); this.D_prev.set(this.D);
            this.P.set(P_new); this.A.set(A_new); this.M.set(M_new);
            this.C.set(C_new); this.S.set(S_new); this.D.set(D_new);
            
            this._updatePrediction(M_pred_new, x_t);
            this._updateEmotions(r_t, x_t, context);
            
            if (trace) trace.layers.emotions = performance?.now?.() || Date.now();
            
            const output = this.validateAndClampOutputs(this.D);
            this._lastOutputs = output;
            
            if (trace) {
                trace.end = performance?.now?.() || Date.now();
                trace.duration = trace.end - trace.start;
                if (!this._traceBuffer) this._traceBuffer = [];
                if (this._traceBuffer.length >= this._traceBufferMax) this._traceBuffer.shift();
                this._traceBuffer.push(trace);
            }
            
            return {
                output,
                cortex: Array.from(this.C),
                predictionError: this._computeAvgPredError(),
                reflexTriggered: this.S.some(v => v > 0.9),
                emotions: { ...this.emotions },
                emotionalState: this.emotionalState.current ? { ...this.emotionalState.current } : null,
                personality: { ...this.personality },
                stats: { ...this._stats },
                trace: trace ? { ...trace } : null
            };
        } finally {
            // ‚úÖ Always release buffers, even on exception
            if (this._bufferPool) {
                for (const { name, buf } of acquired) {
                    this._bufferPool.release(name, buf);
                }
                if (this._stats) {
                    this._stats.bufferPoolStats = this._bufferPool.getStats();
                }
            }
        }    }
    
    // Build input helpers (modified to accept pre-allocated buffer)
    _buildPInput(x_t, C_prev, S_prev, M_perm_prev, ratio, output) {
        const PERM_SIZE = this.DIM.M_PERM_END - this.DIM.M_PERM_START;
        let idx = 0;
        for (let i = 0; i < this.DIM.DIM_SENSOR; i++) output[idx++] = x_t[i] * ratio;
        for (let i = 0; i < this.DIM.DIM_C; i++) output[idx++] = C_prev[i];
        for (let i = 0; i < this.DIM.DIM_S; i++) output[idx++] = S_prev[i];
        for (let i = 0; i < PERM_SIZE; i++) output[idx++] = M_perm_prev[i];
        return output;
    }
    
    _buildAInput(P_t, M_work, C_prev, D_prev, headIdx, ratio, output) {
        let idx = 0;
        for (let i = 0; i < this.DIM.DIM_P; i++) output[idx++] = P_t[i] * ratio;
        for (let i = 0; i < 48; i++) output[idx++] = M_work[i];
        const cStart = headIdx * 64;
        for (let i = 0; i < 64; i++) {
            const cIdx = cStart + i;
            output[idx++] = (cIdx < this.DIM.DIM_C) ? C_prev[cIdx] : 0;
        }
        for (let i = 0; i < this.DIM.DIM_D; i++) output[idx++] = D_prev[i];
        return output;
    }
    
    _buildMWorkInput(P_t, A_t, C_prev, ratio, output) {
        let idx = 0;
        for (let i = 0; i < this.DIM.DIM_P; i++) output[idx++] = P_t[i] * ratio;
        for (let i = 0; i < this.DIM.DIM_A; i++) output[idx++] = A_t[i] * ratio;
        for (let i = 0; i < 64; i++) output[idx++] = (i < this.DIM.DIM_C) ? C_prev[i] : 0;
        return output;
    }
    
    _buildMPermInput(C_prev, M_perm_prev, ratio, output) {
        const PERM_SIZE = this.DIM.M_PERM_END - this.DIM.M_PERM_START;
        let idx = 0;
        for (let i = 0; i < this.DIM.DIM_C; i++) output[idx++] = C_prev[i] * ratio;
        for (let i = 0; i < PERM_SIZE; i++) output[idx++] = M_perm_prev[i];
        return output;
    }
    
    _buildMPredInput(A_t, C_prev, M_work, D_prev, ratio, output) {
        let idx = 0;
        for (let i = 0; i < this.DIM.DIM_A; i++) output[idx++] = A_t[i] * ratio;
        for (let i = 0; i < 64; i++) {
            const cIdx = 192 + i;
            output[idx++] = (cIdx < this.DIM.DIM_C) ? C_prev[cIdx] : 0;
        }
        for (let i = 0; i < 48; i++) output[idx++] = M_work[i];        for (let i = 0; i < this.DIM.DIM_D; i++) output[idx++] = D_prev[i];
        return output;
    }
    
    _buildCInput(P_t, A_t, M_t, S_prev, D_prev, r_t, ratio, output) {
        let idx = 0;
        for (let i = 0; i < this.DIM.DIM_P; i++) output[idx++] = P_t[i] * ratio;
        for (let i = 0; i < this.DIM.DIM_A; i++) output[idx++] = A_t[i] * ratio;
        for (let i = 0; i < this.DIM.DIM_M; i++) output[idx++] = M_t[i] * ratio;
        for (let i = 0; i < this.DIM.DIM_S; i++) output[idx++] = S_prev[i];
        for (let i = 0; i < this.DIM.DIM_D; i++) output[idx++] = D_prev[i];
        output[idx] = r_t;
        return output;
    }
    
    _buildSInput(P_t, M_perm, C_prev, D_prev, ratio, output) {
        let idx = 0;
        for (let i = 0; i < this.DIM.DIM_P; i++) output[idx++] = P_t[i] * ratio;
        for (let i = 0; i < 48; i++) output[idx++] = M_perm[i];
        for (let i = 0; i < 32; i++) {
            const cIdx = 224 + i;
            output[idx++] = (cIdx < this.DIM.DIM_C) ? C_prev[cIdx] : 0;
        }
        for (let i = 0; i < this.DIM.DIM_D; i++) output[idx++] = D_prev[i] * ratio;
        return output;
    }
    
    _buildDInput(C_t, S_t, M_pred, output) {
        let idx = 0;
        for (let i = 0; i < this.DIM.DIM_C; i++) output[idx++] = C_t[i];
        for (let i = 0; i < this.DIM.DIM_S; i++) output[idx++] = S_t[i];
        for (let i = 0; i < 48; i++) output[idx++] = M_pred[i];
        return output;
    }
    
    learn(experience) {
        const { observation, action, reward, nextObservation, done } = experience;
        const inputs = observation instanceof Float32Array
            ? observation
            : this.validateAndNormalizeInputs(observation);
        const currentValue = this._estimateValue();
        const nextValue = done ? 0 : (nextObservation ? this._estimateValue() : currentValue);
        return this.tdLearn(inputs, action, reward, currentValue, nextValue);
    }
    
    tdLearn(inputs, outputs, reward, value, nextValue) {
        const currentValue = this._safeNumber(value, this._estimateValue());
        const nextVal = this._safeNumber(nextValue, this._estimateValue());
        const tdErr = this._tdError(reward, currentValue, nextVal, this.gamma);
                this._stats.tdErrorHistory.push(Math.abs(tdErr));
        if (this._stats.tdErrorHistory.length > 100) {
            this._stats.tdErrorHistory.shift();
        }
        
        this._updateValueHead(tdErr);
        this._updateEligibilityTraces(inputs, outputs, tdErr);
        this._applyTDError(tdErr, 'td');
        
        if (Math.abs(reward) > 1) {
            const correlation = Math.sign(reward) * this._clamp(Math.abs(reward) / 5, 0, 1);
            this._hebbianUpdate(this.P_prev, this.A_prev, correlation, 'P‚ÜíA');
            this._hebbianUpdate(this.A_prev, this.C_prev, correlation, 'A‚ÜíC');
            this._hebbianUpdate(this.C_prev, this.D_prev, correlation, 'C‚ÜíD');
        }
        
        this._stats.totalSteps++;
        this._stats.avgReward = this._lerp(this._stats.avgReward, reward, 0.01);
        
        return {
            tdError: tdErr,
            avgTDError: this._stats.tdErrorHistory.reduce((a,b) => a+b, 0) / Math.max(1, this._stats.tdErrorHistory.length),
            avgPredictionError: this._computeAvgPredError()
        };
    }
    
    resetEpisode() {
        this.emotions = this._initializeEmotions();
        this.emotionalState.current = null;
        this.P.fill(0); this.A.fill(0); this.M.fill(0);
        this.C.fill(0); this.S.fill(0); this.D.fill(0);
        this.P_prev.fill(0); this.A_prev.fill(0); this.M_prev.fill(0);
        this.C_prev.fill(0); this.S_prev.fill(0); this.D_prev.fill(0);
        this.predictionErrors.fill(0);
        this.cumulativeReward = 0;
        this.step = 0;
    }
    
    reset() {
        this.resetEpisode();
        this._stats = {
            tdErrorHistory: [],
            predictionErrorHistory: [],
            totalSteps: 0,
            avgReward: 0,
            validationErrors: 0,
            bufferPoolStats: null
        };
    }
        setTracing(enable, maxTraces = 10) {
        this._traceBuffer = enable ? [] : null;
        this._traceBufferMax = maxTraces;
    }
    
    getDebugInfo() {
        return {
            emotions: { ...this.emotions },
            personality: { ...this.personality },
            stats: { ...this._stats },
            predictionError: this._computeAvgPredError(),
            ratios: { ...this.RATIOS },
            bufferPool: this._bufferPool?.getStats?.() || null,
            ready: this._isReady
        };
    }
    
    toJSON(options = {}) {
        const { includeWeights = true, includeState = false } = options;
        const data = {
            type: 'Cortex2Brain',
            version: '2.2.1',
            config: {
                seed: this.config.seed,
                lr: this.config.lr,
                gamma: this.config.gamma,
                lambda: this.config.lambda,
                hebbianRate: this.config.hebbianRate,
                cryptoMode: this.config.cryptoMode,
                taskSpec: this.config.taskSpec,
                dims: { ...this.DIM }
            },
            personality: { ...this.personality },
            stats: { ...this._stats }
        };
        
        if (includeWeights) {
            data.weights = {
                W_P: this.W_P.map(r => Array.from(r)),
                b_P: Array.from(this.b_P),
                W_A: this.W_A.map(m => m.map(r => Array.from(r))),
                b_A: this.b_A.map(b => Array.from(b)),
                W_gate: Array.from(this.W_gate),
                W_M_work: this.W_M_work.map(r => Array.from(r)),
                b_M_work: Array.from(this.b_M_work),
                W_M_perm: this.W_M_perm.map(r => Array.from(r)),
                b_M_perm: Array.from(this.b_M_perm),
                W_M_pred: this.W_M_pred.map(r => Array.from(r)),
                b_M_pred: Array.from(this.b_M_pred),
                W_C: this.W_C.map(r => Array.from(r)),                b_C: Array.from(this.b_C),
                W_S: this.W_S.map(r => Array.from(r)),
                b_S: Array.from(this.b_S),
                W_D: this.W_D.map(r => Array.from(r)),
                b_D: Array.from(this.b_D),
                W_pred: this.W_pred.map(r => Array.from(r)),
                b_pred: Array.from(this.b_pred),
                W_V: Array.from(this.W_V),
                b_V: this.b_V
            };
        }
        
        if (includeState) {
            data.state = {
                P: Array.from(this.P),
                A: Array.from(this.A),
                M: Array.from(this.M),
                C: Array.from(this.C),
                S: Array.from(this.S),
                D: Array.from(this.D),
                predictionErrors: Array.from(this.predictionErrors),
                emotions: { ...this.emotions },
                step: this.step,
                cumulativeReward: this.cumulativeReward
            };
        }
        
        return data;
    }
    
    static fromJSON(data) {
        if (!data || data.type !== 'Cortex2Brain') {
            throw new Error('Invalid Cortex2Brain JSON');
        }
        const brain = new Cortex2Brain(data.config);
        return brain;
    }
    
    // ‚úÖ Key-derived weight initialization with structural factors
    _initializeWeights() {
        const factors = this._rng.getStructuralFactors();
        
        const _init = (rows, cols, baseScale, structKey) => {
            const scale = baseScale * (factors[structKey] || 1);
            const mat = [];
            for (let i = 0; i < rows; i++) {
                const row = new Float32Array(cols);
                for (let j = 0; j < cols; j++) {
                    const perturbation = Math.sin(factors.perturbation_seed * (i + 1) * (j + 2) * 0.001) * 0.15;
                    row[j] = ((this._rng.next() * 2 - 1) * scale) + perturbation + factors.bias_offset;                }
                mat.push(row);
            }
            return mat;
        };
        
        const _vec = (len, baseScale) => {
            const v = new Float32Array(len);
            for (let i = 0; i < len; i++) {
                v[i] = ((this._rng.next() * 2 - 1) * baseScale) + factors.bias_offset * (i % 3);
            }
            return v;
        };
        
        const P_IN = this.DIM.DIM_SENSOR + this.DIM.DIM_C + this.DIM.DIM_S + 48;
        this.W_P = _init(P_IN, this.DIM.DIM_P, 0.3, 'W_P_scale');
        this.b_P = _vec(this.DIM.DIM_P, 0.1);
        
        this.W_A = [];
        this.b_A = [];
        for (let h = 0; h < this.DIM.NUM_HEADS; h++) {
            this.W_A.push(_init(160, this.DIM.HEAD_DIM, 0.3, 'W_A_scale'));
            this.b_A.push(_vec(this.DIM.HEAD_DIM, 0.1));
        }
        
        this.W_gate = _vec(this.DIM.NUM_HEADS, 0.25);
        this.W_M_work = _init(160, 48, 0.3, 'W_C_scale');
        this.b_M_work = _vec(48, 0.1);
        this.W_M_perm = _init(304, 48, 0.3, 'W_C_scale');
        this.b_M_perm = _vec(48, 0.1);
        this.W_M_pred = _init(192, 48, 0.3, 'W_C_scale');
        this.b_M_pred = _vec(48, 0.1);
        this.W_C = _init(289, this.DIM.DIM_C, 0.25, 'W_C_scale');
        this.b_C = _vec(this.DIM.DIM_C, 0.1);
        this.W_S = _init(128, this.DIM.DIM_S, 0.3, 'W_C_scale');
        this.b_S = _vec(this.DIM.DIM_S, 0.1);
        this.W_D = _init(336, this.DIM.DIM_D, 0.2, 'W_D_scale');
        this.b_D = _vec(this.DIM.DIM_D, 0.1);
        this.W_pred = _init(48, this.DIM.DIM_SENSOR, 0.15, 'W_D_scale');
        this.b_pred = _vec(this.DIM.DIM_SENSOR, 0.05);
        this.W_V = _vec(this.DIM.DIM_C, 0.1);
        this.b_V = 0;
    }
    
    _initializeStateVectors() {
        this.P = new Float32Array(this.DIM.DIM_P);
        this.A = new Float32Array(this.DIM.DIM_A);
        this.M = new Float32Array(this.DIM.DIM_M);
        this.C = new Float32Array(this.DIM.DIM_C);
        this.S = new Float32Array(this.DIM.DIM_S);        this.D = new Float32Array(this.DIM.DIM_D);
        this.P_prev = new Float32Array(this.DIM.DIM_P);
        this.A_prev = new Float32Array(this.DIM.DIM_A);
        this.M_prev = new Float32Array(this.DIM.DIM_M);
        this.C_prev = new Float32Array(this.DIM.DIM_C);
        this.S_prev = new Float32Array(this.DIM.DIM_S);
        this.D_prev = new Float32Array(this.DIM.DIM_D);
    }
    
    _initEligibilityTraces() {
        const P_IN = this.DIM.DIM_SENSOR + this.DIM.DIM_C + this.DIM.DIM_S + 48;
        this.trace_P = new Float32Array(P_IN * this.DIM.DIM_P);
        this.trace_C = new Float32Array(289 * this.DIM.DIM_C);
        this.trace_D = new Float32Array(336 * this.DIM.DIM_D);
    }
    
    _initializeEmotions() {
        return {
            threat: 0, frustration: 0, confidence: 0, aggression: 0, fear: 0,
            surprise: 0, caution: 0, desperation: 0, vengeance: 0, empathy: 0,
            loyalty: 0, shame: 0, pride: 0, curiosity: 0, boredom: 0
        };
    }
    
    _projectToCortexSensors(raw) {
        const out = new Float32Array(this.DIM.DIM_SENSOR);
        const len = Math.min(raw.length, this.DIM.DIM_SENSOR);
        for (let i = 0; i < len; i++) {
            out[i] = this._clamp(this._safeNumber(raw[i], 0), -1, 1);
        }
        return out;
    }
    
    _getMWork(M) { return M.slice(this.DIM.M_WORK_START, this.DIM.M_WORK_END); }
    _getMPerm(M) { return M.slice(this.DIM.M_PERM_START, this.DIM.M_PERM_END); }
    _getMPred(M) { return M.slice(this.DIM.M_PRED_START, this.DIM.M_PRED_END); }
    
    _updatePrediction(M_pred, x_t) {
        const x_pred = this._linearMultiply(M_pred, this.W_pred);
        for (let i = 0; i < this.DIM.DIM_SENSOR; i++) {
            x_pred[i] += this.b_pred[i];
        }
        for (let i = 0; i < this.DIM.DIM_SENSOR; i++) {
            const err = Math.abs(x_pred[i] - x_t[i]);
            this.predictionErrors[i] = this._lerp(this.predictionErrors[i], err, 0.1);
        }
    }
    
    _linearMultiply(vec, mat) {
        const out = new Float32Array(mat[0].length);        for (let i = 0; i < mat[0].length; i++) {
            for (let j = 0; j < vec.length; j++) {
                out[i] += this._safeNumber(vec[j], 0) * this._safeNumber(mat[j]?.[i], 0);
            }
        }
        return out;
    }
    
    _matrixMultiply(vec, mat, activation = 'tanh') {
        if (!vec?.length || !mat?.length || !mat[0]?.length) {
            return new Float32Array(0);
        }
        const out = new Float32Array(mat[0].length);
        for (let i = 0; i < mat[0].length; i++) {
            let sum = 0;
            // Loop unrolling for performance (step 4)
            for (let j = 0; j < vec.length; j += 4) {
                sum += (vec[j]||0)*(mat[j]?.[i]||0) +
                       (vec[j+1]||0)*(mat[j+1]?.[i]||0) +
                       (vec[j+2]||0)*(mat[j+2]?.[i]||0) +
                       (vec[j+3]||0)*(mat[j+3]?.[i]||0);
            }
            out[i] = activation === 'tanh' ? this._tanh(sum) : this._leakyRelu(sum);
        }
        return out;
    }
    
    _computeAvgPredError() {
        let sum = 0;
        for (let i = 0; i < this.DIM.DIM_SENSOR; i++) {
            sum += this.predictionErrors[i];
        }
        return sum / this.DIM.DIM_SENSOR;
    }
    
    _estimateValue() {
        let sum = this.b_V;
        for (let i = 0; i < this.DIM.DIM_C; i++) {
            sum += this.C[i] * this.W_V[i];
        }
        return this._tanh(sum);
    }
    
    _updateValueHead(tdErr) {
        const alpha = this.config.lr * 0.5;
        for (let i = 0; i < this.DIM.DIM_C; i++) {
            this.W_V[i] += alpha * tdErr * this.C[i];
            this.W_V[i] = this._clamp(this.W_V[i], -CONFIG.CORTEX.VALUE_CLIP, CONFIG.CORTEX.VALUE_CLIP);
        }
        this.b_V += alpha * tdErr;    }
    
    _updateEligibilityTraces(inputs, outputs, tdErr) {
        const decay = this.config.gamma * this.config.lambda;
        for (let i = 0; i < this.trace_P.length; i++) {
            this.trace_P[i] = decay * this.trace_P[i];
            this.trace_P[i] = this._clamp(this.trace_P[i], -10, 10);
        }
    }
    
    // ‚úÖ TD error applied only to configured cortex range for stability
    _applyTDError(tdErr) {
        const alpha = this.config.lr * Math.sign(tdErr) * 0.1;
        const { start, end } = CONFIG.CORTEX.TD_UPDATE_RANGE;
        
        for (let i = start; i < end && i < this.DIM.DIM_C; i++) {
            for (let j = 0; j < 289 && j < this.W_C.length; j++) {
                if (this.W_C[j]?.[i] !== undefined) {
                    const delta = this._clamp(
                        alpha * 0.01 * this.trace_C[j * this.DIM.DIM_C + i],
                        -CONFIG.CORTEX.MAX_GRAD,
                        CONFIG.CORTEX.MAX_GRAD
                    );
                    this.W_C[j][i] += delta;
                    this.W_C[j][i] = this._clamp(this.W_C[j][i], -CONFIG.CORTEX.VALUE_CLIP, CONFIG.CORTEX.VALUE_CLIP);
                }
            }
        }
    }
    
    // ‚úÖ Hebbian update for all attention heads, not just head 0
    _hebbianUpdate(pre, post, correlation, label) {
        if (!pre?.length || !post?.length) return;
        const eta = this.config.hebbianRate * correlation * 0.5;
        const step = Math.max(1, Math.floor(pre.length / 50));
        
        for (let i = 0; i < post.length; i += step) {
            for (let j = 0; j < pre.length; j += step) {
                // Update all attention heads for balanced learning
                for (let h = 0; h < this.DIM.NUM_HEADS; h++) {
                    if (this.W_A?.[h]?.[j]?.[i] !== undefined) {
                        this.W_A[h][j][i] += eta * pre[j] * post[i] / this.DIM.NUM_HEADS;
                        this.W_A[h][j][i] = this._clamp(this.W_A[h][j][i], -CONFIG.CORTEX.VALUE_CLIP, CONFIG.CORTEX.VALUE_CLIP);
                    }
                }
            }
        }
    }
    
    _tdError(reward, value, nextValue, gamma) {        return this._safeNumber(reward, 0) + gamma * this._safeNumber(nextValue, 0) - this._safeNumber(value, 0);
    }
    
    _updateEmotions(r_t, x_t, context) {
        this.step++;
        if (r_t < 0) {
            this.emotions.frustration = Math.min(1, this.emotions.frustration + 0.03);
        } else {
            this.emotions.frustration *= 0.92;
        }
        if (r_t > 1) {
            this.emotions.confidence = Math.min(1, this.emotions.confidence + 0.05);
        } else {
            this.emotions.confidence *= 0.95;
        }
        for (const key of Object.keys(this.emotions)) {
            this.emotions[key] *= this.emotionDecay;
        }
    }
    
    _clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }
    _lerp(a, b, t) { return a + (b - a) * this._clamp(t, 0, 1); }
    _safeNumber(val, fallback = 0) { return (typeof val === 'number' && isFinite(val)) ? val : fallback; }
    _tanh(x) { if (x > 20) return 1; if (x < -20) return -1; const e = Math.exp(2*x); return (e-1)/(e+1); }
    _leakyRelu(x, Œ± = 0.01) { return x > 0 ? x : Œ± * x; }
    
    _softmax(arr, temp = 1) {
        if (!arr?.length) return [];
        const max = Math.max(...arr);
        const exps = arr.map(v => Math.exp(Math.min((v - max) / temp, 700)));
        const sum = exps.reduce((s,x) => s+x, 0) || 1e-10;
        return exps.map(e => e / sum);
    }
    
    getEmotions() { return { ...this.emotions }; }
    getPersonality() { return { ...this.personality }; }
    getStats() { return { ...this._stats }; }
    getInputDim() { return this.DIM.DIM_SENSOR; }
    getOutputDim() { return this.DIM.DIM_D; }
    isReady() { return this._isReady; }
    getDimensions() { return { ...this.DIM }; }
}

// ============================================================================
// BEHAVIOR ARBITER v1.0 ‚Äî Real 5-mode selection with emotion modulation
// ============================================================================
class BehaviorArbiter {
    constructor(config) {
        this.config = config || {};
        this.modes = CONFIG.BEHAVIOR.MODES;        this.currentMode = 'combat';
        this.modeConfidence = new Float32Array(this.modes.length).fill(1 / this.modes.length);
        this.modeHistory = [];
        this.maxHistory = 20;
        this._lastModeSwitchStep = 0;
        this._minSwitchInterval = 15; // Prevent rapid mode oscillation
    }
    
    // ‚úÖ Select mode based on cortex outputs + emotions + context
    selectMode(cortexOutput, emotions, context) {
        const step = context?.step || 0;
        
        // 1. Decode mode logits from cortex outputs [9-13]
        const modeLogits = cortexOutput.slice(9, 14).map(v => v || 0);
        
        // 2. Emotion modulation factors (key integration point!)
        const emotionModulators = {
            hunt: emotions.confidence * 0.3 + (emotions.curiosity || 0) * 0.2,
            flee: emotions.fear * 0.5 + (1 - emotions.confidence) * 0.3,
            explore: (emotions.curiosity || 0) * 0.4 + (emotions.boredom || 0) * 0.3,
            combat: emotions.aggression * 0.4 + emotions.vengeance * 0.3,
            avoid: emotions.caution * 0.5 + emotions.frustration * 0.2
        };
        
        // 3. Context bonuses
        const contextBonus = this._getContextBonus(context);
        
        // 4. Combine: logits + emotions + context
        const scores = this.modes.map((mode, i) => {
            const logitScore = modeLogits[i] || 0;
            const emotionScore = emotionModulators[mode] || 0;
            const ctxScore = contextBonus[mode] || 0;
            return logitScore * CONFIG.BEHAVIOR.LOGIT_WEIGHT +
                   emotionScore * CONFIG.BEHAVIOR.EMOTION_WEIGHT +
                   ctxScore * CONFIG.BEHAVIOR.CONTEXT_WEIGHT;
        });
        
        // 5. Softmax with temperature for probabilistic selection
        const probs = this._softmax(scores, this.config?.policyTemperature || CONFIG.BEHAVIOR.DEFAULT_TEMP);
        
        // 6. Hysteresis: don't switch too frequently
        const currentIdx = this.modes.indexOf(this.currentMode);
        const timeSinceSwitch = step - this._lastModeSwitchStep;
        
        if (timeSinceSwitch < this._minSwitchInterval) {
            // Stay in current mode with boosted probability
            probs[currentIdx] = Math.max(probs[currentIdx], CONFIG.BEHAVIOR.MODE_SWITCH_HYSTERESIS);
        } else if (probs[currentIdx] > CONFIG.BEHAVIOR.MODE_SWITCH_HYSTERESIS && Math.random() > CONFIG.BEHAVIOR.MODE_SWITCH_PROB) {
            // High confidence: stay with high probability
            return {                mode: this.currentMode,
                confidence: probs[currentIdx],
                probs: [...probs],
                switched: false
            };
        }
        
        // 7. Select new mode (probabilistic)
        const newIdx = this._sampleFromProbs(probs);
        const newMode = this.modes[newIdx];
        
        if (newMode !== this.currentMode) {
            this._lastModeSwitchStep = step;
            this.modeHistory.push({ mode: newMode, step, confidence: probs[newIdx] });
            if (this.modeHistory.length > this.maxHistory) {
                this.modeHistory.shift();
            }
        }
        
        this.currentMode = newMode;
        this.modeConfidence = new Float32Array(probs);
        
        return {
            mode: this.currentMode,
            confidence: probs[newIdx],
            probs: [...probs],
            switched: newMode !== this.currentMode
        };
    }
    
    _getContextBonus(ctx) {
        const { healthRatio, enemyDistance, hasAllyNearby, isCornered, enemyCount } = ctx || {};
        const bonuses = {};
        
        bonuses.flee = 0;
        if (healthRatio !== undefined && healthRatio < 0.3) bonuses.flee += 0.5;
        if (isCornered) bonuses.flee += 0.3;
        
        bonuses.combat = 0;
        if (enemyDistance !== undefined && enemyDistance < 60 && (healthRatio === undefined || healthRatio > 0.4)) {
            bonuses.combat += 0.4;
        }
        if (enemyCount !== undefined && enemyCount === 1) bonuses.combat += 0.2;
        
        bonuses.avoid = 0;
        if (enemyDistance !== undefined && enemyDistance < 40 && (healthRatio === undefined || healthRatio < 0.5)) {
            bonuses.avoid += 0.3;
        }
        
        bonuses.hunt = 0;        if (enemyDistance !== undefined && enemyDistance < 100 && (healthRatio === undefined || healthRatio > 0.6)) {
            bonuses.hunt += 0.3;
        }
        
        bonuses.explore = 0;
        if (enemyDistance !== undefined && enemyDistance > 150 && !hasAllyNearby) {
            bonuses.explore += 0.2;
        }
        
        return bonuses;
    }
    
    _softmax(arr, temp = 1) {
        const max = Math.max(...arr);
        const exps = arr.map(v => Math.exp(Math.min((v - max) / temp, 700)));
        const sum = exps.reduce((a, b) => a + b, 1e-10);
        return exps.map(e => e / sum);
    }
    
    _sampleFromProbs(probs) {
        const r = Math.random();
        let cum = 0;
        for (let i = 0; i < probs.length; i++) {
            cum += probs[i];
            if (r < cum) return i;
        }
        return probs.length - 1;
    }
    
    getModeVector() {
        const vec = new Float32Array(this.modes.length).fill(0);
        const idx = this.modes.indexOf(this.currentMode);
        if (idx >= 0) vec[idx] = 1;
        return vec;
    }
    
    getModeOneHot() {
        return this.getModeVector();
    }
    
    getHistory() {
        return [...this.modeHistory];
    }
    
    reset() {
        this.currentMode = 'combat';
        this.modeConfidence = new Float32Array(this.modes.length).fill(1 / this.modes.length);
        this.modeHistory = [];
        this._lastModeSwitchStep = 0;
    }}

// ============================================================================
// UTILITIES ‚Äî Deterministic, safe, validated, documented
// ============================================================================
const Utils = Object.freeze({
    clamp: (v, min, max) => Math.max(min, Math.min(max, v)),
    lerp: (a, b, t) => a + (b - a) * Utils.clamp(t, 0, 1),
    dist: (a, b) => Math.hypot((a?.x ?? 0) - (b?.x ?? 0), (a?.y ?? 0) - (b?.y ?? 0)),
    normalize: (x, y) => {
        const l = Math.hypot(x, y);
        return l > 1e-10 ? { x: x / l, y: y / l } : { x: 0, y: 0 };
    },
    tanh: (x) => {
        if (!isFinite(x)) return 0;
        if (x > 20) return 1;
        if (x < -20) return -1;
        const e = Math.exp(2 * x);
        return (e - 1) / (e + 1);
    },
    sigmoid: (x) => {
        if (!isFinite(x)) return 0.5;
        if (x > 20) return 1;
        if (x < -20) return 0;
        return 1 / (1 + Math.exp(-x));
    },
    leakyRelu: (x, Œ± = 0.01) => x > 0 ? x : Œ± * x,
    argmax: (arr) => {
        if (!arr || arr.length === 0) return -1;
        let mi = 0;
        for (let i = 1; i < arr.length; i++) {
            if (arr[i] > arr[mi]) mi = i;
        }
        return mi;
    },
    safeNumber: (val, fallback = 0) => (typeof val === 'number' && isFinite(val)) ? val : fallback,
    softmax: (arr, temp = 1) => {
        if (!arr || !Array.isArray(arr) || arr.length === 0) return [];
        const max = Math.max(...arr);
        const exps = arr.map(v => {
            const scaled = (v - max) / temp;
            return scaled > 700 ? 0 : Math.exp(Math.min(scaled, 700));
        });
        const sum = exps.reduce((s, x) => s + x, 0) || 1e-10;
        return exps.map(e => e / sum);
    },
    logSoftmax: (arr, temp = 1) => {
        if (!arr || !Array.isArray(arr) || arr.length === 0) return [];
        const max = Math.max(...arr);
        const logSumExp = max + Math.log(arr.reduce((s, x) => {            const scaled = (x - max) / temp;
            return s + (scaled > 700 ? 0 : Math.exp(Math.min(scaled, 700)));
        }, 0) + 1e-10);
        return arr.map(v => ((v - max) / temp - logSumExp));
    },
    policyGradientLoss: (logProbs, advantages) => {
        if (!logProbs?.length || !advantages?.length) return 0;
        const len = Math.min(logProbs.length, advantages.length);
        if (len === 0) return 0;
        let sum = 0;
        for (let i = 0; i < len; i++) {
            const lp = Utils.safeNumber(logProbs[i], 0);
            const adv = Utils.safeNumber(advantages[i], 0);
            sum += lp * adv;
        }
        return -sum / len;
    },
    entropyBonus: (probs) => {
        if (!probs?.length) return 0;
        let sum = 0;
        for (const p of probs) {
            const safeP = Math.max(Utils.safeNumber(p, 0), 1e-10);
            sum += safeP * Math.log(safeP);
        }
        return -sum;
    },
    moeLoadBalanceLoss: (gateProbs, expertUsage) => {
        if (!gateProbs?.length) return 0;
        const numExperts = gateProbs.length;
        const targetUsage = 1 / numExperts;
        let sum = 0;
        for (let i = 0; i < numExperts; i++) {
            const usage = Utils.safeNumber(expertUsage?.[i], 0);
            sum += Math.pow(usage - targetUsage, 2);
        }
        return sum / numExperts;
    },
    computeGAE: (rewards, values, nextValue, gamma = 0.99, lambda = 0.95) => {
        const advantages = new Array(rewards.length);
        let advantage = 0;
        for (let t = rewards.length - 1; t >= 0; t--) {
            const nextVal = (t === rewards.length - 1) ? nextValue : values[t + 1];
            const delta = Utils.safeNumber(rewards[t], 0) + gamma * Utils.safeNumber(nextVal, 0) - Utils.safeNumber(values[t], 0);
            advantage = delta + gamma * lambda * advantage;
            advantages[t] = advantage;
        }
        return advantages;
    },
    tdError: (reward, value, nextValue, gamma = 0.99) =>
        Utils.safeNumber(reward, 0) + gamma * Utils.safeNumber(nextValue, 0) - Utils.safeNumber(value, 0),    _pointSegDist: (ax, ay, bx, by, cx, cy) => {
        const vx = bx - ax, vy = by - ay;
        const wx = cx - ax, wy = cy - ay;
        const c1 = vx * wx + vy * wy;
        if (c1 <= 0) return Math.hypot(cx - ax, cy - ay);
        const c2 = vx * vx + vy * vy;
        if (c2 <= c1) return Math.hypot(cx - bx, cy - by);
        const b = c1 / c2;
        const pbx = ax + b * vx, pby = ay + b * vy;
        return Math.hypot(cx - pbx, cy - pby);
    },
    hasLineOfSight: (a, b, walls, wallRadius = 14) => {
        if (!a || !b) return false;
        if (!walls?.length) return true;
        for (const w of walls) {
            if (!w) continue;
            const d = Utils._pointSegDist(a.x, a.y, b.x, b.y, w.x, w.y);
            if (d < wallRadius + 2) return false;
        }
        return true;
    },
    projectInput: (rawInputs, embeddingWeights, bias, outputDim) => {
        const projected = new Array(outputDim).fill(0);
        for (let o = 0; o < outputDim; o++) {
            let sum = Utils.safeNumber(bias?.[o], 0);
            for (let i = 0; i < rawInputs.length; i++) {
                const w = embeddingWeights?.[i]?.[o];
                sum += Utils.safeNumber(rawInputs[i], 0) * Utils.safeNumber(w, 0);
            }
            projected[o] = Utils.leakyRelu(sum);
        }
        return projected;
    },
    hashSeed: (seed, i, j) => {
        if (!seed) seed = 'default';
        let h = String(seed).split('').reduce((a, c, idx) => {
            return ((a * 31 + c.charCodeAt(0)) ^ (idx * 17 + i * 7919 + j * 104729)) % 2147483647;
        }, String(seed).length) || 12345;
        h = (h * 2654435761) >>> 0;
        return h / 4294967296;
    },
    deepClone: (obj) => {
        if (obj === null || typeof obj !== 'object') return obj;
        if (obj instanceof Float32Array) return new Float32Array(obj);
        if (Array.isArray(obj)) return obj.map(Utils.deepClone);
        const clone = {};
        for (const key of Object.keys(obj)) {
            clone[key] = Utils.deepClone(obj[key]);
        }
        return clone;    },
    validateAttention: (scores) => {
        if (!scores?.length || !scores[0]?.length) return { valid: false, error: 'empty' };
        const n = scores.length, m = scores[0].length;
        let rowSumValid = true;
        for (let i = 0; i < n; i++) {
            const sum = scores[i].reduce((s, v) => s + v, 0);
            if (Math.abs(sum - 1) > 0.01) { rowSumValid = false; break; }
        }
        let hasInvalid = false;
        for (let i = 0; i < n && !hasInvalid; i++) {
            for (let j = 0; j < m; j++) {
                if (!isFinite(scores[i][j])) { hasInvalid = true; break; }
            }
        }
        return { valid: rowSumValid && !hasInvalid, shape: [n, m], rowSumValid, hasInvalid };
    },
    computeLoadBalance: (usage) => {
        if (!usage?.length) return 1;
        const mean = usage.reduce((s, v) => s + v, 0) / usage.length;
        if (mean < 1e-10) return 1;
        const variance = usage.reduce((s, v) => s + Math.pow(v - mean, 2), 0) / usage.length;
        return Math.sqrt(variance) / mean;
    },
    normalizeAngle: (angle) => {
        angle = angle % (Math.PI * 2);
        return angle > Math.PI ? angle - Math.PI * 2 : angle < -Math.PI ? angle + Math.PI * 2 : angle;
    },
    rand: (rng, min, max) => {
        if (!rng) return Math.random() * (max - min) + min;
        const hash = Utils.hashSeed(rng.getSeed(), Math.floor(min * 1000), Math.floor(max * 1000));
        return min + hash * (max - min);
    },
    randInt: (rng, min, max) => {
        if (!rng) return Math.floor(Math.random() * (max - min + 1)) + min;
        const hash = Utils.hashSeed(rng.getSeed(), Math.floor(min * 1000), Math.floor(max * 1000));
        return Math.floor(min + hash * (max - min + 1));
    },
    getTeamMembers: (agent, world) => {
        if (!agent?.teamId || !world?.enemies) return [];
        return world.enemies.filter(e => e && e.id !== agent.id && e.alive && e.teamId === agent.teamId);
    },
    getEnemies: (agent, world) => {
        if (!world?.enemies) return [];
        return world.enemies.filter(e => {
            if (!e || e.id === agent.id || !e.alive) return false;
            if (agent.teamId === null && e.teamId === null) return true;
            return e.teamId !== agent.teamId;
        });
    },    getTeamAliveCount: (teamId, world) => {
        if (!teamId || !world?.enemies) return 0;
        return world.enemies.filter(e => e && e.alive && e.teamId === teamId).length;
    },
    getAllTeams: (world) => {
        if (!world?.enemies) return [];
        return [...new Set(world.enemies.filter(e => e?.teamId).map(e => e.teamId))];
    },
    checkTeamWin: (world) => {
        if (!world?.enemies || !world.episodeInProgress) return null;
        const mode = world.config?.GAME?.currentMode || '1v1';
        const aliveAgents = world.enemies.filter(e => e && e.alive);
        if (aliveAgents.length === 0) return null;
        
        if (mode === '2v2') {
            const teams = Utils.getAllTeams(world);
            const aliveTeams = teams.filter(teamId => Utils.getTeamAliveCount(teamId, world) > 0);
            if (aliveTeams.length === 1) return { winner: aliveTeams[0], type: 'teamElimination' };
        }
        if (mode === '4way') {
            if (aliveAgents.length === 1) return { winner: aliveAgents[0].teamId, type: 'lastStanding' };
        }
        if (mode === '1v1') {
            if (aliveAgents.length === 1) return { winner: aliveAgents[0].teamId || aliveAgents[0].id, type: 'lastStanding' };
        }
        return null;
    },
    validateArrayShape: (arr, expectedRows, expectedCols, label) => {
        if (!Array.isArray(arr)) {
            console.warn(`${label}: Expected array, got ${typeof arr}`);
            return false;
        }
        if (expectedRows !== undefined && arr.length !== expectedRows) {
            console.warn(`${label}: Row count mismatch: ${arr.length} vs ${expectedRows}`);
            return false;
        }
        if (expectedCols !== undefined && arr.length > 0 && Array.isArray(arr[0])) {
            if (arr[0].length !== expectedCols) {
                console.warn(`${label}: Col count mismatch: ${arr[0].length} vs ${expectedCols}`);
                return false;
            }
        }
        return true;
    }
});

// ============================================================================
// LOGGER ‚Äî Safe, escaped, accessible output
// ============================================================================
const Logger = Object.freeze({    _escape: (str) => String(str).replace(/[&<>"']/g, m => ({
        '&': '&', '<': '<', '>': '>', '"': '"', "'": '&#039;'
    }[m])),
    _truncate: (str, max = 180) => str.length > max ? str.slice(0, max) + '‚Ä¶' : str,
    log: (msg, type = 'info') => {
        const safeMsg = Logger._escape(Logger._truncate(msg));
        const safeType = ['info', 'success', 'warn', 'error', 'learning'].includes(type) ? type : 'info';
        const logEl = document.getElementById('eventLog');
        if (!logEl) {
            console.log(`[${safeType}] ${safeMsg}`);
            return;
        }
        const entry = document.createElement('div');
        entry.className = `log-entry ${safeType}`;
        entry.textContent = `[${new Date().toLocaleTimeString()}] ${safeMsg}`;
        entry.setAttribute('role', 'log');
        logEl.insertBefore(entry, logEl.firstChild);
        while (logEl.children.length > 60) logEl.removeChild(logEl.lastChild);
        logEl.scrollTop = 0;
    }
});

// ============================================================================
// WEAPONS CONFIGURATION ‚Äî Immutable, frozen, documented
// ============================================================================
const WEAPONS = Object.freeze({
    hammer:   { name: 'Hammer', icon: 'üî®', damage: 1.0, speed: 1.0, range: 45, type: 'melee', knockback: 8.0, knockbackType: 'impact', color: '#ffaa00', stunTime: 5, arcAngle: Math.PI * 0.9, mountOffset: { x: 18, y: 0 }, recoil: { x: -2, y: 0 } },
    drill:    { name: 'Drill', icon: 'üî©', damage: 0.6, speed: 1.8, range: 40, type: 'melee', knockback: 2.0, knockbackType: 'vibrate', color: '#ff66cc', stunTime: 2, arcAngle: Math.PI * 0.6, mountOffset: { x: 16, y: 0 }, recoil: { x: -1, y: 0 } },
    sword:    { name: 'Sword', icon: '‚öîÔ∏è', damage: 1.4, speed: 0.7, range: 50, type: 'melee', knockback: 12.0, knockbackType: 'slash', color: '#00d4ff', stunTime: 8, arcAngle: Math.PI * 1.2, mountOffset: { x: 20, y: 0 }, recoil: { x: -3, y: 0 } },
    blaster:  { name: 'Blaster', icon: 'üî´', damage: 0.5, speed: 1.2, range: 200, type: 'ranged', knockback: 4.0, knockbackType: 'pulse', color: '#ffdd44', stunTime: 3, arcAngle: Math.PI * 0.4, mountOffset: { x: 14, y: 0 }, recoil: { x: -4, y: 0 } },
    axe:      { name: 'Axe', icon: 'ü™ì', damage: 1.8, speed: 0.5, range: 45, type: 'melee', knockback: 20.0, knockbackType: 'heavy', color: '#ff4444', stunTime: 15, arcAngle: Math.PI * 0.7, mountOffset: { x: 19, y: 0 }, recoil: { x: -5, y: 0 } },
    dagger:   { name: 'Dagger', icon: 'üó°Ô∏è', damage: 0.4, speed: 2.5, range: 35, type: 'melee', knockback: 1.0, knockbackType: 'quick', color: '#aa88ff', stunTime: 1, arcAngle: Math.PI * 1.0, mountOffset: { x: 12, y: 0 }, recoil: { x: -0.5, y: 0 } },
    spear:    { name: 'Spear', icon: 'üî±', damage: 1.1, speed: 0.9, range: 65, type: 'melee', knockback: 10.0, knockbackType: 'thrust', color: '#00ff9d', stunTime: 6, arcAngle: Math.PI * 0.5, mountOffset: { x: 22, y: 0 }, recoil: { x: -2, y: 0 } },
    chainsaw: { name: 'Chainsaw', icon: '‚öôÔ∏è', damage: 0.8, speed: 1.5, range: 42, type: 'melee', knockback: 3.0, knockbackType: 'continuous', color: '#ff8800', stunTime: 4, arcAngle: Math.PI * 1.1, mountOffset: { x: 17, y: 0 }, recoil: { x: -1, y: 0 } }
});

// ============================================================================
// AGENT v5.0.1 ‚Äî CORTEX2BRAIN Fully Integrated with BehaviorArbiter
// ============================================================================
class Agent {
    static get VISUAL_RADIUS() { return 22; }
    static get COLLISION_RADIUS() { return 20; }
    static get ATTACK_RANGE() { return 45; }

    constructor(id, x, y, color, seed, weaponType = 'hammer', teamId = null, config = null) {
        this.config = config || window.arenaConfig;
        this.id = id;
        this.x = x;
        this.y = y;
        this.color = color;        this.vx = 0;
        this.vy = 0;
        
        this.stats = { maxHealth: 100, damage: 3, fireRate: 15, dodgeChance: 0.0 };
        this.health = this.stats.maxHealth;
        this.lastMutationType = null;
        
        this.seed = seed || `AGENT_${id}_${this.config?._rng?.getSeed() || 'default'}`;
        this.numExperts = this.config?.ARCH?.NUM_EXPERTS || 4;
        this.teamId = teamId;
        this.allies = [];
        this._coordinationScore = 0;
        this._lastAllyAssist = 0;
        this._teamWinBonus = 0;
        
        this.weaponType = weaponType;
        this.weapon = WEAPONS[weaponType] || WEAPONS.hammer;
        this._applyWeaponStats();

        // ‚úÖ CORTEX2BRAIN INTEGRATION
        this.cortex = new Cortex2Brain({
            seed: this.seed + '_CORTEX',
            lr: this.config?.learningRate || CONFIG.CORTEX.DEFAULT_LR,
            gamma: this.config?.gamma || CONFIG.CORTEX.DEFAULT_GAMMA,
            lambda: this.config?.lambda || CONFIG.CORTEX.DEFAULT_LAMBDA,
            hebbianRate: CONFIG.CORTEX.DEFAULT_HEBBIAN,
            cryptoMode: false,
            useBufferPool: true,
            strictValidation: false,
            taskSpec: { inputComplexity: 0.7, temporalDepth: 0.6, socialComplexity: this.teamId ? 0.8 : 0.3 }
        });

        // ‚úÖ ADAPTER: Game-specific input/output mapping
        this.adapter = new GenericAdapter({
            inputMap: this._buildInputMap(),
            outputMap: this._buildOutputMap(),
            taskSpec: { inputComplexity: 0.7, temporalDepth: 0.6, socialComplexity: this.teamId ? 0.8 : 0.3 }
        });

        // ‚úÖ CONNECTOR: Sync integration for game loop
        this.connector = new SyncConnector();
        this.connector.setOutputHandler((output) => { this._applyCortexOutput(output); });

        // ‚úÖ BEHAVIOR ARBITER: Real 5-mode selection with emotion modulation
        this.arbiter = new BehaviorArbiter({
            policyTemperature: this.config?.policyTemperature || CONFIG.BEHAVIOR.DEFAULT_TEMP
        });

        this.mode = 'combat';
        this.target = { x, y };        this.speed = 1;
        this.stuckCounter = 0;
        this.lastPos = { x, y };
        this.cumulativeReward = 5;
        this._smoothedReward = 0;
        this._lastHealth = this.health;
        this._lastHealthChange = 0;
        this.alive = true;
        
        this.skillEmbedding = [0.3, 0.4, 0.2, 0.5, 0.6];
        this.socialMemory = { interactions: new Map(), reputation: 0, lastAggressor: null, allies: [], killerHistory: [] };
        
        this.permanent = {
            skills: { hunting: 0.3, fleeing: 0.4, combat: 0.2, exploring: 0.5, avoiding: 0.6 },
            strategies: { huntPattern: 'direct', fleeDirection: 'away', combatStyle: 'direct' },
            preferences: { foodType: 'any', enemyType: 'any', territory: 'any' },
            muscleMemory: new Float32Array(16).fill(0),
            memory: {
                lastFoodPos: null,
                lastFoodStep: 0,
                visited: new Set(),
                unvisited: [],
                _maxVisited: this.config?.MEMORY?.maxVisitedCells || CONFIG.MEMORY.MAX_VISITED_CELLS
            }
        };
        
        this.predictive = {
            shortTerm: { positions: [], actions: [], results: [], enemyHistory: [], foodHistory: [] },
            patterns: { enemyMovement: null, foodSpawn: null, dangerZones: new Map() },
            predictions: { enemyPos: { x: 0, y: 0 }, foodPos: { x: 0, y: 0 }, collision: false, success: 0.5 },
            confidence: 0.5,
            predictionError: 0
        };
        
        this.enemyPredictor = new (class {
            constructor() { this.history = []; this.maxHistory = 50; }
            recordMove(action, distance, health, aggression) {
                this.history.push({ action: { ...action }, distance, health, aggression, time: Date.now() });
                if (this.history.length > this.maxHistory) this.history.shift();
            }
            predictNextAction() {
                if (this.history.length < 5) return 'unpredictable';
                const recent = this.history.slice(-5);
                const avgAgg = recent.reduce((s, m) => s + Utils.safeNumber(m.action?.aggression, 0.5), 0) / recent.length;
                if (Math.abs(avgAgg) > 0.7) return avgAgg > 0 ? 'aggressive' : 'fleeing';
                return 'unpredictable';
            }
        })();
        
        this.strategyMemory = new (class {            constructor() { this.winningStrategies = []; this.fightHistory = {}; this.maxStrategies = 20; }
            recordFight(opponentId, won, weights, tactics, accuracy) {
                if (!this.fightHistory[opponentId]) {
                    this.fightHistory[opponentId] = { wins: 0, losses: 0, lastTactics: null, bestAccuracy: 0 };
                }
                const hist = this.fightHistory[opponentId];
                if (won) {
                    hist.wins++;
                    hist.lastTactics = tactics;
                    hist.bestAccuracy = Math.max(hist.bestAccuracy, accuracy || 0);
                } else {
                    hist.losses++;
                }
            }
        })();
        
        this.currentTactic = 'aggressive';
        this.fightStartTime = 0;
        this.fightOpponent = null;
        this.attackCooldown = 0;
        this.attackRange = this.weapon.range;
        this.wins = 0;
        this.totalKills = 0;
        this.deaths = 0;
        this.mutations = 0;
        this.generation = 1;
        this.trail = [];
        this.lastDecision = null;
        this._lastWorld = null;
        
        // ‚úÖ Learning buffer with max size enforcement
        this.learningBuffer = {
            states: [], actions: [], rewards: [],
            nextStates: [], dones: [], values: [],
            maxBuffer: CONFIG.MEMORY.LEARNING_BUFFER_MAX
        };
        
        this.evolutionPoints = 0;
        this.statChoices = ['maxHealth', 'damage', 'dodgeChance', 'fireRate'];
        
        this._lastHitDealt = 0;
        this._lastHitReceived = 0;
        this._knockbackVelocity = { x: 0, y: 0 };
        this._stunTimer = 0;
        this._weaponEffectTimer = 0;
        this._forcedCombatTimer = 0;
        this._learnFromWinner = false;
        this._lastKiller = null;
        this._deathMode = null;
                this._totalDamageDealt = 0;
        this._totalAttacks = 0;
        this._successfulHits = 0;
        this._tacticalHits = 0;
        this._frontalHits = 0;
        this._lastAttackDir = null;
        this._recentArcExposure = [];
        this._inEnemyArc = false;
        this._lastThreatAssessment = null;
        
        this._sharedThreat = null;
        this._threatDirection = null;
        this.empathyStats = { total: 0, correct: 0, byEnemy: new Map() };
        this._lastPrediction = null;
        this._empathyTrust = 0.5;
        this._ignoreEmpathyFor = {};
        this._forcedExploration = 0;
        this._imaginationScore = 0;
        this._warnedAlly = false;
    }

    _buildInputMap() {
        const map = new Map();
        // Position/distance inputs (0-11)
        for (let i = 0; i < 3; i++) {
            map.set(`enemy${i}_dx`, { index: i*4, norm: { min: -1, max: 1, type: 'continuous' } });
            map.set(`enemy${i}_dy`, { index: i*4+1, norm: { min: -1, max: 1, type: 'continuous' } });
            map.set(`enemy${i}_dist`, { index: i*4+2, norm: { min: 0, max: 1, type: 'continuous' } });
            map.set(`enemy${i}_health`, { index: i*4+3, norm: { min: 0, max: 1, type: 'continuous' } });
        }
        // Wall inputs (12-14)
        map.set('wall_dx', { index: 12, norm: { min: -1, max: 1, type: 'continuous' } });
        map.set('wall_dy', { index: 13, norm: { min: -1, max: 1, type: 'continuous' } });
        map.set('wall_dist', { index: 14, norm: { min: 0, max: 1, type: 'continuous' } });
        // Self inputs (15-23)
        map.set('self_x', { index: 15, norm: { min: -1, max: 1, type: 'continuous' } });
        map.set('self_y', { index: 16, norm: { min: -1, max: 1, type: 'continuous' } });
        map.set('self_health', { index: 17, norm: { min: 0, max: 1, type: 'continuous' } });
        map.set('self_reward', { index: 18, norm: { min: -1, max: 1, type: 'continuous' } });
        map.set('self_damage', { index: 19, norm: { min: 0, max: 1, type: 'continuous' } });
        map.set('self_dodge', { index: 20, norm: { min: 0, max: 1, type: 'continuous' } });
        map.set('self_fireRate', { index: 21, norm: { min: 0, max: 1, type: 'continuous' } });
        map.set('step_normalized', { index: 22, norm: { min: 0, max: 1, type: 'continuous' } });
        // Weapon one-hot (24-31)
        Object.keys(WEAPONS).forEach((wt, i) => map.set(`weapon_${wt}`, { index: 24+i, norm: { min: 0, max: 1, type: 'onehot' } }));
        // Misc (32-35)
        map.set('death_count', { index: 32, norm: { min: 0, max: 1, type: 'continuous' } });
        map.set('forced_combat', { index: 33, norm: { min: 0, max: 1, type: 'boolean' } });
        map.set('ally_count', { index: 34, norm: { min: 0, max: 4, type: 'discrete' } });
        map.set('ally_health_avg', { index: 35, norm: { min: 0, max: 1, type: 'continuous' } });        // Tactical inputs (36-47)
        map.set('angle_to_enemy', { index: 36, norm: { min: -1, max: 1, type: 'continuous' } });
        map.set('enemy_sees_me', { index: 37, norm: { min: -1, max: 1, type: 'boolean' } });
        map.set('in_enemy_arc', { index: 38, norm: { min: 0, max: 1, type: 'boolean' } });
        map.set('enemy_in_my_arc', { index: 39, norm: { min: 0, max: 1, type: 'boolean' } });
        map.set('threat_level', { index: 40, norm: { min: 0, max: 1, type: 'continuous' } });
        map.set('flank_vector_x', { index: 41, norm: { min: -1, max: 1, type: 'continuous' } });
        map.set('flank_vector_y', { index: 42, norm: { min: -1, max: 1, type: 'continuous' } });
        map.set('angle_from_enemy', { index: 43, norm: { min: -1, max: 1, type: 'continuous' } });
        map.set('dist_to_arc_edge', { index: 44, norm: { min: -1, max: 1, type: 'continuous' } });
        map.set('self_damage_ratio', { index: 45, norm: { min: 0, max: 1, type: 'continuous' } });
        map.set('predicted_enemy_x', { index: 46, norm: { min: -1, max: 1, type: 'continuous' } });
        map.set('predicted_enemy_y', { index: 47, norm: { min: -1, max: 1, type: 'continuous' } });
        // Mode one-hot for cortex input (48-52)
        CONFIG.BEHAVIOR.MODES.forEach((mode, i) => {
            map.set(`mode_${mode}`, { index: 48+i, norm: { min: 0, max: 1, type: 'onehot' } });
        });
        // Remaining inputs padded with zeros (53-63)
        for (let i = 53; i < 64; i++) {
            map.set(`pad_${i}`, { index: i, norm: { min: 0, max: 0, type: 'continuous' } });
        }
        return map;
    }

    _buildOutputMap() {
        const map = new Map();
        // Movement (0-1)
        map.set(0, { name: 'move_x', norm: { min: -1, max: 1, type: 'continuous' } });
        map.set(1, { name: 'move_y', norm: { min: -1, max: 1, type: 'continuous' } });
        // Behaviors (2-8)
        map.set(2, { name: 'throttle', norm: { min: -1, max: 1, type: 'continuous' } });
        map.set(3, { name: 'curiosity', norm: { min: 0, max: 1, type: 'continuous' } });
        map.set(4, { name: 'aggression', norm: { min: 0, max: 1, type: 'continuous' } });
        map.set(5, { name: 'memory_weight', norm: { min: 0, max: 1, type: 'continuous' } });
        map.set(6, { name: 'steering', norm: { min: -1, max: 1, type: 'continuous' } });
        map.set(7, { name: 'circular_bias', norm: { min: -1, max: 1, type: 'continuous' } });
        map.set(8, { name: 'retreat_urgency', norm: { min: 0, max: 1, type: 'continuous' } });
        // Tactical/Mode control (9-13) ‚Äî DIRECTLY MODULATES BEHAVIOR ARBITER
        map.set(9, { name: 'flank_commit', norm: { min: 0, max: 1, type: 'continuous' } });
        map.set(10, { name: 'mode_hunt', norm: { min: -1, max: 1, type: 'continuous' } });
        map.set(11, { name: 'mode_flee', norm: { min: -1, max: 1, type: 'continuous' } });
        map.set(12, { name: 'mode_explore', norm: { min: -1, max: 1, type: 'continuous' } });
        map.set(13, { name: 'mode_avoid', norm: { min: -1, max: 1, type: 'continuous' } });
        // Remaining outputs (14-15)
        map.set(14, { name: 'output_14', norm: { min: -1, max: 1, type: 'continuous' } });
        map.set(15, { name: 'output_15', norm: { min: -1, max: 1, type: 'continuous' } });
        return map;
    }

    _applyWeaponStats() {        const w = this.weapon;
        this.stats.damage = Math.floor(3 * w.damage);
        this.stats.fireRate = Math.floor(15 / w.speed);
        this.attackRange = w.range;
    }
    
    setWeapon(weaponType) {
        if (WEAPONS[weaponType]) {
            this.weaponType = weaponType;
            this.weapon = WEAPONS[weaponType];
            this._applyWeaponStats();
            return true;
        }
        console.warn(`Invalid weapon: ${weaponType}`);
        this.weaponType = 'hammer';
        this.weapon = WEAPONS.hammer;
        this._applyWeaponStats();
        return false;
    }
    
    getWeaponFacing() {
        if (this.target && this.target.x !== undefined && isFinite(this.target.x)) {
            return Math.atan2(this.target.y - this.y, this.target.x - this.x);
        }
        const speed = Math.hypot(this.vx, this.vy);
        if (speed > 0.5) return Math.atan2(this.vy, this.vx);
        if (this._lastAttackDir !== null && isFinite(this._lastAttackDir)) return this._lastAttackDir;
        return 0;
    }
    
    isPointInWeaponArc(point, extraArc = 0) {
        if (!point || typeof point.x !== 'number' || !isFinite(point.x) || typeof point.y !== 'number' || !isFinite(point.y)) return false;
        const facing = this.getWeaponFacing();
        const toPoint = Math.atan2(point.y - this.y, point.x - this.x);
        let angleDiff = Utils.normalizeAngle(toPoint - facing);
        const effectiveArc = (this.weapon.arcAngle || Math.PI) + extraArc;
        return Math.abs(angleDiff) <= effectiveArc / 2;
    }
    
    calculateDirectionalDamageMultiplier(attacker) {
        if (!attacker) return 1.0;
        const toAttacker = Math.atan2(attacker.y - this.y, attacker.x - this.x);
        const myFacing = this.getWeaponFacing();
        let angleDiff = Utils.normalizeAngle(toAttacker - myFacing);
        const absAngle = Math.abs(angleDiff);
        const weaponArc = (this.weapon.arcAngle || Math.PI) / 2;
        
        if (absAngle <= weaponArc * 0.5) return CONFIG.TACTICAL.DAMAGE_FRONT || 0.6;
        else if (absAngle <= weaponArc) return CONFIG.TACTICAL.DAMAGE_FLANK || 1.0;
        else return CONFIG.TACTICAL.DAMAGE_BACK || 1.8;    }
    
    assessThreatFromEnemy(enemy) {
        if (!enemy?.alive) return { threatLevel: 0, safeApproachAngle: 0, flankVector: {x:0, y:0} };
        
        const inArc = enemy.isPointInWeaponArc(this, CONFIG.TACTICAL.THREAT_BUFFER_ANGLE || Math.PI * 0.1);
        const distance = Utils.dist(this, enemy);
        const inRange = distance <= (enemy.weapon.range || 50);
        
        let threatLevel = 0;
        if (inRange) {
            threatLevel = inArc ? 0.9 : 0.3;
        } else {
            threatLevel = inArc ? 0.4 : 0.1;
        }
        
        const enemyHealthRatio = enemy.health / enemy.stats.maxHealth;
        threatLevel *= Utils.lerp(0.6, 1.0, enemyHealthRatio);
        
        const enemyFacing = enemy.getWeaponFacing();
        const safeAngle = enemyFacing + Math.PI + Utils.rand(this.cortex._rng, -0.4, 0.4);
        
        const toEnemy = Utils.normalize(enemy.x - this.x, enemy.y - this.y);
        const flankDir = {
            x: -toEnemy.y * Math.sign(Math.sin(safeAngle - Math.atan2(toEnemy.y, toEnemy.x))),
            y: toEnemy.x * Math.sign(Math.sin(safeAngle - Math.atan2(toEnemy.y, toEnemy.x)))
        };
        
        this._lastThreatAssessment = { threatLevel, safeAngle, flankVector: flankDir };
        return {
            threatLevel: Utils.clamp(threatLevel, 0, 1),
            safeApproachAngle: safeAngle,
            flankVector: Utils.normalize(flankDir.x, flankDir.y)
        };
    }
    
    interpretAttention() {
        const cortexDebug = this.cortex.getDebugInfo();
        if (!cortexDebug?.emotions) {
            return { threat: 'LOW', flank: 'IGNORE', distance: 'FAR', prediction: 'PASSIVE' };
        }
        const emotions = cortexDebug.emotions;
        const threat = emotions.threat > 0.4 ? 'HIGH' : emotions.threat > 0.2 ? 'MED' : 'LOW';
        const flank = emotions.aggression > 0.35 ? 'SEEKING' : emotions.aggression > 0.15 ? 'NEUTRAL' : 'IGNORE';
        const distance = emotions.fear > 0.4 ? 'CLOSE' : emotions.fear > 0.2 ? 'MID' : 'FAR';
        const prediction = emotions.confidence > 0.3 ? 'ACTIVE' : 'PASSIVE';
        return { threat, flank, distance, prediction };
    }
    
    predictEnemyIntent(enemy) {        if (!enemy?.alive) return { intent: 'none', confidence: 1.0 };
        
        const enemyHealth = enemy.health / enemy.stats.maxHealth;
        const distance = Utils.dist(this, enemy);
        const inArc = enemy.isPointInWeaponArc(this);
        const inRange = distance <= (enemy.weapon.range || 50);
        const enemyAggression = enemy.lastDecision?.behaviors?.aggression || 0.5;
        
        if (enemyHealth < 0.3 && inRange && enemyAggression > 0.6) return { intent: 'desperate_attack', confidence: 0.85 };
        if (inArc && inRange && enemyAggression > 0.4) return { intent: 'attack', confidence: 0.75 };
        if (enemyHealth < 0.4 && enemyAggression < 0.3) return { intent: 'flee', confidence: 0.8 };
        if (distance < 80 && enemyAggression > 0.5 && !inArc) return { intent: 'flank', confidence: 0.65 };
        return { intent: 'unknown', confidence: 0.5 };
    }
    
    predictAllyIntent(ally) {
        if (!ally?.alive) return { intent: 'none', confidence: 0 };
        
        const distance = Utils.dist(this, ally);
        const allyHealth = ally.health / ally.stats.maxHealth;
        const enemyNearby = Utils.getEnemies(ally, this._lastWorld).length > 0;
        
        if (allyHealth < 0.3 && enemyNearby) return { intent: 'needs_help', confidence: 0.9 };
        if (ally.target && Utils.dist(ally, ally.target) < 20) return { intent: 'attacking', confidence: 0.7 };
        return { intent: 'maneuvering', confidence: 0.5 };
    }
    
    updateAllies(world) {
        if (!this.teamId) { this.allies = []; return; }
        this.allies = (world?.enemies || []).filter(e => e && e.id !== this.id && e.alive && e.teamId === this.teamId);
    }
    
    getInputs(world) {
        return this.adapter.encode(this._getGameInputs(world));
    }
    
    _getGameInputs(world) {
        const inputs = {};
        const maxDist = Math.sqrt(CONFIG.GAME.LOGICAL_WIDTH ** 2 + CONFIG.GAME.LOGICAL_HEIGHT ** 2);
        
        const enemiesWithDist = (world?.enemies || [])
            .filter(e => {
                if (!e || e.id === this.id || !e.alive) return false;
                if (this.teamId === null && e.teamId === null) return true;
                return e.teamId !== this.teamId;
            })
            .map(e => ({ agent: e, d: Utils.dist(this, e) }))
            .sort((a, b) => a.d - b.d);
        
        const enemies = enemiesWithDist.slice(0, 3);        const primaryEnemy = enemiesWithDist[0]?.agent;
        
        for (let i = 0; i < 3; i++) {
            const e = enemies[i];
            if (e) {
                inputs[`enemy${i}_dx`] = (e.agent.x - this.x) / maxDist;
                inputs[`enemy${i}_dy`] = (e.agent.y - this.y) / maxDist;
                inputs[`enemy${i}_dist`] = (150 - e.d) / 150;
                inputs[`enemy${i}_health`] = e.agent.health / e.agent.stats.maxHealth;
            } else {
                inputs[`enemy${i}_dx`] = 0;
                inputs[`enemy${i}_dy`] = 0;
                inputs[`enemy${i}_dist`] = 1;
                inputs[`enemy${i}_health`] = 1;
            }
        }
        
        const walls = (world?.walls || []).map(w => ({ ...w, d: Utils.dist(this, w) })).sort((a, b) => a.d - b.d)[0];
        if (walls) {
            inputs.wall_dx = (walls.x - this.x) / maxDist;
            inputs.wall_dy = (walls.y - this.y) / maxDist;
            inputs.wall_dist = (60 - walls.d) / 60;
        } else {
            inputs.wall_dx = 0;
            inputs.wall_dy = 0;
            inputs.wall_dist = 1;
        }
        
        inputs.self_x = (CONFIG.GAME.LOGICAL_WIDTH/2 - this.x) / (CONFIG.GAME.LOGICAL_WIDTH/2);
        inputs.self_y = (CONFIG.GAME.LOGICAL_HEIGHT/2 - this.y) / (CONFIG.GAME.LOGICAL_HEIGHT/2);
        inputs.self_health = this.health / this.stats.maxHealth;
        inputs.self_reward = Utils.clamp(this.cumulativeReward / 50, -1, 1);
        inputs.self_damage = this.stats.damage / 15;
        inputs.self_dodge = this.stats.dodgeChance;
        inputs.self_fireRate = this.stats.fireRate / 60;
        inputs.step_normalized = Utils.clamp((world?.step || 0) / 2000, 0, 1);
        
        const weaponTypes = Object.keys(WEAPONS);
        for (const wt of weaponTypes) {
            inputs[`weapon_${wt}`] = this.weaponType === wt ? 1 : 0;
        }
        
        inputs.death_count = this.deaths > 0 ? Math.min(1, this.deaths / 10) : 0;
        inputs.forced_combat = this._forcedCombatTimer > 0 ? 1 : 0;
        
        const allies = Utils.getTeamMembers(this, world);
        inputs.ally_count = allies.length;
        inputs.ally_health_avg = allies.length > 0
            ? allies.reduce((s, a) => s + a.health / a.stats.maxHealth, 0) / allies.length
            : 0;        
        // ‚úÖ Mode one-hot for cortex input
        const modeVec = this.arbiter?.getModeOneHot?.() || new Float32Array(CONFIG.BEHAVIOR.MODES.length);
        CONFIG.BEHAVIOR.MODES.forEach((mode, i) => {
            inputs[`mode_${mode}`] = modeVec[i] || 0;
        });
        
        // Tactical inputs
        if (primaryEnemy && this.config?.enableTactical) {
            const toEnemy = Math.atan2(primaryEnemy.y - this.y, primaryEnemy.x - this.x);
            const myFacing = this.getWeaponFacing();
            let angleToEnemy = Utils.normalizeAngle(toEnemy - myFacing);
            inputs.angle_to_enemy = Utils.clamp(angleToEnemy / Math.PI, -1, 1);
            inputs.enemy_sees_me = primaryEnemy.isPointInWeaponArc(this) ? 1 : 0;
            
            const threat = this.assessThreatFromEnemy(primaryEnemy);
            inputs.threat_level = threat.threatLevel;
            inputs.flank_vector_x = Utils.clamp(threat.flankVector.x, -1, 1);
            inputs.flank_vector_y = Utils.clamp(threat.flankVector.y, -1, 1);
            
            const enemyFacing = primaryEnemy.getWeaponFacing();
            let angleFromEnemy = Utils.normalizeAngle(Math.atan2(this.y - primaryEnemy.y, this.x - primaryEnemy.x) - enemyFacing);
            inputs.angle_from_enemy = Utils.clamp(angleFromEnemy / Math.PI, -1, 1);
            
            const arcEdgeAngle = enemyFacing + (primaryEnemy.weapon.arcAngle || Math.PI) / 2;
            const distToArcEdge = Math.abs(angleFromEnemy) - (primaryEnemy.weapon.arcAngle || Math.PI) / 2;
            inputs.dist_to_arc_edge = Utils.clamp(distToArcEdge / Math.PI, -1, 1);
            
            inputs.self_damage_ratio = Utils.clamp(1 - (this.health / this.stats.maxHealth), 0, 1);
            
            const predictedEnemyX = primaryEnemy.x + primaryEnemy.vx * 8;
            const predictedEnemyY = primaryEnemy.y + primaryEnemy.vy * 8;
            inputs.predicted_enemy_x = Utils.clamp((predictedEnemyX - this.x) / CONFIG.GAME.LOGICAL_WIDTH, -1, 1);
            inputs.predicted_enemy_y = Utils.clamp((predictedEnemyY - this.y) / CONFIG.GAME.LOGICAL_HEIGHT, -1, 1);
            
            const flankTarget = { x: this.x + threat.flankVector.x * 60, y: this.y + threat.flankVector.y * 60 };
            const pathBlocked = (world?.walls || []).some(w =>
                Utils._pointSegDist(this.x, this.y, flankTarget.x, flankTarget.y, w.x, w.y) < 20
            );
            inputs.path_blocked = pathBlocked ? 1 : 0;
            
            const recentExposure = (this._recentArcExposure || []).filter(t => (world.step || 0) - t < 30).length / 30;
            inputs.recent_exposure = Utils.clamp(recentExposure, 0, 1);
            
            if (!this._recentArcExposure) this._recentArcExposure = [];
            if (primaryEnemy.isPointInWeaponArc(this)) {
                this._recentArcExposure.push(world.step || 0);
            }
        }
                return inputs;
    }
    
    // ‚úÖ _applyCortexOutput with mode-specific modulation
    _applyCortexOutput(output, mode = 'combat') {
        if (!output) return;
        
        // Movement with mode-specific damping
        const moveDamping = {
            combat: CONFIG.PHYSICS.MOVE_ACCEL,
            flee: CONFIG.PHYSICS.MOVE_ACCEL * 1.5,
            explore: CONFIG.PHYSICS.MOVE_ACCEL * 0.7,
            avoid: CONFIG.PHYSICS.MOVE_ACCEL * 1.2,
            hunt: CONFIG.PHYSICS.MOVE_ACCEL * 0.9
        }[mode] || CONFIG.PHYSICS.MOVE_ACCEL;
        
        if (output.move_x !== undefined) {
            this.vx = Utils.lerp(this.vx, output.move_x * 15, moveDamping);
        }
        if (output.move_y !== undefined) {
            this.vy = Utils.lerp(this.vy, output.move_y * 15, moveDamping);
        }
        
        // Mode-specific behavior overrides
        if (mode === 'flee' && (output.retreat_urgency || 0) > 0.6) {
            // Immediate reverse + speed boost
            const speed = 1.8 + (output.retreat_urgency - 0.6) * 2;
            this.vx = -Math.sign(this.vx) * speed;
            this.vy = -Math.sign(this.vy) * speed;
        }
        
        if (mode === 'combat' && (output.flank_commit || 0) > 0.5 && this._lastThreatAssessment) {
            // Apply flank vector with commitment weight
            const flankWeight = output.flank_commit * 0.6;
            this.vx = Utils.lerp(this.vx, this._lastThreatAssessment.flankVector.x * 12, flankWeight);
            this.vy = Utils.lerp(this.vy, this._lastThreatAssessment.flankVector.y * 12, flankWeight);
        }
        
        // Aggression/throttle modulation
        if (output.aggression !== undefined) {
            // Used for combat decision weighting
        }
        if (output.retreat_urgency !== undefined && output.retreat_urgency > 0.7 && this.health / this.stats.maxHealth < 0.4) {
            this.vx *= -0.6;
            this.vy *= -0.6;
        }
    }
    
    // ‚úÖ decide() with real arbiter integration
    decide(world) {        this.updateAllies(world);
        this._lastWorld = {
            enemies: (world?.enemies || []).map(e => e ? {
                id: e.id, x: e.x, y: e.y, alive: e.alive, health: e.health,
                stats: { ...e.stats }, agent: e, teamId: e.teamId
            } : null).filter(e => e),
            walls: (world?.walls || []).map(w => w ? { x: w.x, y: w.y } : null).filter(w => w),
            step: world?.step || 0
        };
        
        this.updatePredictiveMemory(world);
        const inputs = this.getInputs(world);
        const reward = this._calculateCortexReward(world);
        const context = {
            enemyDistance: world?.enemies?.[0] ? Utils.dist(this, world.enemies[0]) : 999,
            health: this.health / this.stats.maxHealth,
            step: world?.step || 0
        };
        
        // ‚úÖ CORTEX FORWARD PASS
        const result = this.cortex.forward(inputs, reward, context);
        
        // ‚úÖ ARBITER: Select mode based on cortex outputs + emotions + context
        const arbiterResult = this.arbiter.selectMode(
            result.output,
            result.emotions || this.cortex.getEmotions(),
            {
                healthRatio: this.health / this.stats.maxHealth,
                enemyDistance: context.enemyDistance,
                hasAllyNearby: (this.allies || []).some(a => Utils.dist(this, a) < CONFIG.GAME.COORDINATION_RADIUS),
                isCornered: this._isCornered(world),
                enemyCount: Utils.getEnemies(this, world).length,
                step: world?.step || 0
            }
        );
        
        this.mode = arbiterResult.mode; // ‚úÖ Mode now actually changes!
        
        // ‚úÖ Mode-specific output modulation
        const modulatedOutput = this._modulateOutputByMode(result.output, arbiterResult.mode);
        
        // Decode and apply
        const decoded = this.adapter.decode(modulatedOutput);
        this._applyCortexOutput(decoded, arbiterResult.mode);
        
        // Update target based on movement
        this.target = { x: this.x + this.vx * 10, y: this.y + this.vy * 10 };
        this.speed = Utils.lerp(this.speed, (decoded.throttle || 0) * 2.5 + 1.0, 0.08);
        
        this.lastDecision = {            mode: this.mode,
            behaviors: {
                speed: decoded.throttle || 0.5,
                curiosity: decoded.curiosity || 0.5,
                aggression: decoded.aggression || 0.5,
                memoryWeight: decoded.memory_weight || 0.5,
                retreatUrgency: decoded.retreat_urgency || 0,
                flankCommit: decoded.flank_commit || 0
            },
            inputs,
            output: modulatedOutput,
            value: this.cortex._estimateValue(),
            nextValue: null,
            arbiterConfidence: arbiterResult.confidence
        };
        
        return {
            target: this.target,
            speed: this.speed,
            mode: this.mode,
            behaviors: this.lastDecision.behaviors,
            inputs,
            output: modulatedOutput,
            arbiterResult
        };
    }
    
    // ‚úÖ Mode-specific output modulation
    _modulateOutputByMode(output, mode) {
        const mod = [...output]; // copy
        switch(mode) {
            case 'flee':
                mod[8] = Math.max(mod[8] || 0, 0.7); // retreat_urgency
                mod[4] = Math.min(mod[4] || 0.5, 0.2); // aggression
                mod[2] = Math.max(mod[2] || 0.3, 0.8); // throttle (flee fast)
                break;
            case 'combat':
                mod[4] = Math.max(mod[4] || 0.3, 0.6); // aggression
                mod[9] = Math.max(mod[9] || 0.2, 0.5); // flank_commit
                mod[8] = Math.min(mod[8] || 0.5, 0.3); // retreat_urgency
                break;
            case 'explore':
                mod[3] = Math.max(mod[3] || 0.4, 0.8); // curiosity
                mod[4] = Math.min(mod[4] || 0.5, 0.1); // aggression
                mod[7] = Utils.rand(this.cortex._rng, -0.5, 0.5); // circular_bias for exploration
                break;
            case 'avoid':
                mod[8] = Math.max(mod[8] || 0.5, 0.9); // retreat_urgency
                mod[2] = Math.min(mod[2] || 0.5, 0.3); // throttle (move cautiously)
                mod[6] = Math.abs(mod[6] || 0) > 0.3 ? mod[6] : Utils.rand(this.cortex._rng, -0.8, 0.8); // steering                break;
            case 'hunt':
                mod[4] = Math.max(mod[4] || 0.4, 0.5); // aggression
                mod[3] = Math.max(mod[3] || 0.3, 0.6); // curiosity
                mod[9] = Math.max(mod[9] || 0.3, 0.6); // flank_commit
                break;
        }
        return new Float32Array(mod);
    }
    
    _isCornered(world) {
        const margin = 40;
        const nearWall = (world?.walls || []).some(w => Utils.dist(this, w) < 30);
        const nearEdge = this.x < margin || this.x > CONFIG.GAME.LOGICAL_WIDTH - margin ||
                        this.y < margin || this.y > CONFIG.GAME.LOGICAL_HEIGHT - margin;
        return nearWall && nearEdge;
    }
    
    // ‚úÖ _calculateCortexReward with smoothed rewards and anti-jitter
    _calculateCortexReward(world) {
        let rawReward = 0;
        
        // Enemy proximity reward
        const enemies = Utils.getEnemies(this, world);
        if (enemies.length > 0) {
            const enemy = enemies[0];
            const dist = Utils.dist(this, enemy);
            if (dist < 100) {
                const prevDist = Utils.dist(this.lastPos, enemy);
                if (dist < prevDist && prevDist > 15) {
                    rawReward += 0.2;
                }
            }
        }
        
        // Combat rewards/penalties
        if (this._lastHitDealt > 0) {
            rawReward += this._lastHitDealt * 0.5;
            this._lastHitDealt = 0;
        }
        if (this._lastHitReceived > 0) {
            rawReward -= this._lastHitReceived * 0.3;
            this._lastHitReceived = 0;
        }
        
        // Movement reward with stuck penalty
        const moved = Math.hypot(this.x - this.lastPos.x, this.y - this.lastPos.y);
        if (moved > 1.0) {
            rawReward += 0.03;
            this.stuckCounter = 0;        } else {
            this.stuckCounter++;
            if (this.stuckCounter > 30) {
                rawReward -= 0.15;
            }
        }
        
        // Wall proximity penalty
        const wallDist = (world?.walls || []).length
            ? Math.min(...world.walls.map(w => Utils.dist(this, w)))
            : 999;
        if (wallDist < 25) {
            rawReward -= 0.08 * (1 - wallDist / 25);
        }
        
        // Health-based rewards
        const healthRatio = this.health / this.stats.maxHealth;
        if (healthRatio > 0.7 && enemies.length > 0) {
            rawReward += 0.05;
        } else if (healthRatio < 0.15) {
            rawReward -= 0.2;
        }
        
        // Exploration reward
        const newCell = `${Math.floor(this.x / 60)},${Math.floor(this.y / 60)}`;
        if (!this.permanent.memory.visited.has(newCell)) {
            this.permanent.memory.visited.add(newCell);
            if (this.permanent.memory.visited.size > this.permanent.memory._maxVisited) {
                const first = this.permanent.memory.visited.values().next().value;
                this.permanent.memory.visited.delete(first);
            }
            rawReward += 0.08;
        }
        
        // Tactical rewards
        if (this.config?.enableTactical && enemies.length > 0) {
            const enemy = enemies[0];
            const threat = this.assessThreatFromEnemy(enemy);
            if (enemy.isPointInWeaponArc(this)) {
                rawReward -= (CONFIG.TACTICAL.FRONT_PENALTY || 0.20) * threat.threatLevel;
            } else {
                const angleToMe = Math.atan2(this.y - enemy.y, this.x - enemy.x) - enemy.getWeaponFacing();
                const normalizedAngle = Math.abs(Utils.normalizeAngle(angleToMe));
                const enemyWeaponArc = (enemy.weapon.arcAngle || Math.PI) / 2;
                if (normalizedAngle > enemyWeaponArc * 1.2) {
                    rawReward += (CONFIG.TACTICAL.FLANK_BONUS || 0.30) * (normalizedAngle / Math.PI);
                }
            }
        }
                // ‚úÖ Smooth reward with exponential moving average
        this._smoothedReward = Utils.lerp(this._smoothedReward || 0, rawReward, CONFIG.LEARNING.REWARD_SMOOTH_ALPHA);
        
        // ‚úÖ Anti-jitter: penalty for rapid health oscillations
        const healthChange = this.health - (this._lastHealth || this.health);
        if (Math.abs(healthChange) > CONFIG.LEARNING.ANTI_JITTER_THRESHOLD &&
            Math.sign(healthChange) !== Math.sign(this._lastHealthChange || 0)) {
            this._smoothedReward -= CONFIG.LEARNING.ANTI_JITTER_PENALTY;
        }
        this._lastHealth = this.health;
        this._lastHealthChange = healthChange;
        
        this.lastPos = { x: this.x, y: this.y };
        this.cumulativeReward = Math.max(this.cumulativeReward + this._smoothedReward, -100);
        
        return Utils.clamp(this._smoothedReward, CONFIG.LEARNING.REWARD_CLIP_MIN, CONFIG.LEARNING.REWARD_CLIP_MAX);
    }
    
    // ‚úÖ learn() with gradient clipping and confidence gating
    learn(reward, decision, nextInputs = null) {
        if (!decision || !this.config?.enableTraining) return;
        
        // ‚úÖ Only learn if arbiter is confident
        const modeConfidence = decision.arbiterConfidence || 0.5;
        if (modeConfidence < CONFIG.LEARNING.MIN_CONFIDENCE_FOR_LEARN) return;
        
        // ‚úÖ Clip reward for stability
        const clippedReward = Utils.clamp(reward, CONFIG.LEARNING.REWARD_CLIP_MIN, CONFIG.LEARNING.REWARD_CLIP_MAX);
        
        const currentValue = decision.value;
        const nextValue = nextInputs ? this.cortex._estimateValue() : 0;
        
        this.cortex.learn({
            observation: decision.inputs,
            action: decision.output,
            reward: clippedReward,
            nextObservation: nextInputs,
            done: !this.alive
        });
        
        // Skill evolution on high reward
        if (clippedReward > 3 && this.config?.enableSkillEvolution) {
            this.updatePermanentSkills(clippedReward, decision.mode, this.config?.skillGrowthRate || 0.04);
        }
        if (clippedReward > 4) {
            this.updateMuscleMemory(decision.output, clippedReward);
        }
    }
    
    updatePermanentSkills(reward, mode, skillGrowthRate) {        if (reward <= 3 || !this.config?.enableSkillEvolution) return;
        const skillKey = 'combat';
        if (skillKey && this.permanent.skills[skillKey] !== undefined) {
            const growth = skillGrowthRate * reward * (CONFIG.EVOLUTION.COMBAT_SKILL_GROWTH || 0.15);
            this.permanent.skills[skillKey] = Utils.clamp(this.permanent.skills[skillKey] + growth, 0, 1);
            this.skillEmbedding = [
                this.permanent.skills.hunting,
                this.permanent.skills.fleeing,
                this.permanent.skills.combat,
                this.permanent.skills.exploring,
                this.permanent.skills.avoiding
            ];
        }
    }
    
    updateMuscleMemory(outputs, reward) {
        if (reward < 4) return;
        for (let i = 0; i < Math.min(16, outputs.length); i++) {
            const diff = Math.abs(outputs[i] - this.permanent.muscleMemory[i]);
            if (diff > 0.12 && Math.abs(outputs[i]) > 0.4) {
                this.permanent.muscleMemory[i] = Utils.lerp(this.permanent.muscleMemory[i], outputs[i], 0.08);
            }
        }
    }
    
    updatePredictiveMemory(world) {
        this.predictive.shortTerm.positions.push({ x: this.x, y: this.y });
        if (this.predictive.shortTerm.positions.length > CONFIG.MEMORY.PREDICTIVE_HISTORY_MAX) {
            this.predictive.shortTerm.positions.shift();
        }
        
        const enemies = Utils.getEnemies(this, world);
        if (enemies.length > 0) {
            const enemy = enemies[0];
            this.predictive.shortTerm.enemyHistory.push({ x: enemy.x, y: enemy.y });
            if (this.predictive.shortTerm.enemyHistory.length > CONFIG.MEMORY.ENEMY_HISTORY_MAX) {
                this.predictive.shortTerm.enemyHistory.shift();
            }
            
            const hist = this.predictive.shortTerm.enemyHistory;
            if (hist.length >= 2) {
                const [prev, last] = [hist[hist.length - 2], hist[hist.length - 1]];
                const dx = last.x - prev.x, dy = last.y - prev.y;
                this.predictive.predictions.enemyPos = {
                    x: last.x + dx * 0.75,
                    y: last.y + dy * 0.75
                };
                const error = Utils.dist(enemy, this.predictive.predictions.enemyPos);
                this.predictive.predictionError = Utils.lerp(this.predictive.predictionError, error / 50, 0.1);
                const accuracy = Math.max(0, 1 - error / 100);                this.predictive.confidence = Utils.lerp(this.predictive.confidence, accuracy, 0.05);
            }
        } else {
            this.predictive.confidence = Utils.lerp(this.predictive.confidence, 0.5, 0.02);
        }
    }
    
    move(target, speed, walls, dt, networkOutputs = null) {
        if (!target || typeof target.x !== 'number' || !isFinite(target.x)) {
            target = { x: CONFIG.GAME.LOGICAL_WIDTH/2, y: CONFIG.GAME.LOGICAL_HEIGHT/2 };
        }
        
        const dx = target.x - this.x, dy = target.y - this.y;
        const dist = Math.hypot(dx, dy);
        
        // Knockback physics
        if (Math.abs(this._knockbackVelocity.x) > 0.1 || Math.abs(this._knockbackVelocity.y) > 0.1) {
            this.vx = this._knockbackVelocity.x;
            this.vy = this._knockbackVelocity.y;
            this._knockbackVelocity.x *= CONFIG.PHYSICS.FRICTION_GROUND;
            this._knockbackVelocity.y *= CONFIG.PHYSICS.FRICTION_GROUND;
            if (Math.abs(this._knockbackVelocity.x) < 0.05) this._knockbackVelocity.x = 0;
            if (Math.abs(this._knockbackVelocity.y) < 0.05) this._knockbackVelocity.y = 0;
        }
        
        // Movement with tactical modulation
        if (this._stunTimer <= 0 && dist > 1) {
            let dirX = dx / dist, dirY = dy / dist;
            
            if (this.config?.enableTactical && Array.isArray(networkOutputs) && networkOutputs.length >= 14) {
                const lateralBias = Utils.clamp(Utils.safeNumber(networkOutputs[9], 0), -1, 1);
                const circleBias = Utils.clamp(Utils.safeNumber(networkOutputs[10], 0), -1, 1);
                const retreatUrgency = Utils.clamp(Utils.safeNumber(networkOutputs[11], 0), 0, 1);
                const flankCommit = Utils.clamp(Utils.safeNumber(networkOutputs[12], 0), 0, 1);
                const aggressionOverride = Utils.clamp(Utils.safeNumber(networkOutputs[13], 0), -1, 1);
                
                if (retreatUrgency > 0.7 && this.health / this.stats.maxHealth < CONFIG.TACTICAL.RETREAT_HP_THRESHOLD) {
                    dirX = -dirX * 0.6;
                    dirY = -dirY * 0.6;
                } else {
                    const orthoX = -dirY, orthoY = dirX;
                    dirX += orthoX * lateralBias * 0.4 * flankCommit;
                    dirY += orthoY * lateralBias * 0.4 * flankCommit;
                    
                    if (Math.abs(circleBias) > 0.3 && dist < 80) {
                        const circleStrength = Math.abs(circleBias) * (CONFIG.TACTICAL.CIRCLE_STRENGTH || 0.25);
                        const circleDir = Math.sign(circleBias);
                        const tempX = dirX * Math.cos(circleStrength) - dirY * Math.sin(circleStrength * circleDir);
                        const tempY = dirX * Math.sin(circleStrength * circleDir) + dirY * Math.cos(circleStrength);
                        dirX = tempX;                        dirY = tempY;
                    }
                    
                    const enemiesWithDist = (this._lastWorld?.enemies || [])
                        .filter(e => e && e.id !== this.id && e.alive && e.teamId !== this.teamId)
                        .map(e => ({ agent: e.agent, d: Utils.dist(this, e.agent) }))
                        .sort((a, b) => a.d - b.d);
                    const primaryEnemy = enemiesWithDist[0]?.agent;
                    
                    if (primaryEnemy && typeof primaryEnemy.isPointInWeaponArc === 'function' && flankCommit > CONFIG.TACTICAL.MIN_FLANK_COMMIT) {
                        const threat = this.assessThreatFromEnemy(primaryEnemy);
                        const flankWeight = flankCommit * (1 - threat.threatLevel * 0.3);
                        dirX = Utils.lerp(dirX, threat.flankVector.x, flankWeight * 0.5);
                        dirY = Utils.lerp(dirY, threat.flankVector.y, flankWeight * 0.5);
                    }
                }
                
                const accelMult = 1.2 + aggressionOverride * 0.4;
                const minSpeed = CONFIG.PHYSICS.MIN_SPEED;
                const actualSpeed = Math.max(speed, minSpeed) * accelMult;
                const finalLen = Math.hypot(dirX, dirY);
                if (finalLen > 1e-5) { dirX /= finalLen; dirY /= finalLen; }
                const accel = CONFIG.PHYSICS.MOVE_ACCEL * (1.0 + aggressionOverride * 0.3);
                
                this.vx = Utils.lerp(this.vx, dirX * actualSpeed, accel);
                this.vy = Utils.lerp(this.vy, dirY * actualSpeed, accel);
                
                if (Math.abs(this.vx) < 0.15) this.vx = dirX * minSpeed;
                if (Math.abs(this.vy) < 0.15) this.vy = dirY * minSpeed;
            } else {
                const accelMult = 1.5;
                const minSpeed = CONFIG.PHYSICS.MIN_SPEED;
                const actualSpeed = Math.max(speed, minSpeed) * accelMult;
                const accel = CONFIG.PHYSICS.MOVE_ACCEL * accelMult;
                
                this.vx = Utils.lerp(this.vx, dirX * actualSpeed, accel);
                this.vy = Utils.lerp(this.vy, dirY * actualSpeed, accel);
                
                if (Math.abs(this.vx) < 0.15) this.vx = dirX * minSpeed;
                if (Math.abs(this.vy) < 0.15) this.vy = dirY * minSpeed;
            }
        }
        
        // Position update
        this.x += this.vx * dt;
        this.y += this.vy * dt;
        
        // Boundary clamping
        this.x = Utils.clamp(this.x, 20, CONFIG.GAME.LOGICAL_WIDTH - 20);
        this.y = Utils.clamp(this.y, 20, CONFIG.GAME.LOGICAL_HEIGHT - 20);        
        // Wall collision
        for (const w of walls) {
            const d = Utils.dist(this, w);
            if (d < CONFIG.PHYSICS.AGENT_COLLISION_RADIUS + 2) {
                const push = Utils.normalize(this.x - w.x, this.y - w.y);
                const overlap = (CONFIG.PHYSICS.AGENT_COLLISION_RADIUS + 2) - d;
                this.x += push.x * overlap * CONFIG.PHYSICS.COLLISION_PUSH;
                this.y += push.y * overlap * CONFIG.PHYSICS.COLLISION_PUSH;
                const bounceStrength = CONFIG.PHYSICS.BOUNCE_STRENGTH;
                this.vx = -push.x * bounceStrength + this.vx * 0.5;
                this.vy = -push.y * bounceStrength + this.vy * 0.5;
            }
        }
        
        // Velocity damping and clamping
        this.vx *= CONFIG.PHYSICS.VELOCITY_DAMPING;
        this.vy *= CONFIG.PHYSICS.VELOCITY_DAMPING;
        const maxV = CONFIG.PHYSICS.MAX_VELOCITY;
        this.vx = Utils.clamp(this.vx, -maxV, maxV);
        this.vy = Utils.clamp(this.vy, -maxV, maxV);
        
        // Status timers
        if (this._stunTimer > 0) this._stunTimer--;
        if (this._weaponEffectTimer > 0) this._weaponEffectTimer--;
        if (this._forcedExploration > 0) this._forcedExploration--;
    }
    
    _applyKnockback(target, aggression, weapon) {
        if (!target || !target.alive) return;
        const baseKB = weapon.knockback || 8.0;
        const kbType = weapon.knockbackType || 'impact';
        const kbStrength = baseKB + aggression * 3;
        const knockbackDir = Utils.normalize(target.x - this.x, target.y - this.y);
        const mass = CONFIG.PHYSICS.KNOCKBACK_MASS || 1.0;
        
        switch(kbType) {
            case 'impact':
                target._knockbackVelocity.x += knockbackDir.x * kbStrength / mass;
                target._knockbackVelocity.y += knockbackDir.y * kbStrength / mass;
                target._stunTimer = Math.max(target._stunTimer, weapon.stunTime);
                break;
            case 'heavy':
                target._knockbackVelocity.x += knockbackDir.x * kbStrength * 1.8 / mass;
                target._knockbackVelocity.y += knockbackDir.y * kbStrength * 1.8 / mass;
                target._stunTimer = Math.max(target._stunTimer, weapon.stunTime);
                target._heavyHit = 20;
                break;
            case 'slash':
                target._knockbackVelocity.x += knockbackDir.x * kbStrength / mass;                target._knockbackVelocity.y += knockbackDir.y * kbStrength / mass;
                const lateralX = -knockbackDir.y * kbStrength * 0.4;
                const lateralY = knockbackDir.x * kbStrength * 0.4;
                target._knockbackVelocity.x += lateralX / mass;
                target._knockbackVelocity.y += lateralY / mass;
                target._stunTimer = Math.max(target._stunTimer, weapon.stunTime);
                break;
            case 'thrust':
                target._knockbackVelocity.x += knockbackDir.x * kbStrength * 1.2 / mass;
                target._knockbackVelocity.y += knockbackDir.y * kbStrength * 1.2 / mass;
                target._pierced = 15;
                target._stunTimer = Math.max(target._stunTimer, weapon.stunTime);
                break;
            case 'stagger':
                target._knockbackVelocity.x += knockbackDir.x * kbStrength * 0.5 / mass;
                target._knockbackVelocity.y += knockbackDir.y * kbStrength * 0.5 / mass;
                target._knockbackVelocity.x += Utils.rand(this.cortex._rng, -1, 1) * 2;
                target._knockbackVelocity.y += Utils.rand(this.cortex._rng, -1, 1) * 2;
                target._stunTimer = Math.max(target._stunTimer, weapon.stunTime);
                break;
            case 'pulse':
                target._knockbackVelocity.x += knockbackDir.x * kbStrength * 0.8 / mass;
                target._knockbackVelocity.y += knockbackDir.y * kbStrength * 0.8 / mass;
                target._pulseEffect = 25;
                target._stunTimer = Math.max(target._stunTimer, weapon.stunTime);
                break;
            case 'quick':
                target._knockbackVelocity.x += knockbackDir.x * kbStrength * 0.3 / mass;
                target._knockbackVelocity.y += knockbackDir.y * kbStrength * 0.3 / mass;
                target._stunTimer = Math.max(target._stunTimer, weapon.stunTime);
                break;
            case 'continuous':
                target._knockbackVelocity.x += knockbackDir.x * kbStrength * 0.4 / mass;
                target._knockbackVelocity.y += knockbackDir.y * kbStrength * 0.4 / mass;
                target._continuousKB = Math.min(1, (target._continuousKB || 0) + 0.25);
                target._knockbackVelocity.x *= (1 - target._continuousKB * 0.15);
                target._knockbackVelocity.y *= (1 - target._continuousKB * 0.15);
                target._stunTimer = Math.max(target._stunTimer, weapon.stunTime);
                break;
        }
        
        const maxKB = CONFIG.PHYSICS.MAX_VELOCITY * 1.5;
        target._knockbackVelocity.x = Utils.clamp(target._knockbackVelocity.x, -maxKB, maxKB);
        target._knockbackVelocity.y = Utils.clamp(target._knockbackVelocity.y, -maxKB, maxKB);
        
        // Recoil
        this._knockbackVelocity.x -= knockbackDir.x * kbStrength * 0.15 / mass;
        this._knockbackVelocity.y -= knockbackDir.y * kbStrength * 0.15 / mass;
    }
        calculateReward(world, decision) {
        return this._calculateCortexReward(world);
    }
    
    evolve(mutationRate = 0.1) {
        if (!this.config?.enableEvolution) return 0;
        const actualRate = this._learnFromWinner
            ? (CONFIG.EVOLUTION.MUTATION_ON_DEATH || 0.2)
            : mutationRate;
        return 0; // Cortex handles evolution via weight mutation
    }
    
    reset(x, y) {
        this.x = x;
        this.y = y;
        this.vx = 0;
        this.vy = 0;
        this.health = this.stats.maxHealth;
        this.stuckCounter = 0;
        this.lastPos = { x, y };
        this.cumulativeReward = 5;
        this._smoothedReward = 0;
        this._lastHealth = this.health;
        this._lastHealthChange = 0;
        this.mode = 'combat';
        this.target = { x, y };
        this.trail = [];
        this.predictive.confidence = 0.5;
        this.predictive.predictionError = 0;
        this.attackCooldown = 0;
        this.predictive.shortTerm = { positions: [], actions: [], results: [], enemyHistory: [], foodHistory: [] };
        this._lastHitDealt = 0;
        this._knockbackVelocity = { x: 0, y: 0 };
        this._stunTimer = 0;
        this._weaponEffectTimer = 0;
        this._heavyHit = 0;
        this._pierced = 0;
        this._pulseEffect = 0;
        this._continuousKB = 0;
        this._forcedCombatTimer = CONFIG.EVOLUTION.FORCED_COMBAT_AFTER_DEATH || 30;
        this._recentArcExposure = [];
        this._inEnemyArc = false;
        this._lastThreatAssessment = null;
        this._coordinationScore = 0;
        this._lastAllyAssist = 0;
        this.permanent.memory.visited.clear();
        this.socialMemory = { interactions: new Map(), reputation: 0, lastAggressor: null, allies: [], killerHistory: [] };
        this.empathyStats = { total: 0, correct: 0, byEnemy: new Map() };
        this._lastPrediction = null;
        this._empathyTrust = 0.5;        this._ignoreEmpathyFor = {};
        this._forcedExploration = 0;
        this._imaginationScore = 0;
        this._warnedAlly = false;
        this._sharedThreat = null;
        this._threatDirection = null;
        this.cortex.resetEpisode();
        this.arbiter.reset();
    }
    
    getLearningMetrics() {
        const cortexStats = this.cortex.getStats();
        return {
            avgTDError: cortexStats.tdErrorHistory?.reduce((a,b)=>a+b,0)/Math.max(1,cortexStats.tdErrorHistory?.length||1) || 0,
            avgPredictionError: this.cortex._computeAvgPredError(),
            avgPolicyEntropy: 0,
            winRate: this.wins / Math.max(1, this.wins + this.deaths),
            avgDamage: this._totalDamageDealt / Math.max(1, this._totalAttacks),
            accuracy: this._successfulHits / Math.max(1, this._totalAttacks),
            tacticalRate: this._tacticalHits / Math.max(1, this._successfulHits),
            teamWins: cortexStats.teamWins || 0
        };
    }
    
    draw(ctx, showVision = false, showTrail = true) {
        if (showTrail && this.trail.length > 1) {
            ctx.beginPath();
            ctx.moveTo(this.trail[0].x, this.trail[0].y);
            for (let i = 1; i < this.trail.length; i++) {
                const t = this.trail[i], alpha = 1 - t.age / 80;
                ctx.strokeStyle = this.color + Math.floor(alpha * 40).toString(16).padStart(2, '0');
                ctx.lineTo(t.x, t.y);
            }
            ctx.stroke();
        }
        
        // Color selection with fallbacks
        let drawColor = this.color;
        if (!drawColor || drawColor === '#fff' || drawColor === '#ffffff') {
            const defaultColors = ['#00d4ff', '#ff5577', '#00ff9d', '#ffdd44'];
            drawColor = defaultColors[parseInt(this.id.replace(/\D/g,'')) % defaultColors.length] || '#888888';
        }
        
        // Status color overlays
        if (this._lastHitReceived > 0) drawColor = '#ff8888';
        else if (this.lastMutationType === 'dmg') drawColor = '#ff4444';
        else if (this.lastMutationType === 'spd') drawColor = '#4444ff';
        else if (this.lastMutationType === 'hp') drawColor = '#44ff44';
        else if (this.lastMutationType === 'dod') drawColor = '#aa88ff';
                // Body
        ctx.fillStyle = drawColor;
        ctx.beginPath();
        ctx.arc(this.x, this.y, Agent.VISUAL_RADIUS, 0, Math.PI * 2);
        ctx.fill();
        
        // Team indicator
        if (this.teamId) {
            ctx.strokeStyle = CONFIG.GAME.TEAM_COLORS?.[this.teamId] || '#fff';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(this.x, this.y, Agent.VISUAL_RADIUS + 6, 0, Math.PI * 2);
            ctx.stroke();
        }
        
        // Velocity vector
        ctx.strokeStyle = (this._knockbackVelocity.x !== 0 || this._knockbackVelocity.y !== 0) ? '#ff0000' : '#fff';
        ctx.lineWidth = (this._knockbackVelocity.x !== 0 || this._knockbackVelocity.y !== 0) ? 3 : 2;
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(this.x + this.vx * 8, this.y + this.vy * 8);
        ctx.stroke();
        
        // Mode ring
        const modeColors = {
            combat: '#ffaa00', flee: '#ff4444', explore: '#00f2ff',
            hunt: '#aa88ff', avoid: '#ffdd44'
        };
        ctx.strokeStyle = modeColors[this.mode] || '#ffaa00';
        ctx.lineWidth = 2.5;
        ctx.beginPath();
        ctx.arc(this.x, this.y, Agent.VISUAL_RADIUS + 4, 0, Math.PI * 2);
        ctx.stroke();
        
        // Weapon icon
        ctx.fillStyle = this.weapon.color || '#ffaa00';
        ctx.font = '18px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(this.weapon.icon, this.x, this.y + 6);
        ctx.textAlign = 'left';
        
        // Confidence indicator
        ctx.fillStyle = this.predictive.confidence > 0.7 ? '#00ff9d' :
                       (this.predictive.confidence < 0.4 ? '#ff5577' : '#ffaa00');
        ctx.beginPath();
        ctx.arc(this.x + 14, this.y - 14, 3, 0, Math.PI * 2);
        ctx.fill();
        
        // Health bar
        if (this.health < this.stats.maxHealth) {            ctx.fillStyle = '#222';
            ctx.fillRect(this.x - Agent.VISUAL_RADIUS, this.y - Agent.VISUAL_RADIUS - 12, Agent.VISUAL_RADIUS * 2, 4);
            ctx.fillStyle = this.health > this.stats.maxHealth / 2 ? '#00ff9d' : '#ff5577';
            ctx.fillRect(this.x - Agent.VISUAL_RADIUS, this.y - Agent.VISUAL_RADIUS - 12,
                        Agent.VISUAL_RADIUS * 2 * (this.health / this.stats.maxHealth), 4);
        }
        
        // Stats text
        ctx.fillStyle = '#fff';
        ctx.font = '9px monospace';
        ctx.textAlign = 'center';
        ctx.fillText(`HP:${Math.round(this.stats.maxHealth)} DMG:${this.stats.damage}`, this.x, this.y - 25);
        ctx.fillText(`${this.weapon.name} W:${this.wins}`, this.x, this.y - 16);
        ctx.textAlign = 'left';
        
        // Vision cone
        if (showVision && this.mode === 'combat') {
            ctx.strokeStyle = 'rgba(255,170,0,0.3)';
            ctx.fillStyle = 'rgba(255,170,0,0.1)';
            ctx.beginPath();
            ctx.moveTo(this.x, this.y);
            ctx.arc(this.x, this.y, this.attackRange, Math.atan2(this.vy, this.vx) - 0.6, Math.atan2(this.vy, this.vx) + 0.6);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
        }
        
        // Target line
        ctx.strokeStyle = 'rgba(255,255,255,0.35)';
        ctx.setLineDash([4, 3]);
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(this.target.x, this.target.y);
        ctx.stroke();
        ctx.setLineDash([]);
        
        // Trail update
        if (this.trail.length === 0 || this.trail[this.trail.length - 1].age > 4) {
            this.trail.push({ x: this.x, y: this.y, age: 0 });
            if (this.trail.length > 35) this.trail.shift();
        }
        this.trail.forEach(t => t.age++);
        
        // Status effects
        if (Math.abs(this._knockbackVelocity.x) > 1 || Math.abs(this._knockbackVelocity.y) > 1) {
            ctx.strokeStyle = 'rgba(255,50,50,0.8)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(this.x, this.y, Agent.VISUAL_RADIUS + 8, 0, Math.PI * 2);
            ctx.stroke();        }
        if (this._stunTimer > 0) {
            ctx.strokeStyle = 'rgba(255,255,0,0.6)';
            ctx.setLineDash([2, 3]);
            ctx.beginPath();
            ctx.arc(this.x, this.y, Agent.VISUAL_RADIUS + 10, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);
        }
        if (this._forcedCombatTimer > 0) {
            ctx.strokeStyle = 'rgba(255,0,0,0.5)';
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.arc(this.x, this.y, Agent.VISUAL_RADIUS + 12, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);
        }
        
        // Debug collision radius
        if (window.arenaGame?.debug) {
            ctx.strokeStyle = 'rgba(255,255,0,0.4)';
            ctx.setLineDash([3, 2]);
            ctx.beginPath();
            ctx.arc(this.x, this.y, Agent.COLLISION_RADIUS, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);
        }
        
        // Tactical visualization
        if ((showVision || window.arenaGame?.debug) && this.config?.enableTactical) {
            const facing = this.getWeaponFacing();
            const arc = this.weapon.arcAngle || Math.PI;
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(facing);
            ctx.fillStyle = 'rgba(255, 80, 80, 0.25)';
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.arc(0, 0, this.weapon.range, -arc/2, arc/2);
            ctx.closePath();
            ctx.fill();
            ctx.fillStyle = 'rgba(255, 170, 0, 0.15)';
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.arc(0, 0, this.weapon.range * 0.7, -arc/4, arc/4);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = this.weapon.color;
            ctx.lineWidth = 2;
            ctx.beginPath();            ctx.moveTo(this.weapon.mountOffset.x, this.weapon.mountOffset.y);
            ctx.lineTo(this.weapon.mountOffset.x + 12, this.weapon.mountOffset.y);
            ctx.stroke();
            ctx.restore();
            
            const enemies = (this._lastWorld?.enemies || []).filter(e => {
                if (!e || e.id !== this.id || !e.alive) return false;
                if (this.teamId === null && e.teamId === null) return true;
                return e.teamId !== this.teamId;
            });
            const primaryEnemy = enemies[0]?.agent;
            if (primaryEnemy && typeof primaryEnemy.assessThreatFromEnemy === 'function' && showVision) {
                const threat = this.assessThreatFromEnemy(primaryEnemy);
                if (threat.threatLevel > 0.5) {
                    ctx.strokeStyle = 'rgba(0, 255, 157, 0.6)';
                    ctx.setLineDash([3, 4]);
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(this.x + threat.flankVector.x * 50, this.y + threat.flankVector.y * 50);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }
        }
        
        if (this._inEnemyArc && showVision) {
            ctx.strokeStyle = 'rgba(255, 50, 50, 0.8)';
            ctx.setLineDash([2, 2]);
            ctx.beginPath();
            ctx.arc(this.x, this.y, Agent.VISUAL_RADIUS + 14, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);
        }
        
        if (this.config?.enableDeepCognition && this._imaginationScore > 5 && showVision) {
            ctx.fillStyle = 'rgba(0, 255, 157, 0.3)';
            ctx.font = '8px monospace';
            ctx.textAlign = 'center';
            ctx.fillText(`üß†${this._imaginationScore.toFixed(1)}`, this.x, this.y - 35);
        }
    }
    
    getDebugInfo() {
        const metrics = this.getLearningMetrics();
        const attention = this.interpretAttention();
        const enemyIntent = this.predictEnemyIntent(
            (this._lastWorld?.enemies || []).find(e => {
                if (!e?.id || e.id === this.id || !e?.alive) return false;
                if (this.teamId === null && e.teamId === null) return true;
                return e.teamId !== this.teamId;            })?.agent
        );
        const empathyAcc = this.empathyStats.total > 0 ? this.empathyStats.correct / this.empathyStats.total : 0;
        const memConf = 0.5;
        
        return {
            mode: this.mode,
            weapon: this.weapon.icon + ' ' + this.weapon.name,
            target: `${Math.round(this.target.x)},${Math.round(this.target.y)}`,
            speed: this.speed.toFixed(2),
            aggro: this.lastDecision?.behaviors?.aggression?.toFixed(2) || '‚Äî',
            memory: (this.permanent.memory.visited.size / 100).toFixed(2),
            neurons: '',
            reward: this.cumulativeReward.toFixed(2),
            stuck: this.stuckCounter,
            confidence: this.predictive.confidence.toFixed(2),
            predError: metrics.avgPredictionError.toFixed(3),
            health: `${Math.round(this.health)}/${this.stats.maxHealth}`,
            mutations: this.mutations,
            generation: this.generation,
            tdError: metrics.avgTDError.toFixed(4),
            policyEntropy: metrics.avgPolicyEntropy.toFixed(3),
            winRate: metrics.winRate.toFixed(2),
            collectionRate: 0,
            gate0: '‚Äî',
            gate1: '‚Äî',
            expert0: '‚Äî',
            expert1: '‚Äî',
            loadBal: '‚Äî',
            hebbian: this.config?.enableHebbian ? 'ON' : 'OFF',
            socialRep: this.socialMemory.reputation.toFixed(2),
            archetype: this.permanent.skills.combat > 0.6 ? 'fighter' : 'aggressor',
            wins: this.wins,
            deaths: this.deaths,
            kbVel: `${this._knockbackVelocity.x.toFixed(1)},${this._knockbackVelocity.y.toFixed(1)}`,
            stun: this._stunTimer,
            forcedCombat: this._forcedCombatTimer,
            threat: this._lastThreatAssessment?.threatLevel?.toFixed(2) || '‚Äî',
            flank: this._lastThreatAssessment ? `${this._lastThreatAssessment.flankVector.x.toFixed(2)},${this._lastThreatAssessment.flankVector.y.toFixed(2)}` : '‚Äî',
            attThreat: attention.threat,
            attFlank: attention.flank,
            attDist: attention.distance,
            attPred: attention.prediction,
            enemyIntent: enemyIntent.intent,
            intentConf: enemyIntent.confidence.toFixed(2),
            teamId: this.teamId || '‚Äî',
            coordination: this._coordinationScore.toFixed(2),
            allyAssist: this._lastAllyAssist > 0 ? 'YES' : 'NO',
            teamWins: metrics.teamWins,
            lr: this.cortex.lr.toFixed(4),            empathy: empathyAcc.toFixed(2),
            memConf: memConf.toFixed(2),
            imagination: this._imaginationScore.toFixed(1)
        };
    }
    
    toJSON() {
        return {
            id: this.id, seed: this.seed, x: this.x, y: this.y, health: this.health,
            stats: this.stats, lastMutationType: this.lastMutationType,
            cumulativeReward: this.cumulativeReward, wins: this.wins,
            totalKills: this.totalKills, deaths: this.deaths, mutations: this.mutations,
            generation: this.generation, teamId: this.teamId, weaponType: this.weaponType,
            cortex: this.cortex.toJSON(),
            adapter: this.adapter.getMetadata(),
            arbiter: { currentMode: this.arbiter.currentMode, history: this.arbiter.getHistory() },
            permanent: {
                skills: this.permanent.skills,
                strategies: this.permanent.strategies,
                preferences: this.permanent.preferences,
                muscleMemory: Array.from(this.permanent.muscleMemory),
                memory: {
                    lastFoodPos: this.permanent.memory.lastFoodPos,
                    lastFoodStep: this.permanent.memory.lastFoodStep,
                    visited: Array.from(this.permanent.memory.visited).slice(0, 100),
                    unvisited: this.permanent.memory.unvisited.slice(0, 30),
                    _maxVisited: this.permanent.memory._maxVisited
                }
            },
            predictive: {
                confidence: this.predictive.confidence,
                predictionError: this.predictive.predictionError
            },
            skillEmbedding: this.skillEmbedding.slice(),
            strategyMemory: {
                winningStrategies: this.strategyMemory.winningStrategies.slice(0, 5),
                fightHistory: this.strategyMemory.fightHistory
            },
            socialMemory: {
                interactions: Array.from(this.socialMemory.interactions.entries()).map(([k, v]) => [k, { ...v }]),
                reputation: this.socialMemory.reputation,
                lastAggressor: this.socialMemory.lastAggressor,
                allies: [...this.socialMemory.allies],
                killerHistory: this.socialMemory.killerHistory
            },
            evolutionPoints: this.evolutionPoints,
            statChoices: [...this.statChoices],
            _lastHitDealt: this._lastHitDealt,
            _knockbackVelocity: this._knockbackVelocity,
            _stunTimer: this._stunTimer,            _forcedCombatTimer: this._forcedCombatTimer,
            _learnFromWinner: this._learnFromWinner,
            _lastKiller: this._lastKiller,
            _deathMode: this._deathMode,
            _lastAttackDir: this._lastAttackDir,
            _recentArcExposure: this._recentArcExposure,
            _inEnemyArc: this._inEnemyArc,
            _lastThreatAssessment: this._lastThreatAssessment,
            _totalDamageDealt: this._totalDamageDealt,
            _totalAttacks: this._totalAttacks,
            _successfulHits: this._successfulHits,
            _tacticalHits: this._tacticalHits,
            _frontalHits: this._frontalHits,
            _coordinationScore: this._coordinationScore,
            _lastAllyAssist: this._lastAllyAssist,
            empathyStats: {
                total: this.empathyStats.total,
                correct: this.empathyStats.correct,
                byEnemy: Array.from(this.empathyStats.byEnemy.entries())
            },
            _lastPrediction: this._lastPrediction,
            _empathyTrust: this._empathyTrust,
            _ignoreEmpathyFor: this._ignoreEmpathyFor,
            _forcedExploration: this._forcedExploration,
            _imaginationScore: this._imaginationScore,
            _warnedAlly: this._warnedAlly,
            _sharedThreat: this._sharedThreat,
            _threatDirection: this._threatDirection
        };
    }
    
    static fromJSON(data, color, config = null) {
        const agent = new Agent(data.id, data.x, data.y, color, data.seed, data.weaponType || 'hammer', data.teamId || null, config);
        agent.cortex = Cortex2Brain.fromJSON(data.cortex);
        agent.health = data.health ?? 100;
        agent.stats = data.stats || { maxHealth: 100, damage: 3, fireRate: 15, dodgeChance: 0.0 };
        agent.lastMutationType = data.lastMutationType || null;
        agent.cumulativeReward = data.cumulativeReward ?? 5;
        agent.wins = data.wins ?? 0;
        agent.totalKills = data.totalKills ?? 0;
        agent.deaths = data.deaths ?? 0;
        agent.mutations = data.mutations ?? 0;
        agent.generation = data.generation ?? 1;
        
        if (data.permanent) {
            agent.permanent.skills = { ...(data.permanent.skills || agent.permanent.skills) };
            agent.permanent.strategies = { ...(data.permanent.strategies || agent.permanent.strategies) };
            agent.permanent.preferences = { ...(data.permanent.preferences || agent.permanent.preferences) };
            if (data.permanent.muscleMemory) agent.permanent.muscleMemory = new Float32Array(data.permanent.muscleMemory);
            if (data.permanent.memory) {                agent.permanent.memory.lastFoodPos = data.permanent.memory.lastFoodPos;
                agent.permanent.memory.lastFoodStep = data.permanent.memory.lastFoodStep || 0;
                agent.permanent.memory.visited = new Set(data.permanent.memory.visited || []);
                agent.permanent.memory.unvisited = data.permanent.memory.unvisited || [];
                agent.permanent.memory._maxVisited = data.permanent.memory._maxVisited || CONFIG.MEMORY.MAX_VISITED_CELLS;
            }
        }
        
        if (data.strategyMemory) {
            agent.strategyMemory.winningStrategies = data.strategyMemory.winningStrategies || [];
            agent.strategyMemory.fightHistory = data.strategyMemory.fightHistory || {};
        }
        
        if (data.predictive) {
            agent.predictive.confidence = data.predictive.confidence ?? 0.5;
            agent.predictive.predictionError = data.predictive.predictionError ?? 0;
        }
        
        if (data.skillEmbedding) agent.skillEmbedding = data.skillEmbedding.slice();
        
        if (data.socialMemory) {
            agent.socialMemory.interactions = new Map(data.socialMemory.interactions || []);
            agent.socialMemory.reputation = data.socialMemory.reputation ?? 0;
            agent.socialMemory.lastAggressor = data.socialMemory.lastAggressor || null;
            agent.socialMemory.allies = data.socialMemory.allies || [];
            agent.socialMemory.killerHistory = data.socialMemory.killerHistory || [];
        }
        
        if (data.evolutionPoints !== undefined) agent.evolutionPoints = data.evolutionPoints;
        if (data.statChoices) agent.statChoices = [...data.statChoices];
        
        // Restore internal state
        if (data._lastHitDealt !== undefined) agent._lastHitDealt = data._lastHitDealt;
        if (data._knockbackVelocity) agent._knockbackVelocity = { ...data._knockbackVelocity };
        if (data._stunTimer !== undefined) agent._stunTimer = data._stunTimer;
        if (data._forcedCombatTimer !== undefined) agent._forcedCombatTimer = data._forcedCombatTimer;
        if (data._learnFromWinner !== undefined) agent._learnFromWinner = data._learnFromWinner;
        if (data._lastKiller) agent._lastKiller = data._lastKiller;
        if (data._deathMode) agent._deathMode = data._deathMode;
        if (data._lastAttackDir !== undefined) agent._lastAttackDir = data._lastAttackDir;
        if (data._recentArcExposure) agent._recentArcExposure = [...data._recentArcExposure];
        if (data._inEnemyArc !== undefined) agent._inEnemyArc = data._inEnemyArc;
        if (data._lastThreatAssessment) agent._lastThreatAssessment = { ...data._lastThreatAssessment };
        if (data._totalDamageDealt !== undefined) agent._totalDamageDealt = data._totalDamageDealt;
        if (data._totalAttacks !== undefined) agent._totalAttacks = data._totalAttacks;
        if (data._successfulHits !== undefined) agent._successfulHits = data._successfulHits;
        if (data._tacticalHits !== undefined) agent._tacticalHits = data._tacticalHits;
        if (data._frontalHits !== undefined) agent._frontalHits = data._frontalHits;
        if (data._coordinationScore !== undefined) agent._coordinationScore = data._coordinationScore;
        if (data._lastAllyAssist !== undefined) agent._lastAllyAssist = data._lastAllyAssist;        
        if (data.empathyStats) {
            agent.empathyStats.total = data.empathyStats.total || 0;
            agent.empathyStats.correct = data.empathyStats.correct || 0;
            agent.empathyStats.byEnemy = new Map(data.empathyStats.byEnemy || []);
        }
        
        if (data._lastPrediction) agent._lastPrediction = data._lastPrediction;
        if (data._empathyTrust !== undefined) agent._empathyTrust = data._empathyTrust;
        if (data._ignoreEmpathyFor) agent._ignoreEmpathyFor = { ...data._ignoreEmpathyFor };
        if (data._forcedExploration !== undefined) agent._forcedExploration = data._forcedExploration;
        if (data._imaginationScore !== undefined) agent._imaginationScore = data._imaginationScore;
        if (data._warnedAlly !== undefined) agent._warnedAlly = data._warnedAlly;
        if (data._sharedThreat) agent._sharedThreat = data._sharedThreat;
        if (data._threatDirection) agent._threatDirection = data._threatDirection;
        
        if (data.teamId) agent.teamId = data.teamId;
        if (data.arbiter?.currentMode) agent.arbiter.currentMode = data.arbiter.currentMode;
        
        return agent;
    }
}

// ============================================================================
// WORLD ‚Äî Complete team win logic, race condition fixed
// ============================================================================
class World {
    constructor(width, height, config = null) {
        this.config = config || window.arenaConfig;
        this.logicalWidth = width;
        this.logicalHeight = height;
        this.step = 0;
        this.episode = 0;
        this.totalFights = 0;
        this.walls = [];
        this.enemies = [];
        this.projectiles = [];
        this.teamWins = { blue: 0, red: 0, green: 0, yellow: 0 };
        this.episodeInProgress = true;
    }
    
    reset() {
        this.step = 0;
        this.walls = [];
        for (let i = 0; i < 12; i++) {
            this.walls.push({
                x: 60 + Utils.rand(this.config._rng, 0, this.logicalWidth - 120),
                y: 60 + Utils.rand(this.config._rng, 0, this.logicalHeight - 120)
            });
        }        this.projectiles = [];
        this.episodeInProgress = true;
    }
    
    spawnAgents(mode = '1v1', weaponMap = {}) {
        this.enemies = [];
        const spawnPositions = {
            '1v1': [
                { x: 150, y: 150, team: null },
                { x: this.logicalWidth - 150, y: this.logicalHeight - 150, team: null }
            ],
            '2v2': [
                { x: 100, y: 150, team: 'blue' },
                { x: 150, y: 200, team: 'blue' },
                { x: this.logicalWidth - 150, y: this.logicalHeight - 150, team: 'red' },
                { x: this.logicalWidth - 100, y: this.logicalHeight - 200, team: 'red' }
            ],
            '4way': [
                { x: 150, y: 150, team: 'blue' },
                { x: this.logicalWidth - 150, y: 150, team: 'red' },
                { x: 150, y: this.logicalHeight - 150, team: 'green' },
                { x: this.logicalWidth - 150, y: this.logicalHeight - 150, team: 'yellow' }
            ]
        };
        
        const positions = spawnPositions[mode] || spawnPositions['1v1'];
        const maxAgents = this.config?.GAME?.maxAgents?.[mode] || 2;
        
        for (let i = 0; i < Math.min(maxAgents, positions.length); i++) {
            const pos = positions[i];
            const uniqueSeed = `${this.config.seed}_AGENT${i}_${this.config._rng?.next().toString(36).slice(2,10)}`;
            const weapon = weaponMap[pos.team || `agent${i}`] || 'hammer';
            
            let color;
            if (pos.team) {
                color = this.config?.GAME?.teamColors?.[pos.team] || '#fff';
            } else {
                const defaultColors = ['#00d4ff', '#ff5577', '#00ff9d', '#ffdd44'];
                color = defaultColors[i % defaultColors.length];
            }
            
            const agentId = pos.team || `agent${i}`;
            const teamId = pos.team || null;
            
            const agent = new Agent(agentId, pos.x, pos.y, color, uniqueSeed, weapon, teamId, this.config);
            agent.stats.maxHealth = 100;
            agent.stats.damage = 3;
            agent.stats.fireRate = 15;
            agent.stats.dodgeChance = 0.0;
                        this.enemies.push(agent);
        }
        
        for (const agent of this.enemies) {
            if (agent.teamId) agent.updateAllies(this);
        }
    }
    
    _selectBestTarget(agent, opponents) {
        if (!opponents?.length) return null;
        return opponents.reduce((best, enemy) => {
            const dist = Utils.dist(agent, enemy);
            const healthRatio = enemy.health / enemy.stats.maxHealth;
            const threatScore = (1 - healthRatio) * 0.6 + (150 - Math.min(dist, 150)) / 150 * 0.4;
            const bestDist = Utils.dist(agent, best);
            const bestHealth = best.health / best.stats.maxHealth;
            const bestThreat = (1 - bestHealth) * 0.6 + (150 - Math.min(bestDist, 150)) / 150 * 0.4;
            return threatScore > bestThreat ? enemy : best;
        });
    }
    
    _resolveAgentCollisions(dt) {
        const COLLISION_RADIUS = CONFIG.PHYSICS.AGENT_COLLISION_RADIUS;
        const REPULSION_STRENGTH = CONFIG.PHYSICS.AGENT_REPULSION_STRENGTH;
        const MIN_SEPARATION = COLLISION_RADIUS * 2 + 4;
        const MAX_V = CONFIG.PHYSICS.MAX_VELOCITY;
        
        // ‚úÖ Spatial grid optimization for O(n) collision detection
        const grid = new Map();
        const cellSize = 200;
        
        // Populate grid
        for (const agent of this.enemies) {
            if (!agent || !agent.alive) continue;
            const key = `${Math.floor(agent.x/cellSize)},${Math.floor(agent.y/cellSize)}`;
            if (!grid.has(key)) grid.set(key, []);
            grid.get(key).push(agent);
        }
        
        // Check only neighbors
        for (const agents of grid.values()) {
            for (let i = 0; i < agents.length; i++) {
                const agentA = agents[i];
                for (let j = i + 1; j < agents.length; j++) {
                    const agentB = agents[j];
                    if (!agentB || !agentB.alive) continue;
                    
                    const isAlly = agentA.teamId && agentA.teamId === agentB.teamId;
                    const repulsion = isAlly ? REPULSION_STRENGTH * 0.3 : REPULSION_STRENGTH;
                                        const dx = agentB.x - agentA.x, dy = agentB.y - agentA.y;
                    const dist = Math.hypot(dx, dy);
                    
                    if (dist < MIN_SEPARATION && dist > 0) {
                        const overlap = MIN_SEPARATION - dist;
                        const pushX = (dx / dist) * overlap * 0.5, pushY = (dy / dist) * overlap * 0.5;
                        agentA.x -= pushX; agentA.y -= pushY;
                        agentB.x += pushX; agentB.y += pushY;
                        
                        const repulseX = (dx / dist) * repulsion, repulseY = (dy / dist) * repulsion;
                        agentA.vx -= repulseX * dt; agentA.vy -= repulseY * dt;
                        agentB.vx += repulseX * dt; agentB.vy += repulseY * dt;
                        
                        agentA.vx = Utils.clamp(agentA.vx, -MAX_V, MAX_V);
                        agentA.vy = Utils.clamp(agentA.vy, -MAX_V, MAX_V);
                        agentB.vx = Utils.clamp(agentB.vx, -MAX_V, MAX_V);
                        agentB.vy = Utils.clamp(agentB.vy, -MAX_V, MAX_V);
                    }
                }
            }
        }
    }
    
    update(dt) {
        if (!this.enemies || this.enemies.length === 0) {
            console.error('World.update: No agents in world');
            return { episode: this.episode, totalFights: this.totalFights, winner: null };
        }
        
        this.step++;
        if (!this.enemies?.length || this.enemies.length < 2) {
            console.error('World.update: Invalid agents');
            return { episode: this.episode, totalFights: this.totalFights, winner: null };
        }
        
        // Check win condition first
        if (this.episodeInProgress) {
            const winResult = Utils.checkTeamWin(this);
            if (winResult) {
                this._endEpisode(winResult);
                return { episode: this.episode, totalFights: this.totalFights, winner: winResult.winner };
            }
        }
        
        for (const agent of this.enemies) {
            if (!this.episodeInProgress) break;
            if (!agent || !agent.alive) continue;
            
            // Status effect timers
            if (agent._heavyHit > 0) agent._heavyHit--;            if (agent._pierced > 0) agent._pierced--;
            if (agent._pulseEffect > 0) agent._pulseEffect--;
            if (agent._continuousKB > 0) agent._continuousKB = Math.max(0, agent._continuousKB - 0.03);
            
            // Enemy prediction
            const enemies = Utils.getEnemies(agent, this);
            if (enemies.length > 0) {
                const enemy = enemies[0];
                const distance = Utils.dist(agent, enemy);
                if (distance < 150) {
                    agent.enemyPredictor.recordMove(
                        agent.lastDecision?.behaviors || {},
                        distance,
                        enemy.health / enemy.stats.maxHealth,
                        agent.lastDecision?.behaviors?.aggression || 0.5
                    );
                    if (distance < 100) {
                        agent.decideCombatAction?.(enemy, this);
                    }
                }
            }
            
            // Decision and movement
            const decision = agent.decide(this);
            agent.move(decision.target, decision.speed, this.walls, dt, decision.output);
            agent.attackCooldown = Math.max(0, (agent.attackCooldown || 0) - 1);
            
            // Combat logic
            if (this.config?.enableFighting) {
                const opponents = Utils.getEnemies(agent, this);
                if (opponents.length > 0) {
                    const enemy = this._selectBestTarget(agent, opponents);
                    if (!enemy) continue;
                    
                    const dist = Utils.dist(agent, enemy);
                    const range = agent.attackRange || Agent.ATTACK_RANGE;
                    
                    if (dist <= range && (agent.attackCooldown || 0) <= 0) {
                        // Arc check for melee
                        if (!agent.isPointInWeaponArc(enemy)) {
                            agent.attackCooldown = Math.floor(agent.stats.fireRate * 0.4);
                            continue;
                        }
                        
                        this.totalFights++;
                        const aggression = agent.lastDecision?.behaviors?.aggression || 0.5;
                        const skill = agent.permanent?.skills?.combat || 0.3;
                        const baseDmg = agent.stats.damage;
                        
                        const directionalMult = enemy.calculateDirectionalDamageMultiplier(agent);                        const damage = Math.floor(Utils.clamp(
                            baseDmg * (0.8 + aggression * 0.4) * (0.7 + skill * 0.6) * directionalMult,
                            1, 15
                        ));
                        
                        const dodgeRoll = agent.cortex._rng.next();
                        if (dodgeRoll < enemy.stats.dodgeChance) {
                            // Dodged
                        } else {
                            enemy.health -= damage;
                            enemy._lastHitReceived = damage;
                            agent._lastHitDealt = damage;
                            agent._totalAttacks++;
                            agent._totalDamageDealt += damage;
                            agent._successfulHits++;
                            
                            if (directionalMult >= 1.5) agent._tacticalHits++;
                            else if (directionalMult <= 0.7) agent._frontalHits++;
                            
                            agent._lastAttackDir = Math.atan2(enemy.y - agent.y, enemy.x - agent.x);
                            agent._applyKnockback(enemy, aggression, agent.weapon);
                            
                            if (enemy.health <= 0) {
                                enemy.health = 0;
                                enemy.alive = false;
                                if (this.episodeInProgress) {
                                    const winResult = Utils.checkTeamWin(this);
                                    if (winResult) {
                                        this._endEpisode(winResult);
                                        return { episode: this.episode, totalFights: this.totalFights, winner: winResult.winner };
                                    }
                                }
                            }
                        }
                        agent.attackCooldown = agent.stats.fireRate;
                    }
                    // Ranged attack
                    else if (this.config?.enableRanged && (agent.attackCooldown || 0) <= 0) {
                        if (agent.weapon.type === 'ranged') {
                            const aggr = agent.lastDecision?.behaviors?.aggression || 0.4;
                            if (aggr > 0.3 && dist > range && dist <= 200) {
                                const dir = Utils.normalize(enemy.x - agent.x, enemy.y - agent.y);
                                const speed = 10 + agent.cortex._rng.next() * 4;
                                const dmg = Math.floor(Utils.clamp(agent.stats.damage * 0.5 * (0.8 + aggr * 0.8), 1, 5));
                                const p = new Projectile(
                                    agent.x + dir.x * 12,
                                    agent.y + dir.y * 12,
                                    dir.x * speed,
                                    dir.y * speed,
                                    agent.id,                                    dmg,
                                    80
                                );
                                this.projectiles.push(p);
                                agent.attackCooldown = agent.stats.fireRate + 5;
                            }
                        }
                    }
                }
            }
            
            // Learning
            const reward = agent.calculateReward(this, decision);
            const nextInputs = agent.getInputs(this);
            agent.learn(reward, decision, nextInputs);
            
            // Empathy validation
            if (this.config?.enableDeepCognition && this.step % (this.config?.COGNITION?.empathyValidationSteps || 10) === 0) {
                agent.validateLastPrediction?.();
            }
        }
        
        // Agent collisions
        this._resolveAgentCollisions(dt);
        
        // Projectiles
        for (const p of this.projectiles) {
            if (!p?.alive) continue;
            p.update(dt);
            
            // Wall collision
            for (const w of this.walls) {
                if (Utils.dist(p, w) < 14 + p.radius) {
                    p.alive = false;
                    break;
                }
            }
            if (!p.alive) continue;
            
            // Enemy collision
            for (const e of this.enemies) {
                if (!e || !e.alive || e.id === p.owner) continue;
                const ownerAgent = this.enemies.find(a => a && a.id === p.owner);
                if (!ownerAgent) { p.alive = false; continue; }
                
                if (Utils.dist(p, e) < 15) {
                    const dodgeRoll = e.cortex._rng.next();
                    if (dodgeRoll >= e.stats.dodgeChance) {
                        e.health -= p.damage;
                        e._lastHitReceived = p.damage;                    }
                    p.alive = false;
                    
                    if (e.health <= 0) {
                        e.health = 0;
                        e.alive = false;
                        if (this.episodeInProgress) {
                            const winResult = Utils.checkTeamWin(this);
                            if (winResult) {
                                this._endEpisode(winResult);
                                return { episode: this.episode, totalFights: this.totalFights, winner: winResult.winner };
                            }
                        }
                    }
                    break;
                }
            }
        }
        this.projectiles = this.projectiles.filter(p => p?.alive);
        
        return { episode: this.episode, totalFights: this.totalFights, winner: null };
    }
    
    _endEpisode(winResult) {
        this.episodeInProgress = false;
        this.episode++;
        this.teamWins[winResult.winner] = (this.teamWins[winResult.winner] || 0) + 1;
        
        const winningTeam = this.enemies.filter(a => a?.teamId === winResult.winner);
        winningTeam.forEach(a => { if (a && a.alive) { a.wins++; } });
        
        if (window.arenaGame) {
            window.arenaGame.showWinnerBanner(winResult.winner, winResult.type);
        }
        
        Logger.log(`üèÜ –ü–û–ë–ï–î–ê: ${winResult.winner.toUpperCase()} (${winResult.type})`, 'success');
        
        setTimeout(() => {
            if (window.arenaGame) window.arenaGame.resetEpisode();
        }, 3000);
    }
    
    resetEpisode() {
        const banner = document.getElementById('winnerBanner');
        if (banner) banner.classList.remove('active');
        
        const mode = this.config?.GAME?.currentMode || '1v1';
        const spawnPositions = {
            '1v1': [
                { x: 150, y: 150, team: null },                { x: this.logicalWidth - 150, y: this.logicalHeight - 150, team: null }
            ],
            '2v2': [
                { x: 100, y: 150, team: 'blue' },
                { x: 150, y: 200, team: 'blue' },
                { x: this.logicalWidth - 150, y: this.logicalHeight - 150, team: 'red' },
                { x: this.logicalWidth - 100, y: this.logicalHeight - 200, team: 'red' }
            ],
            '4way': [
                { x: 150, y: 150, team: 'blue' },
                { x: this.logicalWidth - 150, y: 150, team: 'red' },
                { x: 150, y: this.logicalHeight - 150, team: 'green' },
                { x: this.logicalWidth - 150, y: this.logicalHeight - 150, team: 'yellow' }
            ]
        };
        const positions = spawnPositions[mode] || spawnPositions['1v1'];
        
        for (let i = 0; i < this.enemies.length; i++) {
            const agent = this.enemies[i];
            const pos = positions[i];
            if (agent && pos) {
                agent.reset(pos.x, pos.y);
                agent.alive = true;
                agent.teamId = pos.team || null;
                if (agent.teamId) agent.updateAllies(this);
                else agent.allies = [];
            }
        }
        
        this.enemies.forEach(a => a?.cortex?.resetEpisode?.());
        this.episodeInProgress = true;
        Logger.log(`üîÑ –ù–æ–≤—ã–π —ç–ø–∏–∑–æ–¥ ${this.episode}`, 'info');
    }
    
    draw(ctx, vision = false, trail = true) {
        if (!ctx) return;
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        
        // Background gradient
        const grad = ctx.createLinearGradient(0, 0, this.logicalWidth, this.logicalHeight);
        grad.addColorStop(0, '#0a0a15');
        grad.addColorStop(1, '#1a1a2e');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, this.logicalWidth, this.logicalHeight);
        
        // Grid
        ctx.strokeStyle = 'rgba(50,50,90,0.25)';
        ctx.lineWidth = 1;
        for (let x = 0; x < this.logicalWidth; x += 50) {
            ctx.beginPath();            ctx.moveTo(x, 0);
            ctx.lineTo(x, this.logicalHeight);
            ctx.stroke();
        }
        for (let y = 0; y < this.logicalHeight; y += 50) {
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(this.logicalWidth, y);
            ctx.stroke();
        }
        
        // Walls
        ctx.fillStyle = '#4a4a7a';
        for (const w of this.walls) {
            ctx.beginPath();
            ctx.arc(w.x, w.y, 14, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#6a6a9a';
            ctx.lineWidth = 2;
            ctx.stroke();
        }
        
        // Projectiles
        for (const pr of this.projectiles || []) {
            if (pr) pr.draw(ctx);
        }
        
        // Agents
        for (const a of this.enemies) {
            if (a) a.draw(ctx, vision, trail);
        }
        
        // HUD
        ctx.fillStyle = 'rgba(100,100,140,0.5)';
        ctx.font = '10px monospace';
        ctx.fillText(`Step: ${this.step} | Ep: ${this.episode} | Fights: ${this.totalFights}`, 12, this.logicalHeight - 12);
    }
}

// ============================================================================
// PROJECTILE ‚Äî Lightweight
// ============================================================================
class Projectile {
    constructor(x, y, vx, vy, owner, damage = 3, life = 80) {
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
        this.owner = owner;
        this.damage = damage;        this.life = life;
        this.alive = true;
        this.radius = 3;
    }
    
    update(dt) {
        this.x += this.vx * dt * 8;
        this.y += this.vy * dt * 8;
        this.life -= dt;
        if (this.life <= 0) this.alive = false;
    }
    
    draw(ctx) {
        if (!this.alive) return;
        ctx.fillStyle = '#ffdd44';
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
    }
}

// ============================================================================
// GAME ENGINE v5.0.1 ‚Äî CORTEX2BRAIN Integrated
// ============================================================================
class GameEngine {
    constructor(config = null) {
        this.config = config || window.arenaConfig;
        this.canvas = document.getElementById('gameCanvas');
        if (!this.canvas) {
            console.error('Canvas not found');
            alert('–û—à–∏–±–∫–∞: Canvas —ç–ª–µ–º–µ–Ω—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω!');
            return;
        }
        this.ctx = this.canvas.getContext('2d');
        if (!this.ctx) {
            console.error('Failed to get canvas context');
            alert('–û—à–∏–±–∫–∞: –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∫–æ–Ω—Ç–µ–∫—Å—Ç canvas!');
            return;
        }
        
        this.settings = { ...this.config };
        this.logicalWidth = CONFIG.GAME.LOGICAL_WIDTH;
        this.logicalHeight = CONFIG.GAME.LOGICAL_HEIGHT;
        
        this.resize();
        this.world = new World(this.logicalWidth, this.logicalHeight, this.config);
        
        this.running = false;
        this.lastTime = 0;
        this.fps = 60;        this.vision = false;
        this.debug = false;
        this.showMetrics = true;
        
        this.selectedAgent = null;
        this.rafId = null;
        
        this._onResize = this._onResize.bind(this);
        this._onClick = this._onClick.bind(this);
        this._onKey = this._onKey.bind(this);
        this._onTouchStart = this._onTouchStart.bind(this);
        
        this.setupEvents();
        this.init();
    }
    
    resize() {
        const parent = this.canvas?.parentElement;
        if (!parent) return;
        const dpr = window.devicePixelRatio || 1;
        this.canvas.width = parent.clientWidth * dpr;
        this.canvas.height = parent.clientHeight * dpr;
        this.ctx.scale(dpr, dpr);
        this.scaleX = (parent.clientWidth * dpr) / this.logicalWidth;
        this.scaleY = (parent.clientHeight * dpr) / this.logicalHeight;
    }
    
    _onResize() {
        this.resize();
    }
    
    _debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    }
    
    _onTouchStart(e) {
        e.preventDefault();
    }
    
    setupEvents() {
        const debouncedResize = this._debounce(this._onResize, 150);
        window.addEventListener('resize', debouncedResize);        
        const handlePointer = (e) => {
            const rect = this.canvas.getBoundingClientRect();
            const scaleX = this.canvas.width / rect.width;
            const scaleY = this.canvas.height / rect.height;
            const clientX = e.touches?.[0]?.clientX ?? e.clientX;
            const clientY = e.touches?.[0]?.clientY ?? e.clientY;
            const x = (clientX - rect.left) * scaleX;
            const y = (clientY - rect.top) * scaleY;
            this._onClick({ x, y });
        };
        
        this.canvas.addEventListener('click', handlePointer);
        this.canvas.addEventListener('touchend', handlePointer);
        this.canvas.addEventListener('touchstart', this._onTouchStart, { passive: false });
        
        document.addEventListener('keydown', this._onKey);
        this.canvas.setAttribute('tabindex', '0');
        this.canvas.setAttribute('role', 'application');
        this.canvas.setAttribute('aria-label', 'AI Arena simulation canvas');
        
        const bindClick = (id, handler) => {
            const btn = document.getElementById(id);
            if (btn) btn.addEventListener('click', handler);
        };
        
        bindClick('btnStart', () => this.toggle());
        bindClick('btnReset', () => this.reset());
        bindClick('btnSave', () => this.save());
        bindClick('btnLoad', () => this.load());
        bindClick('btnExport', () => this.exportWeights());
        bindClick('btnImport', () => document.getElementById('fileImport')?.click());
        bindClick('btnDebug', () => this.toggleDebug());
        bindClick('btnVision', () => { this.vision = !this.vision; this.updateBtns(); });
        bindClick('btnApplyWeapons', () => this.applyWeapons());
        bindClick('btnRandomWeapons', () => this.randomWeapons());
        
        const fileImport = document.getElementById('fileImport');
        if (fileImport) {
            fileImport.addEventListener('change', (e) => this.importWeights(e));
        }
        
        const bindSlider = (id, key, displayId) => {
            const slider = document.getElementById(id);
            const display = document.getElementById(displayId);
            if (!slider || !display) return;
            slider.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                this.settings[key] = value;
                display.textContent = value;                if (this.world?.enemies) {
                    this.world.enemies.forEach(a => {
                        if (a?.cortex) {
                            a.cortex.lr = this.settings.learningRate;
                            a.cortex.lambda = this.settings.lambda;
                            a.cortex.gamma = this.settings.gamma;
                        }
                    });
                }
            });
        };
        
        bindSlider('learningRate', 'learningRate', 'learningRateValue');
        bindSlider('lambda', 'lambda', 'lambdaValue');
        bindSlider('mutationRate', 'mutationRate', 'mutationRateValue');
        bindSlider('policyTemp', 'policyTemperature', 'policyTempValue');
        
        const bindToggle = (id, key) => {
            const toggle = document.getElementById(id);
            if (toggle) {
                toggle.addEventListener('change', (e) => {
                    this.settings[key] = e.target.checked;
                });
            }
        };
        
        bindToggle('enableTraining', 'enableTraining');
        bindToggle('enableEvolution', 'enableEvolution');
        bindToggle('enableFighting', 'enableFighting');
        bindToggle('enableRanged', 'enableRanged');
        bindToggle('enableWeightInheritance', 'enableWeightInheritance');
        bindToggle('enableTactical', 'enableTactical');
        bindToggle('enableTeamwork', 'enableTeamwork');
        bindToggle('enableDeepCognition', 'enableDeepCognition');
        
        const modeSelect = document.getElementById('gameModeSelect');
        if (modeSelect) {
            modeSelect.value = this.config?.GAME?.currentMode || '1v1';
            modeSelect.addEventListener('change', (e) => {
                try {
                    const newMode = e.target.value;
                    if (!this.config || !this.config.GAME) throw new Error('Config is undefined');
                    this.config.GAME.currentMode = newMode;
                    if (this.settings && this.settings.GAME) this.settings.GAME.currentMode = newMode;
                    this.reset();
                    Logger.log(`üéÆ –†–µ–∂–∏–º –∏–∑–º–µ–Ω–µ–Ω –Ω–∞: ${newMode}`, 'success');
                } catch (err) {
                    console.error('‚ùå Mode change failed:', err);
                    Logger.log(`‚ùå –û—à–∏–±–∫–∞ —Å–º–µ–Ω—ã —Ä–µ–∂–∏–º–∞: ${err.message}`, 'error');
                    modeSelect.value = this.config?.GAME?.currentMode || '1v1';                }
            });
        }
    }
    
    _onKey(e) {
        if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code)) {
            e.preventDefault();
        }
        switch (e.key) {
            case ' ':
                e.preventDefault();
                this.toggle();
                break;
            case '1':
                this.selectedAgent = this.world?.enemies?.[0];
                this.updateDebugPanel();
                break;
            case '2':
                this.selectedAgent = this.world?.enemies?.[1];
                this.updateDebugPanel();
                break;
            case '3':
                this.selectedAgent = this.world?.enemies?.[2];
                this.updateDebugPanel();
                break;
            case '4':
                this.selectedAgent = this.world?.enemies?.[3];
                this.updateDebugPanel();
                break;
            case 'Tab':
                e.preventDefault();
                const focusable = document.querySelectorAll('button, input, [tabindex="0"]');
                const idx = Array.from(focusable).indexOf(document.activeElement);
                focusable[(idx + 1) % focusable.length]?.focus();
                break;
            case 'Escape':
                if (this.debug) {
                    this.debug = false;
                    this.updateDebugPanel();
                }
                break;
        }
    }
    
    _onClick({ x, y }) {
        if (!this.debug) return;
        const lx = x / this.scaleX;
        const ly = y / this.scaleY;
        let nearest = null;        let minD = 25;
        for (const a of this.world?.enemies || []) {
            if (!a) continue;
            const d = Math.hypot(a.x - lx, a.y - ly);
            if (d < minD) {
                minD = d;
                nearest = a;
            }
        }
        this.selectedAgent = nearest;
        if (nearest) {
            Logger.log(`üîç –í—ã–±—Ä–∞–Ω –∞–≥–µ–Ω—Ç ${nearest.id}`, 'info');
        }
        this.updateDebugPanel();
    }
    
    updateUI() {
        const mode = this.config?.GAME?.currentMode || '1v1';
        const maxAgents = this.config?.GAME?.maxAgents?.[mode] || 2;
        const container = document.getElementById('agentsContainer');
        const weaponControls = document.getElementById('weaponControls');
        const teamStatus = document.getElementById('teamStatus');
        
        if (!container || !weaponControls) return;
        
        // Team status panel
        if (teamStatus && this.world) {
            const teams = Utils.getAllTeams(this.world);
            teamStatus.innerHTML = teams.map(teamId => {
                const alive = Utils.getTeamAliveCount(teamId, this.world);
                const total = this.world.enemies.filter(a => a?.teamId === teamId).length;
                const color = this.config?.GAME?.teamColors?.[teamId];
                return `<div class="team-status-item ${teamId}">
                    <span style="color:${color};font-weight:700">${teamId.toUpperCase()}</span>
                    <span class="team-status-count">${alive}/${total}</span>
                    <span class="${alive > 0 ? 'team-status-alive' : 'team-status-dead'}">‚óè</span>
                </div>`;
            }).join('');
        }
        
        container.innerHTML = '';
        weaponControls.innerHTML = '';
        
        for (let i = 0; i < maxAgents; i++) {
            const agent = this.world?.enemies?.[i];
            const teamColor = agent?.teamId ? this.config?.GAME?.teamColors?.[agent.teamId] : agent?.color || '#fff';
            const teamBadge = agent?.teamId ? `<span class="team-badge ${agent.teamId}">${agent.teamId.toUpperCase()}</span>` : '';
            
            const card = document.createElement('article');
            card.className = `agent-card team-${agent?.teamId || 'blue'}${!agent?.alive ? ' dead' : ''}`;            card.innerHTML = `
                <header class="agent-header">
                    <span style="color:${teamColor}">‚óè</span> ${agent?.id?.toUpperCase() || `AGENT${i+1}`} ${teamBadge}
                    <span class="mode-badge mode-${agent?.mode || 'combat'}" id="${agent?.id}-mode">${(agent?.mode || 'combat').toUpperCase()}</span>
                </header>
                <div class="health-bar">
                    <div class="health-fill" id="${agent?.id}-health" style="width:${agent?.alive ? (agent.health / agent.stats.maxHealth) * 100 : 0}%"></div>
                </div>
                <div class="agent-stats">
                    <span>Reward: <b id="${agent?.id}-reward">${agent?.cumulativeReward.toFixed(2) || '0.00'}</b></span>
                    <span>Wins: <b id="${agent?.id}-wins">${agent?.wins || 0}</b></span>
                    <span>Gen: <b id="${agent?.id}-gen">${agent?.generation || 1}</b></span>
                </div>
                <div style="font-size:0.5rem;margin-top:0.0625rem;color:var(--text-dim)">
                    <span class="stat-badge stat-hp" id="${agent?.id}-stat-hp">HP:${agent?.stats.maxHealth || 100}</span>
                    <span class="stat-badge stat-str" id="${agent?.id}-stat-dmg">DMG:${agent?.stats.damage || 3}</span>
                    <span class="stat-badge stat-spd" id="${agent?.id}-stat-spd">SPD:${agent?.stats.fireRate || 15}</span>
                    <span class="stat-badge stat-dod" id="${agent?.id}-stat-dod">DOD:${Math.round((agent?.stats.dodgeChance || 0) * 100)}%</span>
                </div>
                <div class="weapon-badge" id="${agent?.id}-weapon">${agent?.weapon?.icon || 'üî®'} ${agent?.weapon?.name?.toUpperCase() || 'HAMMER'}</div>
            `;
            container.appendChild(card);
            
            const weaponCtrl = document.createElement('div');
            weaponCtrl.className = 'control-group';
            weaponCtrl.innerHTML = `
                <label class="control-label">
                    <span style="color:${teamColor}">‚óè ${agent?.id?.toUpperCase() || `AGENT${i+1}`}</span>
                </label>
                <select id="${agent?.id}-weapon-select">
                    ${Object.entries(WEAPONS).map(([k,v]) =>
                        `<option value="${k}"${agent?.weaponType === k ? ' selected' : ''}>${v.icon} ${v.name}</option>`
                    ).join('')}
                </select>
            `;
            weaponControls.appendChild(weaponCtrl);
        }
    }
    
    init() {
        this.world.reset();
        const mode = this.config?.GAME?.currentMode || '1v1';
        const weaponMap = {};
        const positions = {
            '1v1': [
                { x: 150, y: 150, team: null },
                { x: this.logicalWidth - 150, y: this.logicalHeight - 150, team: null }
            ],
            '2v2': [
                { x: 100, y: 150, team: 'blue' },                { x: 150, y: 200, team: 'blue' },
                { x: this.logicalWidth - 150, y: this.logicalHeight - 150, team: 'red' },
                { x: this.logicalWidth - 100, y: this.logicalHeight - 200, team: 'red' }
            ],
            '4way': [
                { x: 150, y: 150, team: 'blue' },
                { x: this.logicalWidth - 150, y: 150, team: 'red' },
                { x: 150, y: this.logicalHeight - 150, team: 'green' },
                { x: this.logicalWidth - 150, y: this.logicalHeight - 150, team: 'yellow' }
            ]
        }[mode] || [
            { x: 150, y: 150, team: null },
            { x: this.logicalWidth - 150, y: this.logicalHeight - 150, team: null }
        ];
        
        const maxAgents = this.config?.GAME?.maxAgents?.[mode] || 2;
        for (let i = 0; i < Math.min(maxAgents, positions.length); i++) {
            const pos = positions[i];
            const agentKey = pos.team || `agent${i}`;
            weaponMap[agentKey] = 'hammer';
        }
        
        this.world.spawnAgents(mode, weaponMap);
        this.updateUI();
        
        this.world.enemies.forEach(a => {
            if (!a) return;
            if (a.cortex) {
                a.cortex.lr = this.settings.learningRate;
                a.cortex.lambda = this.settings.lambda;
                a.cortex.gamma = this.settings.gamma;
            }
        });
        
        this.updateStats();
        this.updateMetrics();
        if (this.world.enemies[0] && this.world.enemies[1]) {
            this.world.draw(this.ctx, false, true);
        }
        
        Logger.log('üöÄ AI ARENA v5.0.1 CORTEX2BRAIN Professional –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞', 'success');
        Logger.log(`üîß –†–µ–∂–∏–º: ${mode} (${this.config?.GAME?.maxAgents?.[mode]||2} –∞–≥–µ–Ω—Ç–æ–≤)`, 'success');
        Logger.log('üèÜ –ü–æ–±–µ–¥–∞ —Ç–æ–ª—å–∫–æ –ø—Ä–∏ —É—Å—Ç—Ä–∞–Ω–µ–Ω–∏–∏ –í–°–ï–ô –∫–æ–º–∞–Ω–¥—ã', 'success');
        Logger.log('üë• –ö–æ–º–∞–Ω–¥–Ω–∞—è –∏–≥—Ä–∞: –∫–æ–æ—Ä–¥–∏–Ω–∞—Ü–∏—è + –∑–∞—â–∏—Ç–∞ —Å–æ—é–∑–Ω–∏–∫–æ–≤', 'success');
        Logger.log('üß† CORTEX2BRAIN: Universal Neural Engine —Å BehaviorArbiter', 'success');
        Logger.log('üéØ –≠–º–æ—Ü–∏–∏ —Ä–µ–∞–ª—å–Ω–æ –≤–ª–∏—è—é—Ç –Ω–∞ –ø–æ–≤–µ–¥–µ–Ω–∏–µ —á–µ—Ä–µ–∑ 5 —Ä–µ–∂–∏–º–æ–≤', 'success');
    }
    
    toggle() {
        this.running = !this.running;        const btn = document.getElementById('btnStart');
        if (btn) {
            btn.textContent = this.running ? '‚è∏ –ü–∞—É–∑–∞' : '‚ñ∂ –°—Ç–∞—Ä—Ç';
            btn.className = this.running ? 'btn-danger' : 'btn-primary';
            btn.setAttribute('aria-pressed', String(this.running));
        }
        Logger.log(this.running ? '‚ñ∂ –°–∏–º—É–ª—è—Ü–∏—è –∑–∞–ø—É—â–µ–Ω–∞' : '‚è∏ –ü–∞—É–∑–∞', 'info');
        if (this.running) {
            this.lastTime = performance.now();
            this.loop();
        }
    }
    
    reset() {
        console.log('üîÑ GameEngine.reset() called');
        if (this.rafId) {
            cancelAnimationFrame(this.rafId);
            this.rafId = null;
            console.log('‚èπÔ∏è Cancelled animation frame');
        }
        this.running = false;
        const btn = document.getElementById('btnStart');
        if (btn) {
            btn.textContent = '‚ñ∂ –°—Ç–∞—Ä—Ç';
            btn.className = 'btn-primary';
            btn.setAttribute('aria-pressed', 'false');
        }
        
        const mode = this.config?.GAME?.currentMode || '1v1';
        const weaponMap = {};
        const positions = {
            '1v1': [
                { x: 150, y: 150, team: null },
                { x: this.logicalWidth - 150, y: this.logicalHeight - 150, team: null }
            ],
            '2v2': [
                { x: 100, y: 150, team: 'blue' },
                { x: 150, y: 200, team: 'blue' },
                { x: this.logicalWidth - 150, y: this.logicalHeight - 150, team: 'red' },
                { x: this.logicalWidth - 100, y: this.logicalHeight - 200, team: 'red' }
            ],
            '4way': [
                { x: 150, y: 150, team: 'blue' },
                { x: this.logicalWidth - 150, y: 150, team: 'red' },
                { x: 150, y: this.logicalHeight - 150, team: 'green' },
                { x: this.logicalWidth - 150, y: this.logicalHeight - 150, team: 'yellow' }
            ]
        }[mode] || [
            { x: 150, y: 150, team: null },
            { x: this.logicalWidth - 150, y: this.logicalHeight - 150, team: null }        ];
        
        const maxAgents = this.config?.GAME?.maxAgents?.[mode] || 2;
        for (let i = 0; i < Math.min(maxAgents, positions.length); i++) {
            const pos = positions[i];
            const agentKey = pos.team || `agent${i}`;
            weaponMap[agentKey] = 'hammer';
        }
        
        this.world = new World(this.logicalWidth, this.logicalHeight, this.config);
        this.world.reset();
        this.world.spawnAgents(mode, weaponMap);
        
        this.updateUI();
        this.world.enemies?.forEach(a => {
            if (!a) return;
            if (a.cortex) {
                a.cortex.lr = this.settings.learningRate;
                a.cortex.lambda = this.settings.lambda;
                a.cortex.gamma = this.settings.gamma;
            }
        });
        
        Logger.log('üîÑ –°–∏–º—É–ª—è—Ü–∏—è —Å–±—Ä–æ—à–µ–Ω–∞', 'warn');
        this.updateStats();
        this.updateMetrics();
        console.log('‚úÖ GameEngine.reset() completed successfully');
    }
    
    resetEpisode() {
        this.world.resetEpisode();
        this.updateUI();
        this.updateStats();
    }
    
    loop() {
        if (!this.running) return;
        if (!this.ctx || !this.world) {
            console.error('Context or world lost');
            this.running = false;
            return;
        }
        if (!this.world.enemies?.length || this.world.enemies.length < 2) {
            console.error('Invalid agents in world');
            this.running = false;
            Logger.log('‚ùå –û—à–∏–±–∫–∞: –∞–≥–µ–Ω—Ç—ã –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –∏–ª–∏ –Ω–µ–≤–∞–ª–∏–¥–Ω—ã', 'error');
            return;
        }
        
        const now = performance.now();        const dt = Math.min((now - this.lastTime) / 16.67, 3);
        const fps = Math.round(1000 / (now - this.lastTime + 0.001));
        this.fps = fps;
        this.lastTime = now;
        
        const fpsEl = document.getElementById('fpsCounter');
        if (fpsEl) fpsEl.textContent = `FPS: ${this.fps}`;
        
        try {
            const state = this.world.update(dt);
            this.world.draw(this.ctx, this.vision);
            this.updateStats(state);
            if (this.showMetrics) this.updateMetrics();
            if (this.debug) this.updateDebugPanel();
            if (this.world.episodeInProgress && this.world.step % 6 === 0) {
                this.updateUI();
            }
        } catch (e) {
            console.error('Loop error:', e);
            Logger.log(`‚ùå –û—à–∏–±–∫–∞ –≤ —Ü–∏–∫–ª–µ: ${e.message}`, 'error');
            this.running = false;
            return;
        }
        
        this.rafId = requestAnimationFrame(() => this.loop());
    }
    
    updateStats(state = null) {
        if (!state) {
            if (!this.world?.enemies?.length) return;
            state = { episode: this.world.episode, totalFights: this.world.totalFights, winner: null };
        }
        const { episode, totalFights } = state;
        const updateText = (id, val) => {
            const el = document.getElementById(id);
            if (el) el.textContent = typeof val === 'number' ? val.toFixed(2) : val;
        };
        
        updateText('episodeStat', episode);
        updateText('stepStat', this.world.step);
        updateText('totalFightsStat', totalFights);
        
        const totalWins = Object.values(this.world.teamWins).reduce((s, v) => s + v, 0);
        updateText('winsStat', totalWins);
        
        const progressEl = document.getElementById('episodeProgress');
        if (progressEl) {
            progressEl.style.width = `${(episode % 10) * 10}%`;
            progressEl.setAttribute('aria-valuenow', String((episode % 10) * 10));
        }        
        for (const agent of this.world.enemies) {
            if (!agent) continue;
            const healthEl = document.getElementById(`${agent.id}-health`);
            const rewardEl = document.getElementById(`${agent.id}-reward`);
            const winsEl = document.getElementById(`${agent.id}-wins`);
            const genEl = document.getElementById(`${agent.id}-gen`);
            const hpEl = document.getElementById(`${agent.id}-stat-hp`);
            const dmgEl = document.getElementById(`${agent.id}-stat-dmg`);
            const spdEl = document.getElementById(`${agent.id}-stat-spd`);
            const dodEl = document.getElementById(`${agent.id}-stat-dod`);
            const weaponEl = document.getElementById(`${agent.id}-weapon`);
            const modeEl = document.getElementById(`${agent.id}-mode`);
            const card = document.querySelector(`.agent-card.team-${agent.teamId || 'blue'}`);
            
            if (healthEl) healthEl.style.width = `${agent.alive ? (agent.health / agent.stats.maxHealth) * 100 : 0}%`;
            if (rewardEl) rewardEl.textContent = agent.cumulativeReward.toFixed(2);
            if (winsEl) winsEl.textContent = agent.wins;
            if (genEl) genEl.textContent = agent.generation;
            if (dodEl) dodEl.textContent = `DOD:${Math.round(agent.stats.dodgeChance * 100)}%`;
            if (weaponEl) weaponEl.textContent = `${agent.weapon.icon} ${agent.weapon.name.toUpperCase()}`;
            if (modeEl) {
                modeEl.textContent = (agent.mode || 'combat').toUpperCase();
                modeEl.className = `mode-badge mode-${agent.mode || 'combat'}`;
            }
            if (card) {
                if (agent.alive) card.classList.remove('dead');
                else card.classList.add('dead');
            }
        }
    }
    
    updateMetrics() {
        if (!this.showMetrics || !this.world?.enemies?.length) return;
        const blue = this.world.enemies[0], red = this.world.enemies[1];
        if (!blue || !red) return;
        
        const blueMetrics = blue.getLearningMetrics();
        const redMetrics = red.getLearningMetrics();
        const avgTD = (blueMetrics.avgTDError + redMetrics.avgTDError) / 2;
        const avgWin = (blueMetrics.winRate + redMetrics.winRate) / 2;
        const avgDmg = (blueMetrics.avgDamage + redMetrics.avgDamage) / 2;
        const avgAcc = (blueMetrics.accuracy + redMetrics.accuracy) / 2;
        
        const tdEl = document.getElementById('metricTDError');
        const winEl = document.getElementById('metricWinRate');
        const dmgEl = document.getElementById('metricDamage');
        const accEl = document.getElementById('metricAccuracy');
        
        if (tdEl) {            tdEl.textContent = avgTD.toFixed(4);
            tdEl.className = `metric-value${avgTD < 0.5 ? ' good' : avgTD > 2 ? ' degrading' : ''}`;
        }
        if (winEl) winEl.textContent = avgWin.toFixed(2);
        if (dmgEl) dmgEl.textContent = avgDmg.toFixed(2);
        if (accEl) accEl.textContent = avgAcc.toFixed(2);
        
        const lrEl = document.getElementById('currentLR');
        if (lrEl) lrEl.textContent = blue.cortex.lr.toFixed(4);
        
        const empAcc = (blue.empathyStats.total > 0 ? blue.empathyStats.correct / blue.empathyStats.total : 0);
        const empEl = document.getElementById('empathyAcc');
        if (empEl) empEl.textContent = empAcc.toFixed(2);
        
        const memConf = 0.5;
        const memEl = document.getElementById('memoryConf');
        if (memEl) memEl.textContent = memConf.toFixed(2);
        
        const gateProbs = [0.25, 0.25, 0.25, 0.25];
        const expEl = document.getElementById('expertLoad');
        if (expEl && gateProbs) expEl.textContent = gateProbs.map(p => p.toFixed(2)).join('/');
        
        const tdHistory = blue.cortex.getStats().tdErrorHistory || [];
        const curveEl = document.getElementById('learningCurve');
        if (curveEl && tdHistory.length > 0) {
            const recentAvg = tdHistory.slice(-10).reduce((a,b) => a+b, 0) / 10;
            const curveWidth = 100 - Math.min(100, recentAvg * 20);
            curveEl.style.width = curveWidth + '%';
        }
    }
    
    updateDebugPanel() {
        const panel = document.getElementById('debugPanel');
        const isActive = this.debug && this.selectedAgent;
        panel.classList.toggle('active', isActive);
        panel.hidden = !isActive;
        if (!isActive || !this.selectedAgent) return;
        
        const info = this.selectedAgent.getDebugInfo();
        const setDebugValue = (id, value) => {
            const el = document.getElementById(id);
            if (el) el.textContent = value;
        };
        
        setDebugValue('dbgMode', info.mode);
        setDebugValue('dbgWeapon', info.weapon);
        setDebugValue('dbgHealth', info.health);
        setDebugValue('dbgTeam', info.teamId);
        setDebugValue('dbgWins', info.wins);
        setDebugValue('dbgTDErr', info.tdError);        setDebugValue('dbgThreat', info.threat);
        setDebugValue('dbgFlank', info.flank);
        setDebugValue('dbgLR', info.lr);
        setDebugValue('dbgEmp', info.empathy);
        setDebugValue('dbgMemC', info.memConf);
        setDebugValue('dbgImag', info.imagination);
    }
    
    toggleDebug() {
        this.debug = !this.debug;
        const btn = document.getElementById('btnDebug');
        if (btn) {
            btn.classList.toggle('active', this.debug);
            btn.setAttribute('aria-pressed', String(this.debug));
        }
        this.updateDebugPanel();
        Logger.log(`üîç Debug ${this.debug ? '–≤–∫–ª—é—á—ë–Ω' : '–≤—ã–∫–ª—é—á–µ–Ω'}`, this.debug ? 'success' : 'info');
    }
    
    updateBtns() {
        const visionBtn = document.getElementById('btnVision');
        if (visionBtn) {
            visionBtn.classList.toggle('active', this.vision);
            visionBtn.setAttribute('aria-pressed', String(this.vision));
        }
    }
    
    save() {
        try {
            const data = {
                version: CONFIG.VERSION,
                timestamp: Date.now(),
                settings: this.settings,
                mode: this.config?.GAME?.currentMode,
                world: {
                    episode: this.world.episode,
                    step: this.world.step,
                    totalFights: this.world.totalFights,
                    walls: this.world.walls.map(w => ({ x: w.x, y: w.y })),
                    teamWins: this.world.teamWins
                },
                agents: this.world.enemies.map(a => a ? a.toJSON() : null).filter(a => a)
            };
            localStorage.setItem('aiArenaV5_0_1', JSON.stringify(data));
            Logger.log('üíæ –°–æ—Ö—Ä–∞–Ω–µ–Ω–æ (v5.0.1)', 'success');
        } catch (e) {
            if (e.name === 'QuotaExceededError') {
                Logger.log('üíæ –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω–æ: –ø—Ä–µ–≤—ã—à–µ–Ω –ª–∏–º–∏—Ç —Ö—Ä–∞–Ω–∏–ª–∏—â–∞', 'error');
            } else {
                Logger.log(`‚ùå –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è: ${e.message}`, 'error');            
}
    }
    
    load() {
        try {
            const raw = localStorage.getItem('aiArenaV5_0_1');
            if (!raw) {
                Logger.log('‚ùå –ù–µ—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–π v5.0.1', 'error');
                return;
            }
            const data = JSON.parse(raw);
            if (data.version !== CONFIG.VERSION) {
                Logger.log(`‚ö†Ô∏è –¢—Ä–µ–±—É–µ—Ç—Å—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ ${CONFIG.VERSION}`, 'warn');
                return;
            }
            this.config.GAME.currentMode = data.mode || '1v1';
            document.getElementById('gameModeSelect').value = this.config.GAME.currentMode;
            this.settings = { ...this.settings, ...data.settings };
            document.getElementById('learningRate').value = this.settings.learningRate;
            document.getElementById('lambda').value = this.settings.lambda;
            document.getElementById('learningRateValue').textContent = this.settings.learningRate;
            document.getElementById('lambdaValue').textContent = this.settings.lambda;
            document.getElementById('mutationRate').value = this.settings.mutationRate;
            document.getElementById('mutationRateValue').textContent = this.settings.mutationRate;
            document.getElementById('policyTemp').value = this.settings.policyTemperature;
            document.getElementById('policyTempValue').textContent = this.settings.policyTemperature;
            this.world.episode = data.world?.episode || 0;
            this.world.step = data.world?.step || 0;
            this.world.totalFights = data.world?.totalFights || 0;
            this.world.teamWins = data.world?.teamWins || { blue: 0, red: 0, green: 0, yellow: 0 };
            this.world.walls = data.world?.walls || [];
            this.world.enemies = data.agents?.map((a, i) =>
                a ? Agent.fromJSON(a, this.config?.GAME?.teamColors?.[a.teamId] || '#fff', this.config) : null
            ).filter(a => a) || [];
            this.world.enemies.forEach(a => {
                if (!a) return;
                if (a.cortex) {
                    a.cortex.lr = this.settings.learningRate;
                    a.cortex.lambda = this.settings.lambda;
                    a.cortex.gamma = this.settings.gamma;
                }
                if (a.teamId) a.updateAllies(this.world);
            });
            Logger.log('üìÇ –ó–∞–≥—Ä—É–∂–µ–Ω–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ v5.0.1', 'success');
            this.updateStats({ episode: this.world.episode, totalFights: this.world.totalFights });
            this.updateMetrics();
        } catch (e) {
            Logger.log(`‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏: ${e.message}`, 'error');
        }
    }    
    exportWeights() {
        try {
            const data = {
                version: CONFIG.VERSION,
                timestamp: Date.now(),
                mode: this.config?.GAME?.currentMode,
                agents: this.world.enemies.map(a => a?.toJSON() || null).filter(a => a)
            };
            const blob = new Blob([JSON.stringify(data)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `arena-v5.0.1-cortex-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
            Logger.log('üì§ –ê–≥–µ–Ω—Ç—ã —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω—ã', 'success');
        } catch (e) {
            Logger.log(`‚ùå –û—à–∏–±–∫–∞ —ç–∫—Å–ø–æ—Ä—Ç–∞: ${e.message}`, 'error');
        }
    }
    
    importWeights(e) {
        const file = e.target.files?.[0];
        if (!file) return;
        if (file.size > 10 * 1024 * 1024) {
            Logger.log('‚ùå –§–∞–π–ª —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π (–º–∞–∫—Å. 10MB)', 'error');
            e.target.value = '';
            return;
        }
        const reader = new FileReader();
        reader.onload = (ev) => {
            try {
                const result = ev.target?.result;
                if (typeof result !== 'string') throw new Error('Invalid file content');
                const data = JSON.parse(result);
                if (!data.version) throw new Error('Missing version field');
                if (data.version !== CONFIG.VERSION) throw new Error(`–¢—Ä–µ–±—É–µ—Ç—Å—è —Ñ–æ—Ä–º–∞—Ç ${CONFIG.VERSION}`);
                if (!data.agents || !Array.isArray(data.agents)) throw new Error('Missing or invalid agents array');
                if (!data.settings || typeof data.settings !== 'object') throw new Error('Missing or invalid settings');
                if (!data.world || typeof data.world !== 'object') throw new Error('Missing or invalid world data');
                this.config.GAME.currentMode = data.mode || '1v1';
                document.getElementById('gameModeSelect').value = this.config.GAME.currentMode;
                this.world.enemies = data.agents?.map((a, i) =>
                    a ? Agent.fromJSON(a, this.config?.GAME?.teamColors?.[a.teamId] || '#fff', this.config) : null
                ).filter(a => a) || [];
                this.world.enemies.forEach(a => {
                    if (!a) return;
                    if (a.cortex) {
                        a.cortex.lr = this.settings.learningRate;                        a.cortex.lambda = this.settings.lambda;
                        a.cortex.gamma = this.settings.gamma;
                    }
                    if (a.teamId) a.updateAllies(this.world);
                });
                Logger.log('üì• –ê–≥–µ–Ω—Ç—ã –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω—ã', 'success');
            } catch (err) {
                Logger.log(`‚ùå –û—à–∏–±–∫–∞ –∏–º–ø–æ—Ä—Ç–∞: ${err.message}`, 'error');
            } finally {
                e.target.value = '';
            }
        };
        reader.readAsText(file);
    }
    
    destroy() {
        console.log('üóëÔ∏è GameEngine.destroy() called');
        if (this.rafId) {
            cancelAnimationFrame(this.rafId);
            this.rafId = null;
            console.log('‚èπÔ∏è Animation frame cancelled');
        }
        this.running = false;
        window.removeEventListener('resize', this._onResize);
        document.removeEventListener('keydown', this._onKey);
        if (this.canvas) {
            this.canvas.removeEventListener('click', this._onClick);
            this.canvas.removeEventListener('touchend', this._onClick);
            this.canvas.removeEventListener('touchstart', this._onTouchStart);
            const ctx = this.canvas.getContext('2d');
            if (ctx) ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        }
        const cleanupBtn = (id) => {
            const btn = document.getElementById(id);
            if (btn) {
                const newBtn = btn.cloneNode(true);
                btn.parentNode.replaceChild(newBtn, btn);
            }
        };
        cleanupBtn('btnStart');
        cleanupBtn('btnReset');
        cleanupBtn('btnSave');
        cleanupBtn('btnLoad');
        cleanupBtn('btnExport');
        cleanupBtn('btnDebug');
        cleanupBtn('btnVision');
        cleanupBtn('btnApplyWeapons');
        cleanupBtn('btnRandomWeapons');
        const fileImport = document.getElementById('fileImport');
        if (fileImport) {            const newFileImport = fileImport.cloneNode(true);
            fileImport.parentNode.replaceChild(newFileImport, fileImport);
        }
        const modeSelect = document.getElementById('gameModeSelect');
        if (modeSelect) {
            const newModeSelect = modeSelect.cloneNode(true);
            modeSelect.parentNode.replaceChild(newModeSelect, modeSelect);
        }
        console.log('‚úÖ GameEngine.destroy() completed');
    }
    
    applyWeapons() {
        const mode = this.config?.GAME?.currentMode || '1v1';
        const maxAgents = this.config?.GAME?.maxAgents?.[mode] || 2;
        for (let i = 0; i < maxAgents; i++) {
            const agent = this.world.enemies[i];
            const select = document.getElementById(`${agent?.id}-weapon-select`);
            if (agent && select) {
                agent.setWeapon(select.value);
                Logger.log(`${agent.id.toUpperCase()} weapon: ${WEAPONS[select.value].icon} ${WEAPONS[select.value].name}`, 'success');
            }
        }
        this.updateStats();
    }
    
    randomWeapons() {
        const mode = this.config?.GAME?.currentMode || '1v1';
        const maxAgents = this.config?.GAME?.maxAgents?.[mode] || 2;
        const weaponTypes = Object.keys(WEAPONS);
        for (let i = 0; i < maxAgents; i++) {
            const agent = this.world.enemies[i];
            const select = document.getElementById(`${agent?.id}-weapon-select`);
            if (agent && select) {
                const w = weaponTypes[Utils.randInt(this.config._rng, 0, weaponTypes.length - 1)];
                select.value = w;
                agent.setWeapon(w);
            }
        }
        this.applyWeapons();
        Logger.log(`üé≤ Random weapons applied`, 'info');
    }
    
    showWinnerBanner(winner, type) {
        const banner = document.getElementById('winnerBanner');
        const title = document.getElementById('winnerTitle');
        const team = document.getElementById('winnerTeam');
        const text = document.getElementById('winnerText');
        const episode = document.getElementById('winnerEpisode');
        if (!banner || !title || !team || !text || !episode) return;
        const color = this.config?.GAME?.teamColors?.[winner] || '#fff';        const winText = type === 'teamElimination' ? '–ö–æ–º–∞–Ω–¥–∞ —É–Ω–∏—á—Ç–æ–∂–µ–Ω–∞' : '–ü–æ—Å–ª–µ–¥–Ω–∏–π –≤—ã–∂–∏–≤—à–∏–π';
        title.textContent = `üèÜ –ü–û–ë–ï–î–ê!`;
        title.style.color = color;
        team.textContent = winner.toUpperCase();
        team.style.color = color;
        text.textContent = winText;
        episode.textContent = `–≠–ø–∏–∑–æ–¥ ${this.world.episode}`;
        banner.classList.add('active');
        setTimeout(() => {
            banner.classList.remove('active');
        }, 3000);
    }
}

// ============================================================================
// GLOBAL INITIALIZATION ‚Äî Deterministic seed, crypto fallback, cleanup
// ============================================================================
(function() {
    'use strict';
    let initialized = false;
    let initPromise = null;
    window.arenaGame = null;
    window.arenaConfig = null;
    
    async function initArena() {
        if (initialized) {
            console.warn('‚ö†Ô∏è Arena already initialized');
            return initPromise;
        }
        if (initPromise) return initPromise;
        
        initialized = true;
        initPromise = (async () => {
            try {
                console.log('üîß Initializing AI Arena v5.0.1 CORTEX2BRAIN...');
                
                // ‚úÖ Deterministic seed generation with crypto fallback
                const seedHash = (() => {
                    try {
                        if (typeof crypto !== 'undefined' && crypto.getRandomValues) {
                            const arr = new Uint32Array(2);
                            crypto.getRandomValues(arr);
                            return arr[0].toString(36) + arr[1].toString(36);
                        }
                    } catch (e) {
                        console.warn('‚ö†Ô∏è Crypto fallback:', e.message);
                    }
                    return 'ts_' + Date.now().toString(36) + '_' + Math.random().toString(36).slice(2, 8);
                })();
                                const config = {
                    seed: 'ARENA_V5.0.1_CORTEX_' + seedHash,
                    timestamp: Date.now(),
                    enableTraining: true,
                    enableCritic: true,
                    enablePolicySelector: true,
                    enableEvolution: true,
                    enableSkillEvolution: true,
                    enableMoE: true,
                    enableConsolidation: true,
                    enableFighting: true,
                    enableRanged: true,
                    enableHebbian: true,
                    compactInputs: false,
                    enableWeightInheritance: true,
                    enableTactical: true,
                    enableTeamwork: true,
                    enableDeepCognition: true,
                    learningRate: CONFIG.CORTEX.DEFAULT_LR,
                    lambda: CONFIG.CORTEX.DEFAULT_LAMBDA,
                    gamma: CONFIG.CORTEX.DEFAULT_GAMMA,
                    entropyCoeff: 0.01,
                    mutationRate: 0.1,
                    skillGrowthRate: 0.04,
                    policyTemperature: CONFIG.BEHAVIOR.DEFAULT_TEMP,
                    GAME: {
                        MODES: { DUEL: '1v1', TEAM: '2v2', FFA: '4way' },
                        currentMode: '1v1',
                        teamColors: CONFIG.GAME.TEAM_COLORS,
                        maxAgents: CONFIG.GAME.MAX_AGENTS,
                        teamBonus: CONFIG.GAME.TEAM_BONUS,
                        coordinationRadius: CONFIG.GAME.COORDINATION_RADIUS,
                        winConditions: CONFIG.GAME.WIN_CONDITIONS
                    },
                    ARCH: {
                        INPUT_DIM: 57,
                        INPUT_DIM_COMPACT: 25,
                        EMBEDDING_DIM: 24,
                        EMBEDDING_DIM_COMPACT: 16,
                        HIDDEN1: 48,
                        HIDDEN2: 36,
                        OUTPUT_DIM: 16,
                        MEMORY_DIM: 16,
                        NUM_HEADS: CONFIG.CORTEX.NUM_HEADS,
                        NUM_EXPERTS: 4,
                        EXPERT_DIM: 36,
                        POLICY_CONTEXT_DIM: 8,
                        POLICY_SKILL_DIM: 5,
                        POLICY_HIDDEN: 24,
                        POLICY_MODES: 5,                        CRITIC_HIDDEN: 32,
                        LOGICAL_WIDTH: CONFIG.GAME.LOGICAL_WIDTH,
                        LOGICAL_HEIGHT: CONFIG.GAME.LOGICAL_HEIGHT
                    },
                    PHYSICS: { ...CONFIG.PHYSICS },
                    EVOLUTION: { ...CONFIG.EVOLUTION },
                    TACTICAL: { ...CONFIG.TACTICAL },
                    MEMORY: { maxVisitedCells: CONFIG.MEMORY.MAX_VISITED_CELLS },
                    POLICY: { softmaxTemperature: CONFIG.BEHAVIOR.DEFAULT_TEMP },
                    COGNITION: {
                        minLr: 0.001,
                        maxLr: 0.02,
                        lrAdjustSteps: 30,
                        memoryDecayRate: 0.001,
                        empathyValidationSteps: 10,
                        imaginationDepth: 2,
                        debateRounds: 1
                    }
                };
                
                window.arenaConfig = config;
                config._rng = new SeededRNG(config.seed);
                
                if (window.arenaGame) {
                    console.log('üîÑ Cleaning up existing game instance...');
                    window.arenaGame.destroy();
                    window.arenaGame = null;
                }
                
                window.arenaGame = new GameEngine(config);
                
                if (window.arenaGame) {
                    console.log('‚úÖ AI Arena v5.0.1 CORTEX2BRAIN initialized successfully');
                    console.log('üîê Seed:', config.seed);
                    console.log('üéÆ Mode:', config.GAME.currentMode);
                    console.log('üß† Engine: CORTEX2BRAIN v2.2.1 Universal with BehaviorArbiter');
                    console.log('üéØ Emotions ‚Üí Behavior: FULLY INTEGRATED');
                } else {
                    throw new Error('GameEngine constructor returned null');
                }
            } catch (e) {
                console.error('‚ùå Failed to initialize AI Arena:', e);
                console.error('Stack:', e.stack);
                initialized = false;
                initPromise = null;
                alert('–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏: ' + e.message);
                throw e;
            }
        })();
        return initPromise;    }
    
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initArena, { once: true, capture: true });
    } else {
        setTimeout(initArena, 0);
    }
    
    window.addEventListener('beforeunload', () => {
        console.log('üëã Cleaning up Arena on page unload...');
        if (window.arenaGame) {
            window.arenaGame.destroy();
            window.arenaGame = null;
        }
        window.arenaConfig = null;
        initialized = false;
        initPromise = null;
    });
    
    // ‚úÖ Test utilities for determinism verification
    window.ArenaTest = {
        runDeterminismTest: function(seed, steps = 100) {
            console.log(`üîç Determinism test: seed="${seed}", steps=${steps}`);
            const rng1 = new SeededRNG(seed);
            const rng2 = new SeededRNG(seed);
            const values1 = [];
            const values2 = [];
            for (let i = 0; i < steps; i++) {
                values1.push(rng1.next());
                values2.push(rng2.next());
            }
            const passed = values1.every((v, i) => Math.abs(v - values2[i]) < 1e-10);
            console.log(`üìä Result: ${passed ? '‚úÖ PASSED' : '‚ùå FAILED'}`);
            return { passed, seed, steps, sampleValues: values1.slice(0, 5) };
        },
        
        runBehaviorArbiterTest: function() {
            console.log('üîç BehaviorArbiter test...');
            const arbiter = new BehaviorArbiter({ policyTemperature: 0.8 });
            const testOutputs = new Float32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0.3, 0.5, 0.2, 0.1, 0.4, 0, 0]);
            const testEmotions = { confidence: 0.7, fear: 0.2, aggression: 0.6, curiosity: 0.4, caution: 0.3, frustration: 0.1, vengeance: 0.2, boredom: 0.1 };
            const testContext = { healthRatio: 0.8, enemyDistance: 50, hasAllyNearby: false, isCornered: false, enemyCount: 1, step: 100 };
            const result = arbiter.selectMode(testOutputs, testEmotions, testContext);
            console.log(`üìä Selected mode: ${result.mode} (confidence: ${result.confidence.toFixed(3)})`);
            console.log(`üìä Mode probabilities: hunt=${result.probs[0].toFixed(3)}, flee=${result.probs[1].toFixed(3)}, explore=${result.probs[2].toFixed(3)}, combat=${result.probs[3].toFixed(3)}, avoid=${result.probs[4].toFixed(3)}`);
            return result;
        },
        
        reset: function() {
            console.log('üîÑ ArenaTest.reset() called');            initialized = false;
            initPromise = null;
            if (window.arenaGame) {
                window.arenaGame.destroy();
                window.arenaGame = null;
            }
            setTimeout(initArena, 100);
        },
        
        getStatus: function() {
            return {
                initialized,
                hasGame: !!window.arenaGame,
                hasConfig: !!window.arenaConfig,
                gameRunning: window.arenaGame?.running || false,
                fps: window.arenaGame?.fps || 0,
                version: CONFIG.VERSION
            };
        },
        
        exportAgentState: function(agentId = 0) {
            if (!window.arenaGame?.world?.enemies?.[agentId]) {
                console.error('‚ùå Agent not found');
                return null;
            }
            const agent = window.arenaGame.world.enemies[agentId];
            const state = agent.toJSON();
            console.log('üì¶ Agent state exported to console');
            return state;
        },
        
        importAgentState: function(state, agentId = 0) {
            if (!window.arenaGame?.world?.enemies?.[agentId]) {
                console.error('‚ùå Agent not found');
                return false;
            }
            try {
                const agent = Agent.fromJSON(state, window.arenaGame.world.enemies[agentId].color, window.arenaConfig);
                window.arenaGame.world.enemies[agentId] = agent;
                console.log('üì• Agent state imported successfully');
                return true;
            } catch (e) {
                console.error('‚ùå Import failed:', e);
                return false;
            }
        }
    };
    
    console.log('üì¶ Arena v5.0.1 CORTEX2BRAIN module loaded, waiting for DOM...');
    console.log('üí° Use ArenaTest.runDeterminismTest("my_seed") to verify determinism');    console.log('üí° Use ArenaTest.runBehaviorArbiterTest() to verify behavior integration');
})();
</script>
</body>
</html>