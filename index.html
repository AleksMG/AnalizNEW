const Utils = {
    clamp: (v, min, max) => Math.max(min, Math.min(max, v)),
    dist: (a, b) => Math.hypot(a.x - b.x, a.y - b.y),
    tanh: x => { const e = Math.exp(2*x); return (e-1)/(e+1); },
    safeNumber: (val, fallback = 0) => (typeof val === 'number' && isFinite(val)) ? val : fallback,
};

class NeuralNetwork {
    constructor(config) {
        this.inputDim = config.inputDim || 24;
        this.hidden1 = config.hidden1 || 48;
        this.hidden2 = config.hidden2 || 36;
        this.outputDim = config.outputDim || 16;
        this.memoryDim = config.memoryDim || 16;
        this.seed = config.seed || 'default';
        this.rng = { next: () => Math.random() };
        
        this.W1 = this._randMat(this.inputDim + this.memoryDim, this.hidden1, 0.3);
        this.W2 = this._randMat(this.hidden1, this.hidden2, 0.2);
        this.W3 = this._randMat(this.hidden2, this.outputDim, 0.1);
        this.memory = new Array(this.memoryDim).fill(0);
        this.lr = config.lr || 0.005;
        this.hebbianRate = config.hebbianRate || 0.002;
    }
    
    _randMat(rows, cols, scale) {
        const m = [];
        for(let i=0; i<rows; i++) {
            const row = [];
            for(let j=0; j<cols; j++) row.push((this.rng.next()*2-1)*scale);
            m.push(row);
        }
        return m;
    }
    
    _matMul(vec, mat) {
        const out = [];
        for(let i=0; i<mat[0].length; i++) {
            let sum = 0;
            for(let j=0; j<vec.length; j++) sum += vec[j] * mat[j][i];
            out.push(Utils.tanh(sum));
        }
        return out;
    }
    
    forward(inputs) {
        if (!inputs || inputs.length !== this.inputDim) inputs = new Array(this.inputDim).fill(0);
        const combined = [...inputs, ...this.memory];
        let h1 = this._matMul(combined, this.W1);
        let h2 = this._matMul(h1, this.W2);        let output = this._matMul(h2, this.W3);
        this.memory = h2.slice(0, this.memoryDim);
        return { output: output.map(v => Utils.safeNumber(v, 0)), memory: this.memory.slice() };
    }
    
    hebbianUpdate(inputs, outputs, reward) {
        if (reward <= 0) return;
        for(let i=0; i<Math.min(inputs.length, this.W1.length); i++) {
            for(let o=0; o<Math.min(outputs.length, this.W1[0].length); o++) {
                if (Math.abs(inputs[i]) > 0.4 && Math.abs(outputs[o]) > 0.4) {
                    const sign = Math.sign(inputs[i]) * Math.sign(outputs[o]);
                    this.W1[i][o] += this.hebbianRate * reward * sign;
                    this.W1[i][o] = Utils.clamp(this.W1[i][o], -1, 1);
                }
            }
        }
    }
}

class MeanMaxAgent {
    constructor(id) {
        this.id = id;
        this.x = 0; this.y = 0;
        this.vx = 0; this.vy = 0;
        this.mass = 0.5;
        this.water = 0;
        this.playerId = -1;
        this.cumulativeReward = 0;
        
        this.net = new NeuralNetwork({
            inputDim: 24, hidden1: 48, hidden2: 36, outputDim: 16,
            memoryDim: 16, seed: 'MM_' + id, lr: 0.005, hebbianRate: 0.002
        });
    }
    
    getInputs(units, turn) {
        const inputs = [];
        const maxDist = 12000;
        
        const wrecks = units.filter(u => u.type === 4 && u.extra > 0 && u.player === -1)
            .map(w => ({...w, d: Utils.dist(this, w)}))
            .sort((a,b) => a.d - b.d).slice(0, 3);
        
        for (let i = 0; i < 3; i++) {
            const w = wrecks[i];
            if (w) {
                inputs.push(Utils.clamp((w.x - this.x) / maxDist, -1, 1));
                inputs.push(Utils.clamp((w.y - this.y) / maxDist, -1, 1));
            } else inputs.push(0, 0);
        }        
        const enemies = units.filter(u => u.type === 0 && u.player !== -1 && u.player !== this.playerId)
            .map(e => ({...e, d: Utils.dist(this, e)}))
            .sort((a,b) => a.d - b.d).slice(0, 3);
        
        for (let i = 0; i < 3; i++) {
            const e = enemies[i];
            if (e) {
                inputs.push(Utils.clamp((e.x - this.x) / maxDist, -1, 1));
                inputs.push(Utils.clamp((e.y - this.y) / maxDist, -1, 1));
            } else inputs.push(0, 0);
        }
        
        inputs.push(Utils.clamp(this.x / 6000, -1, 1));
        inputs.push(Utils.clamp(this.y / 6000, -1, 1));
        inputs.push(Utils.clamp(this.water / 50, 0, 1));
        inputs.push(Utils.clamp(turn / 200, 0, 1));
        inputs.push(Utils.clamp(wrecks.filter(w => w.d < 2000).length / 5, 0, 1));
        inputs.push(Utils.clamp(enemies.filter(e => e.d < 1500).length / 3, 0, 1));
        inputs.push(Utils.clamp(Math.min(this.x + 6000, 6000 - this.x, this.y + 6000, 6000 - this.y) / 1000, 0, 1));
        inputs.push(Utils.clamp(this.cumulativeReward / 100, -1, 1));
        inputs.push(Utils.clamp(Math.hypot(this.vx, this.vy) / 200, 0, 1));
        inputs.push(this.mass);
        inputs.push(0, 0);
        
        return inputs;
    }
    
    decide(units, turn) {
        const inputs = this.getInputs(units, turn);
        const { output } = this.net.forward(inputs);
        
        const dirX = Utils.tanh(output[9] || 0);
        const dirY = Utils.tanh(output[10] || 0);
        const throttle = Math.max(50, Math.min(300, Math.floor((Math.abs(output[11] || 0) + 0.5) * 200)));
        
        const scale = 1000;
        const targetX = Math.floor(this.x + dirX * scale);
        const targetY = Math.floor(this.y + dirY * scale);
        
        return `${targetX} ${targetY} ${throttle}`;
    }
    
    update(unit) {
        this.x = unit.x; this.y = unit.y;
        this.vx = unit.vx; this.vy = unit.vy;
        this.mass = unit.mass;
        this.playerId = unit.player;
    }
}
const agent = new MeanMaxAgent('ME');
let turn = 0;
const myId = parseInt(readline());

while (true) {
    turn++;
    
    readline(); readline(); readline();
    readline(); readline(); readline();
    
    const unitCount = parseInt(readline());
    const units = [];
    let myUnit = null;
    
    for (let i = 0; i < unitCount; i++) {
        const inputs = readline().split(' ');
        const unit = {
            id: parseInt(inputs[0]),
            type: parseInt(inputs[1]),
            player: parseInt(inputs[2]),
            mass: parseFloat(inputs[3]),
            radius: parseInt(inputs[4]),
            x: parseFloat(inputs[5]),
            y: parseFloat(inputs[6]),
            vx: parseFloat(inputs[7]),
            vy: parseFloat(inputs[8]),
            extra: parseInt(inputs[9]),
            extra2: parseInt(inputs[10])
        };
        units.push(unit);
        
        if (unit.type === 0 && unit.player === myId) {
            myUnit = unit;
            agent.update(unit);
        }
    }
    
    if (myUnit) {
        const action = agent.decide(units, turn);
        console.log(action);
        console.error(`Turn ${turn}: pos=(${myUnit.x.toFixed(0)},${myUnit.y.toFixed(0)}) â†’ ${action}`);
    } else {
        console.log('WAIT');
        console.error('ERROR: My unit not found!');
    }
}
