<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline'; connect-src 'self'; img-src 'self'; font-src 'self'; base-uri 'self'; form-action 'self';">
    <meta name="description" content="AI Arena v5.0 Professional ‚Äî Deep Team Cognition System [FULL FEATURE SET]">
    <meta name="theme-color" content="#0a0a15">
    <meta name="robots" content="noindex">
    <title>üéÆ AI Arena v5.0 Professional ‚Äî Deep Team Cognition [PRO]</title>
    <style>
        :root {
            --bg: #0a0a15; --bg-gradient-start: #0a0a15; --bg-gradient-end: #1a1a2e;
            --panel: #121225; --panel-alpha: rgba(18, 18, 37, 0.95);
            --text: #e0e0ff; --text-dim: #b0b0d0; --text-muted: #707090;
            --primary: #00f2ff; --primary-dark: #00c4d4; --accent: #ff0066;
            --success: #00ff9d; --warning: #ffaa00; --danger: #ff4444;
            --border: #2a2a45; --border-light: #3a3a5a;
            --purple: #aa88ff; --yellow: #ffdd44; --pink: #ff66cc; --cyan: #00d4ff;
            --stat-str: #ff4444; --stat-spd: #4444ff; --stat-hp: #44ff44; --stat-dod: #aa88ff;
            --learning-good: #00ff9d; --learning-bad: #ff5577; --learning-neutral: #ffaa00;
            --mode-combat-bg: rgba(255, 170, 0, 0.15); --mode-combat-text: #ffaa00;
            --team-blue: #00d4ff; --team-red: #ff5577; --team-green: #00ff9d; --team-yellow: #ffdd44;
            --sidebar-width: 420px; --header-height: 48px; --panel-radius: 12px;
            --btn-radius: 8px; --input-radius: 6px; --card-radius: 10px;
            --transition-fast: 150ms ease; --transition-normal: 250ms ease;
            --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.3); --shadow-md: 0 4px 8px rgba(0, 0, 0, 0.4);
            --z-canvas: 1; --z-sidebar: 10; --z-header: 100; --z-modal: 1000;
        }
        @supports not (--css: variables) {
            body { background: #0a0a15; color: #e0e0ff; }
            .sidebar { background: #121225; }
            .panel { background: rgba(0, 0, 0, 0.3); border-color: #2a2a45; }
        }
        *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }
        html { font-size: 16px; -webkit-text-size-adjust: 100%; scroll-behavior: smooth; }
        body {
            background: linear-gradient(135deg, var(--bg-gradient-start) 0%, var(--bg-gradient-end) 100%);
            color: var(--text); font-family: 'Segoe UI', system-ui, sans-serif;
            font-size: 0.875rem; line-height: 1.4; overflow: hidden; user-select: none;
            touch-action: manipulation; text-rendering: optimizeLegibility;
            -webkit-font-smoothing: antialiased;
        }
        :focus-visible { outline: 2px solid var(--primary); outline-offset: 2px; }
        button:focus-visible, input:focus-visible, select:focus-visible {
            outline: 2px solid var(--primary); outline-offset: 2px;
            box-shadow: 0 0 0 4px rgba(0, 242, 255, 0.2);
        }
        .skip-link { position: absolute; top: -40px; left: 0; background: var(--primary); color: #000; padding: 0.5rem 1rem; z-index: var(--z-modal); }
        .skip-link:focus { top: 0; }
        .container {
            display: grid; grid-template-columns: 1fr var(--sidebar-width);
            grid-template-rows: var(--header-height) 1fr; grid-template-areas: "header header" "canvas sidebar";
            height: 100vh; width: 100vw;
        }
        .header {
            grid-area: header; background: var(--panel); border-bottom: 1px solid var(--border);
            padding: 0.5rem 1rem; display: flex; justify-content:space-between; align-items: center;
            z-index: var(--z-header);
        }
        .header h1 { font-size: 1rem; font-weight: 700; color: var(--primary); display: flex; align-items: center; gap: 0.5rem; margin: 0; }
        .version-badge { background: var(--accent); color: #fff; padding: 0.125rem 0.375rem; border-radius: 0.25rem; font-size: 0.625rem; font-weight: 600; }
        .fps-counter { font-family: monospace; color: var(--success); font-weight: 700; font-size: 0.875rem; background: rgba(0, 255, 157, 0.1); padding: 0.25rem 0.5rem; border-radius: 0.375rem; min-width: 70px; text-align: center; }
        #gameCanvas { grid-area: canvas; width: 100%; height: 100%; display: block; cursor: crosshair; touch-action: none; }
        .sidebar {
            grid-area: sidebar; background: var(--panel); border-left: 1px solid var(--border);
            padding: 0.625rem; overflow-y: auto; display: flex; flex-direction: column; gap: 0.5rem;
            scrollbar-width: thin; scrollbar-color: var(--border) var(--bg);
        }
        .sidebar::-webkit-scrollbar { width: 0.25rem; }
        .sidebar::-webkit-scrollbar-track { background: var(--bg); }
        .sidebar::-webkit-scrollbar-thumb { background: var(--border); border-radius: 0.125rem; }
        .panel {
            background: var(--panel-alpha); border: 1px solid var(--border); border-radius: var(--panel-radius);
            padding: 0.5rem; backdrop-filter: blur(4px);
        }
        .panel-title { color: var(--primary); font-size: 0.75rem; font-weight: 700; margin-bottom: 0.375rem; display: flex; align-items: center; gap: 0.3125rem; padding-bottom: 0.25rem; border-bottom: 1px solid var(--border); text-transform: uppercase; letter-spacing: 0.5px; }
        .stat-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.25rem; }
        .stat { background: rgba(0, 0, 0, 0.2); padding: 0.25rem 0.375rem; border-radius: 0.375rem; font-size: 0.625rem; border: 1px solid transparent; }
        .stat:hover { border-color: var(--border-light); background: rgba(0, 0, 0, 0.25); }
        .stat-label { color: var(--text-dim); display: block; margin-bottom: 0.0625rem; font-size: 0.5625rem; }
        .stat-value { color: var(--primary); font-weight: 700; font-family: monospace; font-size: 0.6875rem; }
        .stat-value.good { color: var(--success); } .stat-value.bad { color: var(--danger); }
        .control-group { margin-bottom: 0.375rem; }
        .control-label { display: flex; justify-content: space-between; align-items: center; font-size: 0.6875rem; margin-bottom: 0.125rem; color: var(--text-dim); }
        input[type="range"] { width: 100%; height: 0.25rem; background: var(--border); border-radius: 0.125rem; appearance: none; cursor: pointer; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 0.75rem; height: 0.75rem; background: var(--primary); border-radius: 50%; cursor: pointer; border: 2px solid var(--bg); }
        select { width: 100%; padding: 0.375rem 0.5rem; background: rgba(0, 0, 0, 0.3); border: 1px solid var(--border); border-radius: var(--input-radius); color: var(--text); font-size: 0.6875rem; cursor: pointer; }
        .btn-group { display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.25rem; margin-top: 0.25rem; }
        .btn-group-3 { display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.25rem; margin-top: 0.25rem; }
        .btn-group-4 { display: grid; grid-template-columns: repeat(4, 1fr); gap: 0.25rem; margin-top: 0.25rem; }
        button {
            padding: 0.375rem 0.5rem; border: none; border-radius: var(--btn-radius); font-weight: 700;
            cursor: pointer; font-size: 0.6875rem; background: var(--border); color: var(--text);
            min-height: 2rem; transition: all var(--transition-fast); text-transform: uppercase; letter-spacing: 0.5px;
            display: flex; align-items: center; justify-content: center; gap: 0.25rem; position: relative; overflow: hidden;
        }
        button:hover:not(:disabled) { background: var(--border-light); }
        button:active { transform: translateY(1px); }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-primary { background: var(--primary); color: #000; }
        .btn-danger { background: var(--danger); color: #fff; }
        .btn-success { background: var(--success); color: #000; }
        .btn-secondary { background: var(--border); color: var(--text); }
        .btn-toggle.active { background: var(--accent); color: #fff; }
        .toggle { display: flex; align-items: center; gap: 0.25rem; font-size: 0.6875rem; margin-bottom: 0.1875rem; color: var(--text-dim); cursor: pointer; user-select: none; }
        .toggle input { accent-color: var(--primary); width: 0.875rem; height: 0.875rem; cursor: pointer; }
        .log {
            background: #000; border: 1px solid var(--border); border-radius: 0.5rem; padding: 0.375rem;
            height: 5.625rem; overflow-y: auto; font-size: 0.5625rem; font-family: monospace;
            word-break: break-word; white-space: pre-wrap;
        }
        .log-entry { margin-bottom: 0.125rem; padding-bottom: 0.125rem; border-bottom: 1px solid #111; line-height: 1.3; }
        .log-entry.info { color: var(--primary); } .log-entry.success { color: var(--success); }
        .log-entry.warn { color: var(--warning); } .log-entry.error { color: var(--danger); }
        .progress-bar { height: 0.25rem; background: rgba(0, 0, 0, 0.3); border-radius: 0.1875rem; overflow: hidden; margin-top: 0.1875rem; }
        .progress-fill { height: 100%; background: linear-gradient(90deg, var(--primary), var(--success)); transition: width var(--transition-normal); }
        
        /* TEAM-BASED AGENT CARDS */
        .agent-card {
            display: flex; flex-direction: column; gap: 0.25rem; padding: 0.375rem;
            background: rgba(0, 0, 0, 0.2); border-radius: var(--card-radius); margin-bottom: 0.375rem;
            border-left: 4px solid transparent; position: relative;
        }
        .agent-card.team-blue { border-left-color: var(--team-blue); background: rgba(0, 212, 255, 0.08); }
        .agent-card.team-red { border-left-color: var(--team-red); background: rgba(255, 85, 119, 0.08); }
        .agent-card.team-green { border-left-color: var(--team-green); background: rgba(0, 255, 157, 0.08); }
        .agent-card.team-yellow { border-left-color: var(--team-yellow); background: rgba(255, 221, 68, 0.08); }
        .agent-card.dead { opacity: 0.5; filter: grayscale(0.8); }
        .agent-card.dead::after {
            content: '‚ò†Ô∏è'; position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%); font-size: 2rem; opacity: 0.6;
        }
        .agent-header { display: flex; align-items: center; gap: 0.25rem; font-size: 0.6875rem; font-weight: 600; }
        .team-badge {
            display: inline-flex; align-items: center; padding: 0.0625rem 0.25rem;
            border-radius: 0.25rem; font-size: 0.5rem; font-weight: 600; margin-left: 0.25rem;
        }
        .team-badge.blue { background: rgba(0, 212, 255, 0.3); color: var(--team-blue); border: 1px solid var(--team-blue); }
        .team-badge.red { background: rgba(255, 85, 119, 0.3); color: var(--team-red); border: 1px solid var(--team-red); }
        .team-badge.green { background: rgba(0, 255, 157, 0.3); color: var(--team-green); border: 1px solid var(--team-green); }
        .team-badge.yellow { background: rgba(255, 221, 68, 0.3); color: var(--team-yellow); border: 1px solid var(--team-yellow); }
        .health-bar { height: 0.25rem; background: rgba(0, 0, 0, 0.3); border-radius: 0.125rem; overflow: hidden; }
        .health-fill { height: 100%; background: linear-gradient(90deg, var(--success), var(--primary)); transition: width var(--transition-fast); }
        .agent-stats { display: flex; justify-content: space-between; font-size: 0.5625rem; color: var(--text-dim); flex-wrap: wrap; gap: 0.125rem; }
        .agent-stats b { color: var(--text); font-weight: 600; }
        .stat-badge {
            display: inline-flex; align-items: center; padding: 0.0625rem 0.1875rem;
            border-radius: 0.125rem; font-size: 0.5rem; font-weight: 600; margin-right: 0.125rem; border: 1px solid transparent;
        }
        .stat-badge.stat-hp { background: rgba(68, 255, 68, 0.15); color: var(--stat-hp); }
        .stat-badge.stat-str { background: rgba(255, 68, 68, 0.15); color: var(--stat-str); }
        .stat-badge.stat-spd { background: rgba(68, 68, 255, 0.15); color: var(--stat-spd); }
        .stat-badge.stat-dod { background: rgba(170, 136, 255, 0.15); color: var(--stat-dod); }
        .weapon-badge {
            display: inline-flex; align-items: center; gap: 0.125rem; padding: 0.0625rem 0.25rem;
            border-radius: 0.25rem; font-size: 0.5rem; font-weight: 600; margin-top: 0.125rem;
            background: rgba(255, 170, 0, 0.15); color: var(--warning); border: 1px solid var(--warning);
        }
        .skills-display { display: grid; grid-template-columns: repeat(5, 1fr); gap: 0.125rem; margin-top: 0.1875rem; }
        .skill-item { text-align: center; font-size: 0.5rem; }
        .skill-bar { height: 0.125rem; background: rgba(0, 0, 0, 0.3); border-radius: 0.0625rem; margin-top: 0.0625rem; overflow: hidden; }
        .skill-fill { height: 100%; transition: width var(--transition-normal); }
        .skill-combat .skill-fill { background: var(--warning); }
        .skill-flee .skill-fill { background: var(--danger); }
        .skill-explore .skill-fill { background: var(--primary); }
        .skill-avoid .skill-fill { background: var(--purple); }
        .mode-badge {
            display: inline-flex; align-items: center; padding: 0.0625rem 0.25rem;
            border-radius: 0.375rem; font-size: 0.5rem; font-weight: 600; margin-left: 0.25rem;
        }
        .mode-combat { background: var(--mode-combat-bg); color: var(--mode-combat-text); }
        .learning-metrics { display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.1875rem; margin-top: 0.25rem; }
        .metric-item { background: rgba(0, 0, 0, 0.2); padding: 0.1875rem 0.25rem; border-radius: 0.25rem; font-size: 0.5rem; }
        .metric-label { color: var(--text-dim); display: block; font-size: 0.4375rem; }
        .metric-value { color: var(--learning-good); font-weight: 600; font-family: monospace; }
        .learning-progress { display: flex; flex-direction: column; gap: 0.125rem; margin-top: 0.25rem; }
        .progress-row { display: flex; align-items: center; gap: 0.25rem; font-size: 0.5rem; }
        .progress-label { width: 4.375rem; color: var(--text-dim); flex-shrink: 0; }
        .progress-track { flex: 1; height: 0.1875rem; background: rgba(0, 0, 0, 0.3); border-radius: 0.125rem; overflow: hidden; }
        .progress-track.td .progress-fill { background: linear-gradient(90deg, var(--danger), var(--warning), var(--success)); }
        .progress-track.entropy .progress-fill { background: linear-gradient(90deg, var(--warning), var(--primary)); }
        .debug-panel {
            background: rgba(0, 0, 0, 0.4); border: 1px solid var(--border); border-radius: 0.5rem;
            padding: 0.375rem; font-size: 0.5625rem; display: none;
        }
        .debug-panel.active { display: block; }
        .debug-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.125rem 0.25rem; }
        .debug-item { display: flex; justify-content: space-between; padding: 0.0625rem 0; }
        .debug-label { color: var(--text-dim); }
        .debug-value { color: var(--primary); font-weight: 600; font-family: monospace; }
        .separator { height: 1px; background: var(--border); margin: 0.375rem 0; }
        input[type="file"] { display: none; }
        
        /* TEAM STATUS PANEL */
        .team-status {
            display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.375rem;
            margin-top: 0.375rem; padding: 0.375rem; background: rgba(0,0,0,0.2);
            border-radius: 0.375rem;
        }
        .team-status-item {
            display: flex; align-items: center; gap: 0.25rem; justify-content: space-between;
            padding: 0.1875rem; border-radius: 0.25rem;
            background: rgba(0,0,0,0.3);
        }
        .team-status-item.blue { border-left: 2px solid var(--team-blue); }
        .team-status-item.red { border-left: 2px solid var(--team-red); }
        .team-status-item.green { border-left: 2px solid var(--team-green); }
        .team-status-item.yellow { border-left: 2px solid var(--team-yellow); }
        .team-status-count { font-weight: 700; font-size: 0.625rem; }
        .team-status-alive { color: var(--success); }
        .team-status-dead { color: var(--danger); }
        
        /* WINNER BANNER */
        .winner-banner {
            position: fixed; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            border: 3px solid var(--success);
            border-radius: 1rem;
            padding: 2rem 3rem;
            text-align: center;
            z-index: var(--z-modal);
            display: none;
            animation: winnerPop 0.5s ease-out;
            min-width: 300px;
        }
        .winner-banner.active { display: block; }
        .winner-banner h2 {
            color: var(--success); font-size: 1.5rem;
            margin-bottom: 0.5rem; text-transform: uppercase;
        }
        .winner-banner p { color: var(--text); font-size: 0.875rem; margin-bottom: 0.25rem; }
        .winner-banner .winner-team { font-size: 1.25rem; font-weight: 700; margin: 0.5rem 0; }
        @keyframes winnerPop {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }
        
        @media (max-width: 1100px) {
            .container { grid-template-columns: 1fr !important; grid-template-rows: var(--header-height) 1fr auto !important; grid-template-areas: "header" "canvas" "sidebar" !important; }
            .sidebar { border-left: none !important; border-top: 1px solid var(--border) !important; max-height: 45vh !important; }
        }
        @media (max-width: 600px) {
            :root { --sidebar-width: 100%; }
            .header { padding: 0.375rem 0.75rem; }
            .header h1 { font-size: 0.875rem; }
            .panel { padding: 0.375rem; }
            .stat-grid { grid-template-columns: repeat(2, 1fr); }
            .btn-group, .btn-group-3 { grid-template-columns: repeat(2, 1fr); }
            .learning-metrics { grid-template-columns: repeat(2, 1fr); }
            .debug-grid { grid-template-columns: 1fr; }
            .team-status { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <a href="#gameCanvas" class="skip-link">–ü–µ—Ä–µ–π—Ç–∏ –∫ —Å–∏–º—É–ª—è—Ü–∏–∏</a>
    
    <!-- WINNER BANNER -->
    <div class="winner-banner" id="winnerBanner">
        <h2 id="winnerTitle">üèÜ –ü–û–ë–ï–î–ê!</h2>
        <div class="winner-team" id="winnerTeam">–°–ò–ù–ò–Ø –ö–û–ú–ê–ù–î–ê</div>
        <p id="winnerText">–ö–æ–º–∞–Ω–¥–∞ —É–Ω–∏—á—Ç–æ–∂–µ–Ω–∞</p>
        <p id="winnerEpisode" style="color: var(--text-dim); font-size: 0.75rem;">–≠–ø–∏–∑–æ–¥ 1</p>
    </div>
    
    <div class="container">
        <header class="header">
            <h1>üéÆ AI ARENA <span class="version-badge">v5.0 DEEP COGNITION [PRO]</span></h1>
            <div class="fps-counter" id="fpsCounter">FPS: 60</div>
        </header>
        <canvas id="gameCanvas"></canvas>
        <aside class="sidebar">
            <!-- MODE SELECTOR -->
            <section class="panel">
                <h2 class="panel-title">üéÆ –†–ï–ñ–ò–ú –ò–ì–†–´</h2>
                <div class="control-group">
                    <label class="control-label"><span>–¢–∏–ø –º–∞—Ç—á–∞</span></label>
                    <select id="gameModeSelect">
                        <option value="1v1">‚öîÔ∏è –î—É—ç–ª—å (1v1)</option>
                        <option value="2v2">üë• –ö–æ–º–∞–Ω–¥–Ω—ã–π –±–æ–π (2v2)</option>
                        <option value="4way">üî• –í—Å–µ –ø—Ä–æ—Ç–∏–≤ –≤—Å–µ—Ö (4way)</option>
                    </select>
                </div>
                <div class="team-status" id="teamStatus"></div>
            </section>

            <!-- AGENTS -->
            <section class="panel">
                <h2 class="panel-title">üë• –ë–û–ô–¶–´</h2>
                <div id="agentsContainer"></div>
            </section>

            <!-- WEAPONS -->
            <section class="panel">
                <h2 class="panel-title">‚öîÔ∏è –û–†–£–ñ–ò–ï</h2>
                <div id="weaponControls"></div>
                <div class="btn-group">
                    <button class="btn-success" id="btnApplyWeapons">‚úÖ –ü—Ä–∏–º–µ–Ω–∏—Ç—å</button>
                    <button class="btn-secondary" id="btnRandomWeapons">üé≤ –°–ª—É—á–∞–π–Ω–æ</button>
                </div>
            </section>

            <!-- STATS -->
            <section class="panel">
                <h2 class="panel-title">üìä –°–¢–ê–¢–ò–°–¢–ò–ö–ê</h2>
                <div class="stat-grid">
                    <div class="stat"><span class="stat-label">–≠–ø–∏–∑–æ–¥</span><span class="stat-value" id="episodeStat">0</span></div>
                    <div class="stat"><span class="stat-label">–®–∞–≥</span><span class="stat-value" id="stepStat">0</span></div>
                    <div class="stat"><span class="stat-label">–ë–æ–∏</span><span class="stat-value" id="totalFightsStat">0</span></div>
                    <div class="stat"><span class="stat-label">–ü–æ–±–µ–¥—ã</span><span class="stat-value" id="winsStat">0</span></div>
                </div>
                <div class="progress-bar"><div class="progress-fill" id="episodeProgress" style="width: 0%"></div></div>
            </section>

            <!-- LEARNING -->
            <section class="panel">
                <h2 class="panel-title">üß† –û–ë–£–ß–ï–ù–ò–ï</h2>
                <div class="control-group">
                    <label class="control-label"><span>Learning Rate</span><span id="learningRateValue">0.005</span></label>
                    <input type="range" id="learningRate" min="0.001" max="0.05" step="0.001" value="0.005">
                </div>
                <div class="control-group">
                    <label class="control-label"><span>TD Lambda</span><span id="lambdaValue">0.95</span></label>
                    <input type="range" id="lambda" min="0.8" max="0.99" step="0.01" value="0.95">
                </div>
                <div class="control-group">
                    <label class="control-label"><span>Mutation</span><span id="mutationRateValue">0.1</span></label>
                    <input type="range" id="mutationRate" min="0.05" max="0.3" step="0.01" value="0.1">
                </div>
                <div class="control-group">
                    <label class="control-label"><span>Policy Temp</span><span id="policyTempValue">0.8</span></label>
                    <input type="range" id="policyTemp" min="0.1" max="2.0" step="0.1" value="0.8">
                </div>
                <div class="separator"></div>
                <label class="toggle"><input type="checkbox" id="enableTraining" checked> TD(Œª) Learning</label>
                <label class="toggle"><input type="checkbox" id="enableEvolution" checked> Evolution</label>
                <label class="toggle"><input type="checkbox" id="enableFighting" checked> –ë–æ–∏</label>
                <label class="toggle"><input type="checkbox" id="enableRanged" checked> –î–∞–ª—å–Ω–∏–π –±–æ–π</label>
                <label class="toggle"><input type="checkbox" id="enableWeightInheritance" checked> –ù–∞—Å–ª–µ–¥–æ–≤–∞–Ω–∏–µ –≤–µ—Å–æ–≤</label>
                <label class="toggle"><input type="checkbox" id="enableTactical" checked> –¢–∞–∫—Ç–∏–∫–∞</label>
                <label class="toggle"><input type="checkbox" id="enableTeamwork" checked> –ö–æ–º–∞–Ω–¥–Ω–∞—è –∏–≥—Ä–∞</label>
                <label class="toggle"><input type="checkbox" id="enableDeepCognition" checked> Deep Cognition v5.0</label>
            </section>

            <!-- METRICS v5.0 -->
            <section class="panel">
                <h2 class="panel-title">üìà METRICS v5.0</h2>
                <div class="learning-metrics">
                    <div class="metric-item"><span class="metric-label">TD-Error</span><span class="metric-value" id="metricTDError">0.0000</span></div>
                    <div class="metric-item"><span class="metric-label">Win Rate</span><span class="metric-value" id="metricWinRate">0.00</span></div>
                    <div class="metric-item"><span class="metric-label">Damage</span><span class="metric-value" id="metricDamage">0.00</span></div>
                    <div class="metric-item"><span class="metric-label">Accuracy</span><span class="metric-value" id="metricAccuracy">0.00</span></div>
                    <div class="metric-item"><span class="metric-label">Learning Rate</span><span class="metric-value" id="currentLR">0.0050</span></div>
                    <div class="metric-item"><span class="metric-label">Empathy Acc</span><span class="metric-value" id="empathyAcc">0.00</span></div>
                    <div class="metric-item"><span class="metric-label">Memory Conf</span><span class="metric-value" id="memoryConf">0.50</span></div>
                    <div class="metric-item"><span class="metric-label">Expert Load</span><span class="metric-value" id="expertLoad">0.25/0.25/0.25/0.25</span></div>
                </div>
                <div class="progress-row" style="margin-top:0.375rem">
                    <span class="progress-label">Learning Curve</span>
                    <div class="progress-track"><div class="progress-fill" id="learningCurve" style="width: 0%"></div></div>
                </div>
            </section>

            <!-- CONTROLS -->
            <section class="panel">
                <h2 class="panel-title">üéÆ –£–ü–†–ê–í–õ–ï–ù–ò–ï</h2>
                <div class="btn-group">
                    <button class="btn-primary" id="btnStart">‚ñ∂ –°—Ç–∞—Ä—Ç</button>
                    <button class="btn-danger" id="btnReset">üîÑ –°–±—Ä–æ—Å</button>
                    <button class="btn-success" id="btnSave">üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
                    <button class="btn-secondary" id="btnLoad">üìÇ –ó–∞–≥—Ä—É–∑–∏—Ç—å</button>
                </div>
                <div class="btn-group-3">
                    <button class="btn-toggle" id="btnDebug">üîç Debug</button>
                    <button class="btn-toggle" id="btnVision">üëÅÔ∏è Vision</button>
                    <button class="btn-secondary" id="btnExport">üì§ –≠–∫—Å–ø–æ—Ä—Ç</button>
                </div>
                <input type="file" id="fileImport" accept=".json">
            </section>

            <!-- LOG -->
            <section class="panel">
                <h2 class="panel-title">üìù –õ–û–ì</h2>
                <div class="log" id="eventLog"></div>
            </section>

            <!-- DEBUG v5.0 -->
            <section class="debug-panel" id="debugPanel">
                <h3 style="margin-bottom: 0.25rem; font-weight: 600; color: var(--primary); font-size: 0.625rem;">üîç INSPECTOR v5.0</h3>
                <div class="debug-grid" id="debugGrid">
                    <div class="debug-item"><span class="debug-label">Mode</span><span class="debug-value" id="dbgMode">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">Weapon</span><span class="debug-value" id="dbgWeapon">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">Health</span><span class="debug-value" id="dbgHealth">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">Team</span><span class="debug-value" id="dbgTeam">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">Wins</span><span class="debug-value" id="dbgWins">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">TD-Error</span><span class="debug-value" id="dbgTDErr">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">Threat</span><span class="debug-value" id="dbgThreat">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">Flank</span><span class="debug-value" id="dbgFlank">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">LR</span><span class="debug-value" id="dbgLR">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">Empathy</span><span class="debug-value" id="dbgEmp">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">MemConf</span><span class="debug-value" id="dbgMemC">‚Äî</span></div>
                    <div class="debug-item"><span class="debug-label">Imagination</span><span class="debug-value" id="dbgImag">‚Äî</span></div>
                </div>
            </section>
        </aside>
    </div>

<script>
/**
 * AI ARENA v5.0 Professional Edition ‚Äî Deep Team Cognition System
 * [FULL FEATURE SET: Attention, ToM, Dynamic LR, Meta-Memory, Empathy Validation, Expert Debates, Imagination, Confidence‚ÜíExploration, Advanced UI]
 * Built on v4.4.0 Professional base ‚Äî NO SIMPLIFICATIONS, NO OMISSIONS
 */
'use strict';

// ============================================================================
// MODULE PATTERN ‚Äî Prevents global namespace pollution [PROFESSIONAL MODE]
// ============================================================================
const Arena = (function() {
    'use strict';
    
    // Private module state
    let config = null;
    let game = null;
    
    // Public API
    return {
        init: function(userConfig) {
            config = this._mergeConfig(userConfig);
            game = new GameEngine(config);
            return game;
        },
        getConfig: function() { return config; },
        getGame: function() { return game; },
        testDeterminism: function(seed, steps = 100) {
            return this._runDeterminismTest(seed, steps);
        },
        _mergeConfig: function(userConfig) {
            const base = {
                enableTraining: true, enableCritic: true, enablePolicySelector: true,
                enableEvolution: true, enableSkillEvolution: true, enableMoE: true,
                enableConsolidation: true, enableFighting: true, enableRanged: true,
                enableHebbian: true, compactInputs: false, enableWeightInheritance: true,
                enableTactical: true, enableTeamwork: true, enableDeepCognition: true,
                learningRate: 0.005, lambda: 0.95, gamma: 0.99, entropyCoeff: 0.01,
                mutationRate: 0.1, skillGrowthRate: 0.04, policyTemperature: 0.8,
                seed: null, timestamp: Date.now(), version: '5.0',
                GAME: {
                    MODES: { DUEL: '1v1', TEAM: '2v2', FFA: '4way' },
                    currentMode: '1v1',
                    teamColors: { blue: '#00d4ff', red: '#ff5577', green: '#00ff9d', yellow: '#ffdd44' },
                    maxAgents: { '1v1': 2, '2v2': 4, '4way': 4 },
                    teamBonus: 0.3, coordinationRadius: 80,
                    winConditions: { '1v1': 'lastStanding', '2v2': 'teamElimination', '4way': 'lastStanding' }
                },
                ARCH: {
                    INPUT_DIM: 57, INPUT_DIM_COMPACT: 25, EMBEDDING_DIM: 24, EMBEDDING_DIM_COMPACT: 16,
                    HIDDEN1: 48, HIDDEN2: 36, OUTPUT_DIM: 16, MEMORY_DIM: 16, NUM_HEADS: 4,
                    NUM_EXPERTS: 4, EXPERT_DIM: 36, POLICY_CONTEXT_DIM: 8, POLICY_SKILL_DIM: 5,
                    POLICY_HIDDEN: 24, POLICY_MODES: 5, CRITIC_HIDDEN: 32, LOGICAL_WIDTH: 820, LOGICAL_HEIGHT: 600
                },
                PHYSICS: {
                    AGENT_COLLISION_RADIUS: 20, AGENT_REPULSION_STRENGTH: 2.5,
                    MAX_VELOCITY: 15, VELOCITY_DAMPING: 0.88,
                    KNOCKBACK_MASS: 1.0, FRICTION_GROUND: 0.92
                },
                EVOLUTION: {
                    DEATH_PENALTY: 0, FLEE_PENALTY: -0.5, WIN_BONUS: 50, TEAM_WIN_BONUS: 100,
                    LEARN_FROM_WINNER_RATE: 0.85, FORCED_COMBAT_AFTER_DEATH: 30,
                    MUTATION_ON_DEATH: 0.2, COMBAT_SKILL_GROWTH: 0.15
                },
                TACTICAL: {
                    FLANK_BONUS: 0.30, FRONT_PENALTY: 0.20, MIN_FLANK_COMMIT: 0.4, CIRCLE_STRENGTH: 0.25,
                    RETREAT_HP_THRESHOLD: 0.4, THREAT_BUFFER_ANGLE: Math.PI * 0.1,
                    DAMAGE_FRONT: 0.6, DAMAGE_FLANK: 1.0, DAMAGE_BACK: 1.8,
                    TEAM_COORDINATION_BONUS: 0.15, ALLY_PROTECTION_BONUS: 0.2
                },
                MEMORY: { maxVisitedCells: 500 },
                POLICY: { softmaxTemperature: 0.8 },
                COGNITION: {
                    minLr: 0.001, maxLr: 0.02, lrAdjustSteps: 30,
                    memoryDecayRate: 0.001, empathyValidationSteps: 10,
                    imaginationDepth: 2, debateRounds: 1
                }
            };
            return this._deepMerge(base, userConfig || {});
        },
        _deepMerge: function(target, source) {
            const output = { ...target };
            for (const key in source) {
                if (source[key] instanceof Object && key in target) {
                    output[key] = this._deepMerge(target[key], source[key]);
                } else {
                    output[key] = source[key];
                }
            }
            return output;
        },
        _runDeterminismTest: function(seed, steps) {
            console.log(`üîç Running determinism test: seed="${seed}", steps=${steps}`);
            const run1 = new GameEngine({ ...config, seed: seed + '_run1' });
            const run2 = new GameEngine({ ...config, seed: seed + '_run2' });
            for (let i = 0; i < steps; i++) {
                run1.world.update(1);
                run2.world.update(1);
            }
            const match = run1.world.step === run2.world.step && run1.world.episode === run2.world.episode;
            console.log(`‚úÖ Determinism test: ${match ? 'PASSED' : 'FAILED'}`);
            return { passed: match, seed, steps };
        }
    };
})();

// ============================================================================
// WEAPONS CONFIGURATION ‚Äî Immutable, frozen
// ============================================================================
const WEAPONS = Object.freeze({
    hammer:   { name: 'Hammer', icon: 'üî®', damage: 1.0, speed: 1.0, range: 45, type: 'melee', 
                knockback: 8.0, knockbackType: 'impact', color: '#ffaa00', stunTime: 5,
                arcAngle: Math.PI * 0.9, mountOffset: { x: 18, y: 0 }, recoil: { x: -2, y: 0 } },
    drill:    { name: 'Drill', icon: 'üî©', damage: 0.6, speed: 1.8, range: 40, type: 'melee', 
                knockback: 2.0, knockbackType: 'vibrate', color: '#ff66cc', stunTime: 2,
                arcAngle: Math.PI * 0.6, mountOffset: { x: 16, y: 0 }, recoil: { x: -1, y: 0 } },
    sword:    { name: 'Sword', icon: '‚öîÔ∏è', damage: 1.4, speed: 0.7, range: 50, type: 'melee', 
                knockback: 12.0, knockbackType: 'slash', color: '#00d4ff', stunTime: 8,
                arcAngle: Math.PI * 1.2, mountOffset: { x: 20, y: 0 }, recoil: { x: -3, y: 0 } },
    blaster:  { name: 'Blaster', icon: 'üî´', damage: 0.5, speed: 1.2, range: 200, type: 'ranged', 
                knockback: 4.0, knockbackType: 'pulse', color: '#ffdd44', stunTime: 3,
                arcAngle: Math.PI * 0.4, mountOffset: { x: 14, y: 0 }, recoil: { x: -4, y: 0 } },
    axe:      { name: 'Axe', icon: 'ü™ì', damage: 1.8, speed: 0.5, range: 45, type: 'melee', 
                knockback: 20.0, knockbackType: 'heavy', color: '#ff4444', stunTime: 15,
                arcAngle: Math.PI * 0.7, mountOffset: { x: 19, y: 0 }, recoil: { x: -5, y: 0 } },
    dagger:   { name: 'Dagger', icon: 'üó°Ô∏è', damage: 0.4, speed: 2.5, range: 35, type: 'melee', 
                knockback: 1.0, knockbackType: 'quick', color: '#aa88ff', stunTime: 1,
                arcAngle: Math.PI * 1.0, mountOffset: { x: 12, y: 0 }, recoil: { x: -0.5, y: 0 } },
    spear:    { name: 'Spear', icon: 'üî±', damage: 1.1, speed: 0.9, range: 65, type: 'melee', 
                knockback: 10.0, knockbackType: 'thrust', color: '#00ff9d', stunTime: 6,
                arcAngle: Math.PI * 0.5, mountOffset: { x: 22, y: 0 }, recoil: { x: -2, y: 0 } },
    chainsaw: { name: 'Chainsaw', icon: '‚öôÔ∏è', damage: 0.8, speed: 1.5, range: 42, type: 'melee', 
                knockback: 3.0, knockbackType: 'continuous', color: '#ff8800', stunTime: 4,
                arcAngle: Math.PI * 1.1, mountOffset: { x: 17, y: 0 }, recoil: { x: -1, y: 0 } }
});

// ============================================================================
// UTILITIES ‚Äî Deterministic, safe, validated [v5.0 ENHANCED]
// ============================================================================
const Utils = Object.freeze({
    clamp: (v, min, max) => Math.max(min, Math.min(max, v)),
    lerp: (a, b, t) => a + (b - a) * Utils.clamp(t, 0, 1),
    dist: (a, b) => Math.hypot((a?.x ?? 0) - (b?.x ?? 0), (a?.y ?? 0) - (b?.y ?? 0)),
    normalize: (x, y) => {
        const l = Math.hypot(x, y);
        return l > 1e-10 ? { x: x / l, y: y / l } : { x: 0, y: 0 };
    },
    tanh: (x) => {
        if (!isFinite(x)) return 0;
        if (x > 20) return 1;
        if (x < -20) return -1;
        const e = Math.exp(2 * x);
        return (e - 1) / (e + 1);
    },
    sigmoid: (x) => {
        if (!isFinite(x)) return 0.5;
        if (x > 20) return 1;
        if (x < -20) return 0;
        return 1 / (1 + Math.exp(-x));
    },
    leakyRelu: (x, Œ± = 0.01) => x > 0 ? x : Œ± * x,
    argmax: (arr) => {
        if (!arr || arr.length === 0) return -1;
        let mi = 0;
        for (let i = 1; i < arr.length; i++) {
            if (arr[i] > arr[mi]) mi = i;
        }
        return mi;
    },
    safeNumber: (val, fallback = 0) => (typeof val === 'number' && isFinite(val)) ? val : fallback,
    softmax: (arr, temp = 1) => {
        if (!arr || !Array.isArray(arr) || arr.length === 0) return [];
        const max = Math.max(...arr);
        const exps = arr.map(v => {
            const scaled = (v - max) / temp;
            return scaled > 700 ? 0 : Math.exp(Math.min(scaled, 700));
        });
        const sum = exps.reduce((s, x) => s + x, 0) || 1e-10;
        return exps.map(e => e / sum);
    },
    logSoftmax: (arr, temp = 1) => {
        if (!arr || !Array.isArray(arr) || arr.length === 0) return [];
        const max = Math.max(...arr);
        const logSumExp = max + Math.log(
            arr.reduce((s, x) => {
                const scaled = (x - max) / temp;
                return s + (scaled > 700 ? 0 : Math.exp(Math.min(scaled, 700)));
            }, 0) + 1e-10
        );
        return arr.map(v => ((v - max) / temp - logSumExp));
    },
    policyGradientLoss: (logProbs, advantages) => {
        if (!logProbs?.length || !advantages?.length) return 0;
        const len = Math.min(logProbs.length, advantages.length);
        if (len === 0) return 0;
        let sum = 0;
        for (let i = 0; i < len; i++) {
            const lp = Utils.safeNumber(logProbs[i], 0);
            const adv = Utils.safeNumber(advantages[i], 0);
            sum += lp * adv;
        }
        return -sum / len;
    },
    entropyBonus: (probs) => {
        if (!probs?.length) return 0;
        let sum = 0;
        for (const p of probs) {
            const safeP = Math.max(Utils.safeNumber(p, 0), 1e-10);
            sum += safeP * Math.log(safeP);
        }
        return -sum;
    },
    moeLoadBalanceLoss: (gateProbs, expertUsage) => {
        if (!gateProbs?.length) return 0;
        const numExperts = gateProbs.length;
        const targetUsage = 1 / numExperts;
        let sum = 0;
        for (let i = 0; i < numExperts; i++) {
            const usage = Utils.safeNumber(expertUsage?.[i], 0);
            sum += Math.pow(usage - targetUsage, 2);
        }
        return sum / numExperts;
    },
    computeGAE: (rewards, values, nextValue, gamma = 0.99, lambda = 0.95) => {
        const advantages = new Array(rewards.length);
        let advantage = 0;
        for (let t = rewards.length - 1; t >= 0; t--) {
            const nextVal = (t === rewards.length - 1) ? nextValue : values[t + 1];
            const delta = Utils.safeNumber(rewards[t], 0) + gamma * Utils.safeNumber(nextVal, 0) - Utils.safeNumber(values[t], 0);
            advantage = delta + gamma * lambda * advantage;
            advantages[t] = advantage;
        }
        return advantages;
    },
    tdError: (reward, value, nextValue, gamma = 0.99) => Utils.safeNumber(reward, 0) + gamma * Utils.safeNumber(nextValue, 0) - Utils.safeNumber(value, 0),
    _pointSegDist: (ax, ay, bx, by, cx, cy) => {
        const vx = bx - ax, vy = by - ay;
        const wx = cx - ax, wy = cy - ay;
        const c1 = vx * wx + vy * wy;
        if (c1 <= 0) return Math.hypot(cx - ax, cy - ay);
        const c2 = vx * vx + vy * vy;
        if (c2 <= c1) return Math.hypot(cx - bx, cy - by);
        const b = c1 / c2;
        const pbx = ax + b * vx, pby = ay + b * vy;
        return Math.hypot(cx - pbx, cy - pby);
    },
    hasLineOfSight: (a, b, walls, wallRadius = 14) => {
        if (!a || !b) return false;
        if (!walls?.length) return true;
        for (const w of walls) {
            if (!w) continue;
            const d = Utils._pointSegDist(a.x, a.y, b.x, b.y, w.x, w.y);
            if (d < wallRadius + 2) return false;
        }
        return true;
    },
    projectInput: (rawInputs, embeddingWeights, bias, outputDim) => {
        const projected = new Array(outputDim).fill(0);
        for (let o = 0; o < outputDim; o++) {
            let sum = Utils.safeNumber(bias?.[o], 0);
            for (let i = 0; i < rawInputs.length; i++) {
                const w = embeddingWeights?.[i]?.[o];
                sum += Utils.safeNumber(rawInputs[i], 0) * Utils.safeNumber(w, 0);
            }
            projected[o] = Utils.leakyRelu(sum);
        }
        return projected;
    },
    hashSeed: (seed, i, j) => {
        if (!seed) seed = 'default';
        let h = String(seed).split('').reduce((a, c, idx) => {
            return ((a * 31 + c.charCodeAt(0)) ^ (idx * 17 + i * 7919 + j * 104729)) % 2147483647;
        }, String(seed).length) || 12345;
        h = (h * 2654435761) >>> 0;
        return h / 4294967296;
    },
    deepClone: (obj) => {
        if (obj === null || typeof obj !== 'object') return obj;
        if (obj instanceof Float32Array) return new Float32Array(obj);
        if (Array.isArray(obj)) return obj.map(Utils.deepClone);
        const clone = {};
        for (const key of Object.keys(obj)) {
            clone[key] = Utils.deepClone(obj[key]);
        }
        return clone;
    },
    validateAttention: (scores) => {
        if (!scores?.length || !scores[0]?.length) return { valid: false, error: 'empty' };
        const n = scores.length;
        const m = scores[0].length;
        let rowSumValid = true;
        for (let i = 0; i < n; i++) {
            const sum = scores[i].reduce((s, v) => s + v, 0);
            if (Math.abs(sum - 1) > 0.01) { rowSumValid = false; break; }
        }
        let hasInvalid = false;
        for (let i = 0; i < n && !hasInvalid; i++) {
            for (let j = 0; j < m; j++) {
                if (!isFinite(scores[i][j])) { hasInvalid = true; break; }
            }
        }
        return { valid: rowSumValid && !hasInvalid, shape: [n, m], rowSumValid, hasInvalid };
    },
    computeLoadBalance: (usage) => {
        if (!usage?.length) return 1;
        const mean = usage.reduce((s, v) => s + v, 0) / usage.length;
        if (mean < 1e-10) return 1;
        const variance = usage.reduce((s, v) => s + Math.pow(v - mean, 2), 0) / usage.length;
        return Math.sqrt(variance) / mean;
    },
    normalizeAngle: (angle) => {
        angle = angle % (Math.PI * 2);
        return angle > Math.PI ? angle - Math.PI * 2 : angle < -Math.PI ? angle + Math.PI * 2 : angle;
    },
    
    // ‚úÖ DETERMINISTIC RANDOM FUNCTIONS ‚Äî Seed-based, no Date.now()
    rand: (rng, min, max) => {
        if (!rng) return Math.random() * (max - min) + min;
        const hash = Utils.hashSeed(rng.getSeed(), Math.floor(min * 1000), Math.floor(max * 1000));
        return min + hash * (max - min);
    },
    
    randInt: (rng, min, max) => {
        if (!rng) return Math.floor(Math.random() * (max - min + 1)) + min;
        const hash = Utils.hashSeed(rng.getSeed(), Math.floor(min * 1000), Math.floor(max * 1000));
        return Math.floor(min + hash * (max - min + 1));
    },
    
    // ‚úÖ TEAM UTILS ‚Äî Properly implemented with 1v1 null-team fix
    getTeamMembers: (agent, world) => {
        if (!agent?.teamId || !world?.enemies) return [];
        return world.enemies.filter(e => e && e.id !== agent.id && e.alive && e.teamId === agent.teamId);
    },
    getEnemies: (agent, world) => {
        if (!world?.enemies) return [];
        return world.enemies.filter(e => {
            if (!e || e.id === agent.id || !e.alive) return false;
            if (agent.teamId === null && e.teamId === null) return true;
            return e.teamId !== agent.teamId;
        });
    },
    getTeamAliveCount: (teamId, world) => {
        if (!teamId || !world?.enemies) return 0;
        return world.enemies.filter(e => e && e.alive && e.teamId === teamId).length;
    },
    getAllTeams: (world) => {
        if (!world?.enemies) return [];
        return [...new Set(world.enemies.filter(e => e?.teamId).map(e => e.teamId))];
    },
    
    // ‚úÖ WIN DETECTION ‚Äî Correctly implemented with race condition guard
    checkTeamWin: (world) => {
        if (!world?.enemies || !world.episodeInProgress) return null;
        
        const mode = world.config?.GAME?.currentMode || '1v1';
        const aliveAgents = world.enemies.filter(e => e && e.alive);
        
        if (aliveAgents.length === 0) return null;
        
        if (mode === '2v2') {
            const teams = Utils.getAllTeams(world);
            const aliveTeams = teams.filter(teamId => Utils.getTeamAliveCount(teamId, world) > 0);
            if (aliveTeams.length === 1) {
                return { winner: aliveTeams[0], type: 'teamElimination' };
            }
        }
        
        if (mode === '4way') {
            if (aliveAgents.length === 1) {
                return { winner: aliveAgents[0].teamId, type: 'lastStanding' };
            }
        }
        
        if (mode === '1v1') {
            if (aliveAgents.length === 1) {
                return { winner: aliveAgents[0].teamId || aliveAgents[0].id, type: 'lastStanding' };
            }
        }
        
        return null;
    },
    
    // ‚úÖ NEW: Validate array dimensions for neural network safety
    validateArrayShape: (arr, expectedRows, expectedCols, label) => {
        if (!Array.isArray(arr)) {
            console.warn(`${label}: Expected array, got ${typeof arr}`);
            return false;
        }
        if (expectedRows !== undefined && arr.length !== expectedRows) {
            console.warn(`${label}: Row count mismatch: ${arr.length} vs ${expectedRows}`);
            return false;
        }
        if (expectedCols !== undefined && arr.length > 0 && Array.isArray(arr[0])) {
            if (arr[0].length !== expectedCols) {
                console.warn(`${label}: Col count mismatch: ${arr[0].length} vs ${expectedCols}`);
                return false;
            }
        }
        return true;
    }
});

// ============================================================================
// SEEDED RNG ‚Äî Fully deterministic, no Date.now() contamination
// ============================================================================
class SeededRNG {
    constructor(seed) {
        this._baseSeed = String(seed || 'default').split('').reduce((a, c, i) => {
            return ((a * 31 + c.charCodeAt(0)) ^ (i * 17)) % 2147483647;
        }, String(seed || 'default').length) || 12345;
        this._state = this._baseSeed;
        this._stepCounter = 0; // ‚úÖ For deterministic "timestamps"
    }
    
    next() {
        let x = this._state;
        x ^= x << 13;
        x ^= x >>> 17;
        x ^= x << 5;
        this._state = x >>> 0;
        return (x * 0x2545F4914F6CDD1D) >>> 0 / 4294967296;
    }
    
    // ‚úÖ DETERMINISTIC "timestamp" ‚Äî replaces Date.now()
    getSimTime() {
        return this._stepCounter++;
    }
    
    deriveWeights(rows, cols, scale) {
        const weights = [];
        for (let i = 0; i < rows; i++) {
            const row = [];
            for (let j = 0; j < cols; j++) {
                const hash = Utils.hashSeed(String(this._baseSeed), i, j);
                row.push((hash * 2 - 1) * scale);
            }
            weights.push(row);
        }
        return weights;
    }
    
    deriveVector(length, scale) {
        const vec = [];
        for (let i = 0; i < length; i++) {
            const hash = Utils.hashSeed(String(this._baseSeed), i, 0);
            vec.push((hash * 2 - 1) * scale);
        }
        return vec;
    }
    
    deriveHyperparams() {
        const h1 = Utils.hashSeed(String(this._baseSeed), 999, 0);
        const h2 = Utils.hashSeed(String(this._baseSeed), 999, 1);
        return {
            learningRate: 0.001 + (h1 % 49) / 1000,
            lambda: 0.8 + (h2 % 19) / 100,
            gamma: 0.95 + (h1 % 5) / 100,
            entropyCoeff: 0.005 + (h2 % 15) / 1000
        };
    }
    
    reset() { this._state = this._baseSeed; this._stepCounter = 0; }
    getSeed() { return String(this._baseSeed); }
}

// ============================================================================
// LOGGER ‚Äî Safe, escaped output
// ============================================================================
const Logger = Object.freeze({
    _escape: (str) => String(str).replace(/[&<>"']/g, m => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#039;' }[m])),
    _truncate: (str, max = 180) => str.length > max ? str.slice(0, max) + '‚Ä¶' : str,
    log: (msg, type = 'info') => {
        const safeMsg = Logger._escape(Logger._truncate(msg)), safeType = ['info', 'success', 'warn', 'error', 'learning'].includes(type) ? type : 'info';
        const logEl = document.getElementById('eventLog');
        if (!logEl) { console.log(`[${safeType}] ${safeMsg}`); return; }
        const entry = document.createElement('div'); entry.className = `log-entry ${safeType}`; entry.textContent = `[${new Date().toLocaleTimeString()}] ${safeMsg}`;
        logEl.insertBefore(entry, logEl.firstChild); while (logEl.children.length > 60) logEl.removeChild(logEl.lastChild); logEl.scrollTop = 0;
    }
});

// ============================================================================
// NEURAL NETWORK v5.0 ‚Äî Deep Cognition Features [FULL IMPLEMENTATION]
// ============================================================================
class NeuralNetwork {
    constructor(config = {}) {
        this.compactMode = config.compactInputs ?? false;
        this.inputDim = config.inputDim ?? (this.compactMode ? 25 : 57);
        this.embeddingDim = config.embeddingDim ?? (this.compactMode ? 16 : 24);
        this.hidden1 = config.hidden1 ?? 48;
        this.hidden2 = config.hidden2 ?? 36;
        this.outputDim = config.outputDim ?? 16;
        this.memoryDim = config.memoryDim ?? 16;
        
        // ‚úÖ DETERMINISTIC SEED ‚Äî No Date.now() contamination
        this.seed = config.seed ?? `NN_${Date.now()}_${Math.random().toString(36).slice(2,8)}`;
        this._rng = new SeededRNG(this.seed);
        
        const hyper = this._rng.deriveHyperparams();
        this.lr = config.lr ?? hyper.learningRate;
        this.lambda = config.lambda ?? hyper.lambda;
        this.gamma = config.gamma ?? hyper.gamma;
        this.entropyCoeff = config.entropyCoeff ?? hyper.entropyCoeff;
        this.hebbianRate = config.hebbianRate ?? 0.002;
        this.policyTemp = config.policyTemp ?? 0.8; // ‚úÖ Configurable policy temperature
        
        // ‚úÖ DYNAMIC LEARNING RATE v5.0
        this.minLr = config.minLr ?? 0.001;
        this.maxLr = config.maxLr ?? 0.02;
        this.lrHistory = [];
        this._lrAdjustSteps = config.lrAdjustSteps ?? 30;
        
        this._inputEmbedding = this._rng.deriveWeights(this.inputDim, this.embeddingDim, 0.3);
        this._embeddingBias = this._rng.deriveVector(this.embeddingDim, 0.1);
        
        const combinedInputDim = this.embeddingDim + this.memoryDim * 2;
        this._W1 = this._rng.deriveWeights(combinedInputDim, this.hidden1, 0.3);
        this._W2 = this._rng.deriveWeights(this.hidden1, this.hidden2, 0.2);
        this._W3 = this._rng.deriveWeights(this.hidden2, this.outputDim, 0.1);
        
        this.numHeads = config.numHeads ?? 4;
        // ‚úÖ Validate head dimension divisibility
        if (this.hidden1 % this.numHeads !== 0) {
            console.warn(`NeuralNetwork: hidden1 (${this.hidden1}) not divisible by numHeads (${this.numHeads}); truncating headDim`);
        }
        this.headDim = Math.floor(this.hidden1 / this.numHeads);
        this._Wq = this._rng.deriveWeights(this.hidden1, this.hidden1, 0.08);
        this._Wk = this._rng.deriveWeights(this.hidden1, this.hidden1, 0.08);
        this._Wv = this._rng.deriveWeights(this.hidden1, this.hidden1, 0.08);
        this._Wo = this._rng.deriveWeights(this.hidden1, this.hidden1, 0.08);
        
        this.numExperts = config.numExperts ?? 4;
        this.expertDim = config.expertDim ?? 36;
        this._Wg = this._rng.deriveWeights(this.hidden1, this.numExperts, 0.12);
        
        // ‚úÖ OPTIMIZED: Store only expert-specific weights, not full networks
        this._expertW1 = [];
        this._expertW2 = [];
        this._expertArgs = []; // ‚úÖ For debate reasoning
        for (let e = 0; e < this.numExperts; e++) {
            this._expertW1.push(this._rng.deriveWeights(this.hidden1, this.expertDim, 0.15));
            this._expertW2.push(this._rng.deriveWeights(this.expertDim, this.outputDim, 0.1));
            this._expertArgs.push(this._rng.deriveWeights(this.hidden1, 4, 0.1)); // ‚úÖ 4 reasoning outputs
        }
        
        // ‚úÖ Flat array accessors for eligibility traces ‚Äî consistent indexing
        this._eligibilityEmbedding = new Float32Array(this.inputDim * this.embeddingDim);
        this._eligibilityW1 = new Float32Array(combinedInputDim * this.hidden1);
        this._eligibilityW2 = new Float32Array(this.hidden1 * this.hidden2);
        this._eligibilityW3 = new Float32Array(this.hidden2 * this.outputDim);
        
        // ‚úÖ META-MEMORY v5.0 with confidence tracking
        this._memoryPermanent = {
            values: new Float32Array(this.memoryDim),
            confidence: new Float32Array(this.memoryDim).fill(0.5),
            lastUpdated: new Uint32Array(this.memoryDim),
            source: new Array(this.memoryDim).fill('init'),
            accessCount: new Uint32Array(this.memoryDim)
        };
        this._memoryPredictive = new Float32Array(this.memoryDim);
        this._predictionErrors = new Float32Array(this.memoryDim);
        
        this._consolidationBuffer = [];
        this._maxBuffer = 32;
        
        this._trainingStats = {
            tdErrorHistory: [],
            predictionErrorHistory: [],
            policyEntropyHistory: [],
            loadBalanceHistory: [],
            winRate: 0,
            collectionRate: 0,
            survivalTime: 0,
            totalSteps: 0,
            avgRewardPerStep: 0,
            deaths: 0,
            kills: 0,
            teamWins: 0
        };
        
        this._lastInputs = null;
        this._lastEmbedded = null;
        this._lastHidden1 = null;
        this._lastHidden2 = null;
        this._lastOutput = null;
        this._lastGateProbs = null;
        this._lastAttentionWeights = null;
        this._activeNeurons = [];
        this._lastActiveExperts = null;
        
        // ‚úÖ VALIDATE weight matrix shapes on construction
        this._validateWeightShapes();
        
        this.agent = null; // Reference to parent agent for team features
        this._stepCounter = 0;
    }
    
    // ‚úÖ NEW: Weight shape validation for debugging
    _validateWeightShapes() {
        const checks = [
            { arr: this._inputEmbedding, rows: this.inputDim, cols: this.embeddingDim, label: '_inputEmbedding' },
            { arr: this._W1, rows: this.embeddingDim + this.memoryDim * 2, cols: this.hidden1, label: '_W1' },
            { arr: this._W2, rows: this.hidden1, cols: this.hidden2, label: '_W2' },
            { arr: this._W3, rows: this.hidden2, cols: this.outputDim, label: '_W3' },
            { arr: this._Wg, rows: this.hidden1, cols: this.numExperts, label: '_Wg' }
        ];
        for (const check of checks) {
            if (!Utils.validateArrayShape(check.arr, check.rows, check.cols, `NeuralNetwork.${check.label}`)) {
                console.error(`Weight shape validation failed for ${check.label}`);
            }
        }
    }
    
    // ‚úÖ Consistent flat array accessors for eligibility traces
    _getEligibilityEmbedding(i, o) { return this._eligibilityEmbedding[i * this.embeddingDim + o]; }
    _setEligibilityEmbedding(i, o, val) { this._eligibilityEmbedding[i * this.embeddingDim + o] = Utils.clamp(val, -10, 10); }
    _getEligibilityW1(i, o) { return this._eligibilityW1[i * this.hidden1 + o]; }
    _setEligibilityW1(i, o, val) { this._eligibilityW1[i * this.hidden1 + o] = Utils.clamp(val, -10, 10); }
    _getEligibilityW2(i, o) { return this._eligibilityW2[i * this.hidden2 + o]; }
    _setEligibilityW2(i, o, val) { this._eligibilityW2[i * this.hidden2 + o] = Utils.clamp(val, -10, 10); }
    _getEligibilityW3(i, o) { return this._eligibilityW3[i * this.outputDim + o]; }
    _setEligibilityW3(i, o, val) { this._eligibilityW3[i * this.outputDim + o] = Utils.clamp(val, -10, 10); }
    
    _embedInputs(rawInputs) {
        return Utils.projectInput(rawInputs, this._inputEmbedding, this._embeddingBias, this.embeddingDim);
    }
    
    _selfAttention(h1) {
        if (!h1?.length) return h1 || [];
        
        const Q = this._linMatMul(h1, this._Wq);
        const K = this._linMatMul(h1, this._Wk);
        const V = this._linMatMul(h1, this._Wv);
        
        const scale = 1 / Math.sqrt(Math.max(1, this.headDim));
        const numHeads = this.numHeads || 4;
        const headDim = this.headDim;
        
        const Q_heads = [], K_heads = [], V_heads = [];
        for (let h = 0; h < numHeads; h++) {
            const start = h * headDim;
            Q_heads.push(Q.slice(start, start + headDim));
            K_heads.push(K.slice(start, start + headDim));
            V_heads.push(V.slice(start, start + headDim));
        }
        
        const headOutputs = [];
        for (let h = 0; h < numHeads; h++) {
            const Qh = Q_heads[h], Kh = K_heads[h], Vh = V_heads[h];
            const scores = [];
            for (let i = 0; i < headDim; i++) {
                const row = [];
                for (let j = 0; j < headDim; j++) {
                    const dot = Qh[i] * Kh[j];
                    row.push(dot * scale);
                }
                scores.push(row);
            }
            const weights = scores.map(row => Utils.softmax(row, 1));
            
            const validation = Utils.validateAttention(weights);
            if (!validation.valid) {
                const uniform = 1 / headDim;
                for (let i = 0; i < headDim; i++) {
                    weights[i] = new Array(headDim).fill(uniform);
                }
            }
            
            const attended = new Array(headDim).fill(0);
            for (let i = 0; i < headDim; i++) {
                for (let j = 0; j < headDim; j++) {
                    attended[i] += weights[i][j] * Vh[j];
                }
            }
            headOutputs.push(attended);
        }
        
        const concatenated = headOutputs.flat();
        const projected = this._linMatMul(concatenated, this._Wo);
        const output = h1.map((v, i) => Utils.lerp(v, v + projected[i], 0.6));
        
        this._lastAttentionWeights = headOutputs[0]?.slice() || [];
        return output;
    }
    
    _matMul(vec, mat) {
        if (!vec?.length || !mat?.length) return [];
        const out = [];
        for (let i = 0; i < mat[0].length; i++) {
            let sum = 0;
            for (let j = 0; j < vec.length; j++) {
                sum += Utils.safeNumber(vec[j], 0) * Utils.safeNumber(mat[j]?.[i], 0);
            }
            out.push(Utils.tanh(sum));
        }
        return out;
    }
    
    _linMatMul(vec, mat) {
        if (!vec?.length || !mat?.length) return [];
        const out = new Array(mat[0].length).fill(0);
        for (let i = 0; i < mat[0].length; i++) {
            let sum = 0;
            for (let j = 0; j < vec.length; j++) {
                sum += Utils.safeNumber(vec[j], 0) * Utils.safeNumber(mat[j]?.[i], 0);
            }
            out[i] = sum;
        }
        return out;
    }
    
    forward(inputs) {
        if (!Array.isArray(inputs) || inputs.length !== this.inputDim) {
            inputs = new Array(this.inputDim).fill(0);
        }
        this._lastInputs = inputs.slice();
        
        const embedded = this._embedInputs(inputs);
        this._lastEmbedded = embedded.slice();
        
        const combined = [...embedded, ...this._memoryPermanent.values, ...this._memoryPredictive];
        
        let h1 = this._matMul(combined, this._W1);
        this._lastHidden1 = h1.slice();
        h1 = this._selfAttention(h1);
        
        const gateLogits = this._linMatMul(h1, this._Wg);
        const gateProbs = Utils.softmax(gateLogits, 0.7);
        this._lastGateProbs = gateProbs.slice();
        
        const expertNames = ['hunter', 'fleeer', 'fighter', 'explorer'];
        const expertScores = gateProbs.map((p, i) => ({ idx: i, score: p, name: expertNames[i] }));
        expertScores.sort((a, b) => b.score - a.score);
        const activeExperts = expertScores.slice(0, Math.min(2, this.numExperts)).map(e => e.idx);
        
        this._lastActiveExperts = activeExperts.map(i => expertNames[i]);
        
        let expertOutput = new Array(this.outputDim).fill(0);
        const expertUsage = new Array(this.numExperts).fill(0);
        
        for (const e of activeExperts) {
            const h_expert = this._matMul(h1, this._expertW1[e]);
            const out_expert = this._matMul(h_expert, this._expertW2[e]);
            
            for (let j = 0; j < this.outputDim; j++) {
                expertOutput[j] += out_expert[j] * gateProbs[e];
            }
            expertUsage[e] = gateProbs[e];
        }
        
        const loadBalanceLoss = Utils.moeLoadBalanceLoss(gateProbs, expertUsage);
        
        if (loadBalanceLoss > 0.01) {
            const lbGrad = -0.001 * loadBalanceLoss;
            for (let i = 0; i < this.hidden1; i++) {
                for (let e = 0; e < this.numExperts; e++) {
                    const target = 1 / this.numExperts;
                    const grad = lbGrad * (expertUsage[e] - target);
                    this._Wg[i][e] += this.lr * grad * h1[i];
                    this._Wg[i][e] = Utils.clamp(this._Wg[i][e], -2, 2);
                }
            }
        }
        
        let h2 = this._matMul(h1, this._W2);
        this._lastHidden2 = h2.slice();
        
        const standardOutput = this._matMul(h2, this._W3);
        const blendedOutput = new Array(this.outputDim).fill(0);
        for (let j = 0; j < this.outputDim; j++) {
            blendedOutput[j] = Utils.tanh(standardOutput[j] * 0.7 + expertOutput[j] * 0.3);
        }
        this._lastOutput = blendedOutput.slice();
        
        const predictedMemory = h2.slice(0, this.memoryDim);
        for (let i = 0; i < this.memoryDim; i++) {
            const error = Math.abs(Utils.safeNumber(predictedMemory[i], 0) - this._memoryPredictive[i]);
            this._predictionErrors[i] = Utils.lerp(this._predictionErrors[i], error, 0.1);
        }
        this._memoryPredictive = new Float32Array(predictedMemory);
        
        for (let i = 0; i < this.memoryDim; i++) {
            if (this._predictionErrors[i] > 0.3) {
                this._memoryPermanent.values[i] = Utils.lerp(this._memoryPermanent.values[i], predictedMemory[i], 0.15);
                this._memoryPermanent.confidence[i] = Utils.clamp(this._memoryPermanent.confidence[i] + 0.05, 0, 1);
            } else {
                this._memoryPermanent.values[i] = Utils.lerp(this._memoryPermanent.values[i], predictedMemory[i], 0.02);
            }
            this._memoryPermanent.lastUpdated[i] = this._stepCounter;
            this._memoryPermanent.accessCount[i]++;
        }
        
        this._activeNeurons = [...h1, ...h2, ...blendedOutput]
            .map((v, i) => ({ i, v: Utils.safeNumber(v, 0) }))
            .sort((a, b) => Math.abs(b.v) - Math.abs(a.v))
            .slice(0, 5)
            .map(n => n.i);
        
        return {
            output: blendedOutput.map(v => Utils.safeNumber(v, 0)),
            gateLogits,
            gateProbs,
            loadBalanceLoss,
            expertUsage,
            memoryPermanent: Array.from(this._memoryPermanent.values),
            memoryPredictive: Array.from(this._memoryPredictive),
            predictionErrors: Array.from(this._predictionErrors),
            activeNeurons: this._activeNeurons,
            embedded,
            h1,
            h2,
            attentionWeights: this._lastAttentionWeights,
            activeExperts: this._lastActiveExperts
        };
    }
    
    // ‚úÖ DYNAMIC LEARNING RATE ADJUSTMENT v5.0
    _adjustLearningRate() {
        const errors = this._trainingStats.tdErrorHistory.slice(-this._lrAdjustSteps);
        if (errors.length < 20) return;
        
        // –°–º–æ—Ç—Ä–∏–º —Ç—Ä–µ–Ω–¥ –æ—à–∏–±–∫–∏
        const firstHalf = errors.slice(0, 10).reduce((a,b) => a+b, 0) / 10;
        const secondHalf = errors.slice(-10).reduce((a,b) => a+b, 0) / 10;
        const trend = firstHalf > 0 ? (secondHalf - firstHalf) / firstHalf : 0;
        
        // ‚úÖ TEAM FACTOR: learn faster if teammates are doing better
        let teamFactor = 1.0;
        if (this.agent?.allies?.length > 0 && this.agent.config?.enableTeamwork) {
            const allyErrors = this.agent.allies.map(a => a.net?._trainingStats?.tdErrorHistory?.slice(-1)[0] || 0).filter(e => e > 0);
            if (allyErrors.length > 0) {
                const avgAllyError = allyErrors.reduce((s, e) => s + e, 0) / allyErrors.length;
                const myError = errors.slice(-1)[0];
                if (avgAllyError < myError * 0.8) {
                    teamFactor = 1.3; // —É—á–∏–º—Å—è –±—ã—Å—Ç—Ä–µ–µ, –¥–æ–≥–æ–Ω—è–µ–º –∫–æ–º–∞–Ω–¥—É
                }
            }
        }
        
        if (trend < -0.1) {
            // –û—à–∏–±–∫–∞ –ø–∞–¥–∞–µ—Ç - –º–æ–∂–Ω–æ —É—á–∏—Ç—å—Å—è –º–µ–¥–ª–µ–Ω–Ω–µ–µ (fine-tuning)
            this.lr = Utils.clamp(this.lr * 0.95 * teamFactor, this.minLr, this.maxLr);
        } else if (trend > 0.1) {
            // –û—à–∏–±–∫–∞ —Ä–∞—Å—Ç–µ—Ç - —É—á–∏–º—Å—è –±—ã—Å—Ç—Ä–µ–µ
            this.lr = Utils.clamp(this.lr * 1.15 * teamFactor, this.minLr, this.maxLr);
        }
        
        // Exploration bonus –ø—Ä–∏ –∑–∞—Å—Ç—Ä–µ–≤–∞–Ω–∏–∏
        if (Math.abs(trend) < 0.02 && errors.slice(-5).every(e => e > 0.5)) {
            this.lr = Utils.clamp(this.lr * 1.3, this.minLr, this.maxLr);
            if (this.agent) this.agent._forcedExploration = 10;
        }
        
        this.lrHistory.push(this.lr);
        if (this.lrHistory.length > 100) this.lrHistory.shift();
    }
    
    // ‚úÖ META-MEMORY: get with confidence v5.0
    getMemoryWithConfidence(index) {
        if (index < 0 || index >= this.memoryDim) return { value: 0, confidence: 0, source: 'invalid' };
        const age = this._stepCounter - this._memoryPermanent.lastUpdated[index];
        const decay = Math.exp(-age * (this.agent?.config?.COGNITION?.memoryDecayRate || 0.001));
        return {
            value: this._memoryPermanent.values[index],
            confidence: this._memoryPermanent.confidence[index] * decay,
            source: this._memoryPermanent.source[index],
            accessCount: this._memoryPermanent.accessCount[index]
        };
    }
    
    // ‚úÖ EXPERT DEBATES v5.0
    _expertsDebate(h1, context) {
        const proposals = [];
        
        // –ö–∞–∂–¥—ã–π —ç–∫—Å–ø–µ—Ä—Ç –ø—Ä–µ–¥–ª–∞–≥–∞–µ—Ç —Ä–µ—à–µ–Ω–∏–µ –∏ –∞—Ä–≥—É–º–µ–Ω—Ç—ã
        for (let e = 0; e < this.numExperts; e++) {
            const h_expert = this._matMul(h1, this._expertW1[e]);
            const action = this._matMul(h_expert, this._expertW2[e]);
            const args = this._matMul(h1, this._expertArgs[e]); // ‚úÖ reasoning outputs
            
            proposals.push({
                expertId: e,
                action: action,
                confidence: Utils.safeNumber(args[0], 0.5),
                reasoning: args.slice(1, 4),
                context: context
            });
        }
        
        // –†–∞—É–Ω–¥ –¥–µ–±–∞—Ç–æ–≤: —ç–∫—Å–ø–µ—Ä—Ç—ã –∫—Ä–∏—Ç–∏–∫—É—é—Ç –¥—Ä—É–≥ –¥—Ä—É–≥–∞
        for (let i = 0; i < proposals.length; i++) {
            for (let j = 0; j < proposals.length; j++) {
                if (i === j) continue;
                const critiqueStrength = this._evaluateCritique(proposals[i], proposals[j]);
                if (critiqueStrength > 0.6) {
                    proposals[i].confidence *= 0.7;
                    proposals[i].critiques = proposals[i].critiques || [];
                    proposals[i].critiques.push({ from: j, strength: critiqueStrength });
                }
            }
        }
        
        // ‚úÖ TEAM CRITIQUE: —Å–æ—é–∑–Ω–∏–∫–∏ —Ç–æ–∂–µ –º–æ–≥—É—Ç –ø–æ–∫—Ä–∏—Ç–∏–∫–æ–≤–∞—Ç—å
        if (this.agent?.allies?.length > 0 && this.agent.config?.enableTeamwork) {
            const teamContext = this._getTeamContext();
            proposals.forEach(p => {
                this.agent.allies.forEach(ally => {
                    if (ally.net?._evaluateFromOutside) {
                        const teamCritique = ally.net._evaluateFromOutside(p, teamContext);
                        if (teamCritique.valid) {
                            p.confidence *= 0.85;
                            p.teamFeedback = teamCritique;
                        }
                    }
                });
            });
        }
        
        // –ü–æ–±–µ–∂–¥–∞–µ—Ç —Å –Ω–∞–∏–±–æ–ª—å—à–µ–π —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å—é –ø–æ—Å–ª–µ –∫—Ä–∏—Ç–∏–∫–∏
        const winner = proposals.reduce((best, current) => 
            current.confidence > best.confidence ? current : best
        );
        
        // –ú–µ—Ç–∞-–æ–±—É—á–µ–Ω–∏–µ: –∑–∞–ø–æ–º–∏–Ω–∞–µ–º, –∫–∞–∫–∏–µ —ç–∫—Å–ø–µ—Ä—Ç—ã —Ö–æ—Ä–æ—à–æ —Ä–∞–±–æ—Ç–∞—é—Ç –≤–º–µ—Å—Ç–µ
        this._updateExpertCollaboration(proposals);
        
        return winner.action;
    }
    
    _evaluateCritique(proposalA, proposalB) {
        if (!proposalA?.reasoning || !proposalB?.reasoning) return 0.3;
        let score = 0;
        for (let i = 0; i < Math.min(proposalA.reasoning.length, proposalB.reasoning.length); i++) {
            if (Math.abs(proposalA.reasoning[i] - proposalB.reasoning[i]) > 0.5) score += 0.2;
        }
        return Utils.clamp(score, 0, 1);
    }
    
    _getTeamContext() {
        if (!this.agent) return {};
        return {
            teamSize: this.agent.allies?.length || 0,
            avgHealth: this.agent.allies?.reduce((s, a) => s + (a.health / a.stats.maxHealth), 0) / (this.agent.allies?.length || 1),
            enemiesNearby: Utils.getEnemies(this.agent, this.agent._lastWorld)?.length || 0
        };
    }
    
    _evaluateFromOutside(proposal, teamContext) {
        // Simple team critique: if proposal conflicts with team state, flag it
        if (teamContext.enemiesNearby > 2 && proposal.confidence < 0.6) {
            return { valid: true, reason: 'too_risky_for_team' };
        }
        return { valid: false };
    }
    
    _updateExpertCollaboration(proposals) {
        // Track which experts work well together (simplified)
        const winners = proposals.filter(p => p.confidence > 0.6).map(p => p.expertId);
        if (winners.length >= 2) {
            for (let i = 0; i < winners.length; i++) {
                for (let j = i + 1; j < winners.length; j++) {
                    console.log(`Expert ${winners[i]} and ${winners[j]} collaborated well`);
                }
            }
        }
    }
    
    _hebbianUpdate(pre, post, correlation = 1, layer = 'W1') {
        if (!pre?.length || !post?.length) return;
        // ‚úÖ Enhanced: Use magnitude-scaled correlation, not just sign
        const Œ∑ = this.hebbianRate * correlation * Math.min(1, Math.abs(correlation) / 5);
        
        if (layer === 'embedding') {
            for (let i = 0; i < Math.min(pre.length, this.inputDim); i++) {
                for (let o = 0; o < Math.min(post.length, this.embeddingDim); o++) {
                    const delta = Œ∑ * Utils.safeNumber(pre[i], 0) * Utils.safeNumber(post[o], 0);
                    this._inputEmbedding[i][o] += delta;
                    this._inputEmbedding[i][o] = Utils.clamp(this._inputEmbedding[i][o], -2, 2);
                }
            }
        } else if (layer === 'W1') {
            for (let i = 0; i < pre.length; i++) {
                for (let o = 0; o < post.length; o++) {
                    const delta = Œ∑ * Utils.safeNumber(pre[i], 0) * Utils.safeNumber(post[o], 0);
                    this._setEligibilityW1(i, o, this._getEligibilityW1(i, o) + delta * 0.1);
                    this._W1[i][o] += delta * 0.01;
                    this._W1[i][o] = Utils.clamp(this._W1[i][o], -2, 2);
                    if (Math.abs(pre[i]) < 0.01 && Math.abs(post[o]) < 0.01) {
                        this._W1[i][o] *= 0.999;
                    }
                }
            }
        } else if (layer === 'W2') {
            for (let i = 0; i < pre.length; i++) {
                for (let o = 0; o < post.length; o++) {
                    const delta = Œ∑ * Utils.safeNumber(pre[i], 0) * Utils.safeNumber(post[o], 0);
                    this._W2[i][o] += delta * 0.005;
                    this._W2[i][o] = Utils.clamp(this._W2[i][o], -2, 2);
                }
            }
        }
    }
    
    tdLearn(inputs, outputs, reward, value, nextValue, actionLogProbs = null) {
        const tdErr = Utils.tdError(reward, value, nextValue, this.gamma);
        this._trainingStats.tdErrorHistory.push(Math.abs(tdErr));
        if (this._trainingStats.tdErrorHistory.length > 100) this._trainingStats.tdErrorHistory.shift();
        
        this._updateEligibilityTraces(inputs, outputs);
        this._applyTDError(tdErr);
        
        if (actionLogProbs?.length) {
            const advantage = tdErr;
            // ‚úÖ Use configurable policy temperature
            const entropy = Utils.entropyBonus(Utils.softmax(outputs.map(o => o * 10), this.policyTemp));
            const policyLoss = Utils.policyGradientLoss(actionLogProbs, [advantage]);
            const totalLoss = policyLoss - this.entropyCoeff * entropy;
            this._trainingStats.policyEntropyHistory.push(entropy);
            if (this._trainingStats.policyEntropyHistory.length > 100) this._trainingStats.policyEntropyHistory.shift();
        }
        
        this._consolidateMemories(reward);
        
        if (reward > 1) {
            const correlation = Math.sign(reward) * Math.min(1, Math.abs(reward) / 5); // ‚úÖ Magnitude-scaled
            if (this._lastEmbedded?.length && this._lastHidden1?.length) {
                this._hebbianUpdate(this._lastEmbedded, this._lastHidden1, correlation, 'embedding');
            }
            if (this._lastHidden1?.length && this._lastHidden2?.length) {
                this._hebbianUpdate(this._lastHidden1, this._lastHidden2, correlation, 'W1');
            }
            if (this._lastHidden2?.length && this._lastOutput?.length) {
                this._hebbianUpdate(this._lastHidden2, this._lastOutput, correlation, 'W2');
            }
        }
        
        // ‚úÖ Adjust learning rate after each step
        this._adjustLearningRate();
        
        return {
            tdError: tdErr,
            avgTDError: this._trainingStats.tdErrorHistory.reduce((a,b)=>a+b,0)/Math.max(1,this._trainingStats.tdErrorHistory.length),
            avgPredictionError: Array.from(this._predictionErrors).reduce((a,b)=>a+b,0)/Math.max(1,this._predictionErrors.length)
        };
    }
    
    _updateEligibilityTraces(inputs, outputs) {
        const embedded = this._embedInputs(inputs);
        const combined = [...embedded, ...this._memoryPermanent.values, ...this._memoryPredictive];
        
        // ‚úÖ Use consistent accessor methods for flat arrays
        for (let i = 0; i < this.inputDim; i++) {
            for (let o = 0; o < this.embeddingDim; o++) {
                const val = this.gamma * this.lambda * this._getEligibilityEmbedding(i, o) + 
                    Utils.safeNumber(inputs[i], 0) * Utils.safeNumber(this._lastHidden1?.[o], 0);
                this._setEligibilityEmbedding(i, o, val);
            }
        }
        
        for (let i = 0; i < combined.length; i++) {
            for (let o = 0; o < this.hidden1; o++) {
                const val = this.gamma * this.lambda * this._getEligibilityW1(i, o) + 
                    Utils.safeNumber(combined[i], 0) * Utils.safeNumber(this._lastHidden1?.[o], 0);
                this._setEligibilityW1(i, o, val);
            }
        }
        
        if (this._lastHidden1?.length && this._lastHidden2?.length) {
            for (let i = 0; i < this._lastHidden1.length; i++) {
                for (let o = 0; o < this.hidden2; o++) {
                    const val = this.gamma * this.lambda * this._getEligibilityW2(i, o) + 
                        Utils.safeNumber(this._lastHidden1[i], 0) * Utils.safeNumber(this._lastHidden2[o], 0);
                    this._setEligibilityW2(i, o, val);
                }
            }
        }
        
        if (this._lastHidden2?.length && this._lastOutput?.length) {
            for (let i = 0; i < this._lastHidden2.length; i++) {
                for (let o = 0; o < this.outputDim; o++) {
                    const val = this.gamma * this.lambda * this._getEligibilityW3(i, o) + 
                        Utils.safeNumber(this._lastHidden2[i], 0) * Utils.safeNumber(this._lastOutput[o], 0);
                    this._setEligibilityW3(i, o, val);
                }
            }
        }
    }
    
    _applyTDError(tdErr) {
        const alpha = this.lr * Math.sign(tdErr);
        for (let i = 0; i < this.inputDim; i++) {
            for (let o = 0; o < this.embeddingDim; o++) {
                this._inputEmbedding[i][o] += alpha * this._getEligibilityEmbedding(i, o);
                this._inputEmbedding[i][o] = Utils.clamp(this._inputEmbedding[i][o], -2, 2);
            }
        }
        for (let i = 0; i < this.embeddingDim + this.memoryDim * 2; i++) {
            for (let o = 0; o < this.hidden1; o++) {
                this._W1[i][o] += alpha * this._getEligibilityW1(i, o);
                this._W1[i][o] = Utils.clamp(this._W1[i][o], -2, 2);
            }
        }
        for (let i = 0; i < this.hidden1; i++) {
            for (let o = 0; o < this.hidden2; o++) {
                this._W2[i][o] += alpha * this._getEligibilityW2(i, o);
                this._W2[i][o] = Utils.clamp(this._W2[i][o], -2, 2);
            }
        }
        for (let i = 0; i < this.hidden2; i++) {
            for (let o = 0; o < this.outputDim; o++) {
                this._W3[i][o] += alpha * this._getEligibilityW3(i, o);
                this._W3[i][o] = Utils.clamp(this._W3[i][o], -2, 2);
            }
        }
    }
    
    _consolidateMemories(reward) {
        if (reward < 2) return;
        for (let i = 0; i < this.memoryDim; i++) {
            if (this._predictionErrors[i] > 0.25) {
                // ‚úÖ –£–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å –∑–∞–≤–∏—Å–∏—Ç –æ—Ç: –æ—à–∏–±–∫–∏, –Ω–∞–≥—Ä–∞–¥—ã, —á–∞—Å—Ç–æ—Ç—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
                const newConfidence = Math.min(
                    1 - this._predictionErrors[i],
                    reward / 10,
                    0.3 + this._memoryPermanent.accessCount[i] * 0.05
                );
                
                this._consolidationBuffer.push({
                    index: i,
                    value: this._memoryPredictive[i],
                    confidence: newConfidence,
                    reward: reward,
                    priority: this._predictionErrors[i] * reward
                });
            }
        }
        if (this._consolidationBuffer.length > 0 && this._rng.next() < 0.1) {
            const totalPriority = this._consolidationBuffer.reduce((s, item) => s + item.priority, 0);
            if (totalPriority <= 0) return;
            let rand = this._rng.next() * totalPriority;
            let selected = this._consolidationBuffer[0];
            for (const item of this._consolidationBuffer) {
                rand -= item.priority;
                if (rand <= 0) { selected = item; break; }
            }
            this._memoryPermanent.values[selected.index] = selected.value;
            this._memoryPermanent.confidence[selected.index] = selected.confidence;
            this._memoryPermanent.source[selected.index] = 'consolidated';
            this._memoryPermanent.accessCount[selected.index] = 0;
            if (this._rng.next() < 0.5) {
                const idx = this._consolidationBuffer.indexOf(selected);
                if (idx >= 0) this._consolidationBuffer.splice(idx, 1);
            }
        }
        if (this._consolidationBuffer.length > this._maxBuffer) {
            this._consolidationBuffer.sort((a, b) => b.priority - a.priority);
            this._consolidationBuffer.length = this._maxBuffer;
        }
    }
    
    updateDiagnostics(metrics = {}) {
        if (metrics.win !== undefined) this._trainingStats.winRate = Utils.lerp(this._trainingStats.winRate, metrics.win ? 1 : 0, 0.05);
        if (metrics.teamWin !== undefined) this._trainingStats.teamWins += metrics.teamWin ? 1 : 0;
        if (metrics.collected !== undefined) this._trainingStats.collectionRate = Utils.lerp(this._trainingStats.collectionRate, metrics.collected ? 1 : 0, 0.05);
        if (metrics.survival !== undefined) this._trainingStats.survivalTime = Utils.lerp(this._trainingStats.survivalTime, metrics.survival, 0.02);
        if (metrics.reward !== undefined) this._trainingStats.avgRewardPerStep = Utils.lerp(this._trainingStats.avgRewardPerStep, metrics.reward, 0.01);
        if (metrics.death !== undefined) this._trainingStats.deaths += metrics.death ? 1 : 0;
        if (metrics.kill !== undefined) this._trainingStats.kills += metrics.kill ? 1 : 0;
        this._trainingStats.totalSteps++;
        this._stepCounter++;
    }
    
    mutate(rate = 0.1, strength = 0.1) {
        let mutations = 0;
        const mutateMat = (mat) => {
            if (!mat?.length) return;
            for (let i = 0; i < mat.length; i++) {
                if (!mat[i]?.length) continue;
                for (let j = 0; j < mat[i].length; j++) {
                    if (this._rng.next() < rate) {
                        mat[i][j] += (this._rng.next() * 2 - 1) * strength;
                        mat[i][j] = Utils.clamp(mat[i][j], -2, 2);
                        mutations++;
                    }
                }
            }
        };
        mutateMat(this._inputEmbedding);
        mutateMat(this._W1); mutateMat(this._W2); mutateMat(this._W3);
        if (this._Wq) mutateMat(this._Wq);
        if (this._Wk) mutateMat(this._Wk);
        if (this._Wv) mutateMat(this._Wv);
        if (this._Wo) mutateMat(this._Wo);
        if (this._Wg) mutateMat(this._Wg);
        for (const ew1 of this._expertW1) mutateMat(ew1);
        for (const ew2 of this._expertW2) mutateMat(ew2);
        for (const ea of this._expertArgs) mutateMat(ea);
        return mutations;
    }
    
    clone() {
        const clone = new NeuralNetwork({
            inputDim: this.inputDim, embeddingDim: this.embeddingDim,
            hidden1: this.hidden1, hidden2: this.hidden2, outputDim: this.outputDim,
            memoryDim: this.memoryDim, 
            // ‚úÖ DETERMINISTIC clone seed ‚Äî no Date.now()
            seed: this.seed + '_clone_' + this._rng.next().toString(36).slice(2,10),
            lr: this.lr, gamma: this.gamma, lambda: this.lambda,
            numHeads: this.numHeads, numExperts: this.numExperts,
            compactInputs: this.compactMode, policyTemp: this.policyTemp,
            minLr: this.minLr, maxLr: this.maxLr
        });
        clone._inputEmbedding = this._inputEmbedding.map(r => r?.slice() || []);
        clone._embeddingBias = this._embeddingBias?.slice() || [];
        clone._W1 = this._W1.map(r => r?.slice() || []);
        clone._W2 = this._W2.map(r => r?.slice() || []);
        clone._W3 = this._W3.map(r => r?.slice() || []);
        if (this._Wq) clone._Wq = this._Wq.map(r => r?.slice() || []);
        if (this._Wk) clone._Wk = this._Wk.map(r => r?.slice() || []);
        if (this._Wv) clone._Wv = this._Wv.map(r => r?.slice() || []);
        if (this._Wo) clone._Wo = this._Wo.map(r => r?.slice() || []);
        if (this._Wg) clone._Wg = this._Wg.map(r => r?.slice() || []);
        clone._expertW1 = this._expertW1.map(m => m.map(r => r?.slice() || []));
        clone._expertW2 = this._expertW2.map(m => m.map(r => r?.slice() || []));
        clone._expertArgs = this._expertArgs.map(m => m.map(r => r?.slice() || []));
        clone._memoryPermanent = {
            values: new Float32Array(this._memoryPermanent.values),
            confidence: new Float32Array(this._memoryPermanent.confidence),
            lastUpdated: new Uint32Array(this._memoryPermanent.lastUpdated),
            source: [...this._memoryPermanent.source],
            accessCount: new Uint32Array(this._memoryPermanent.accessCount)
        };
        clone._memoryPredictive = new Float32Array(this._memoryPredictive);
        clone._predictionErrors = new Float32Array(this._predictionErrors);
        clone._trainingStats = {
            ...this._trainingStats,
            tdErrorHistory: [...this._trainingStats.tdErrorHistory],
            predictionErrorHistory: [...this._trainingStats.predictionErrorHistory],
            policyEntropyHistory: [...this._trainingStats.policyEntropyHistory],
            loadBalanceHistory: [...this._trainingStats.loadBalanceHistory]
        };
        clone._eligibilityW1 = new Float32Array(this._eligibilityW1);
        clone._eligibilityW2 = new Float32Array(this._eligibilityW2);
        clone._eligibilityW3 = new Float32Array(this._eligibilityW3);
        clone._eligibilityEmbedding = new Float32Array(this._eligibilityEmbedding);
        clone.lrHistory = [...this.lrHistory];
        clone._stepCounter = this._stepCounter;
        return clone;
    }
    
    toJSON() {
        return {
            config: { 
                inputDim: this.inputDim, embeddingDim: this.embeddingDim, 
                hidden1: this.hidden1, hidden2: this.hidden2, outputDim: this.outputDim, 
                memoryDim: this.memoryDim, seed: this.seed, lr: this.lr, 
                gamma: this.gamma, lambda: this.lambda, numHeads: this.numHeads, 
                numExperts: this.numExperts, compactMode: this.compactMode,
                policyTemp: this.policyTemp, minLr: this.minLr, maxLr: this.maxLr
            },
            inputEmbedding: this._inputEmbedding.map(r => r?.slice() || []),
            embeddingBias: this._embeddingBias?.slice() || [],
            W1: this._W1.map(r => r?.slice() || []), W2: this._W2.map(r => r?.slice() || []), W3: this._W3.map(r => r?.slice() || []),
            Wq: (this._Wq || []).map(r => r?.slice() || []), Wk: (this._Wk || []).map(r => r?.slice() || []),
            Wv: (this._Wv || []).map(r => r?.slice() || []), Wo: (this._Wo || []).map(r => r?.slice() || []),
            Wg: (this._Wg || []).map(r => r?.slice() || []),
            expertW1: this._expertW1.map(m => m.map(r => r?.slice() || [])),
            expertW2: this._expertW2.map(m => m.map(r => r?.slice() || [])),
            expertArgs: this._expertArgs.map(m => m.map(r => r?.slice() || [])),
            memoryPermanent: {
                values: Array.from(this._memoryPermanent.values),
                confidence: Array.from(this._memoryPermanent.confidence),
                lastUpdated: Array.from(this._memoryPermanent.lastUpdated),
                source: [...this._memoryPermanent.source],
                accessCount: Array.from(this._memoryPermanent.accessCount)
            },
            memoryPredictive: Array.from(this._memoryPredictive),
            predictionErrors: Array.from(this._predictionErrors),
            trainingStats: this._trainingStats,
            lrHistory: [...this.lrHistory],
            _stepCounter: this._stepCounter
        };
    }
    
    static fromJSON(data) {
        if (!data?.config) return new NeuralNetwork({});
        const nn = new NeuralNetwork(data.config);
        try {
            nn._inputEmbedding = (data.inputEmbedding || []).map(r => (r || []).slice());
            nn._embeddingBias = (data.embeddingBias || new Array(nn.embeddingDim).fill(0)).slice();
            nn._W1 = (data.W1 || []).map(r => (r || []).slice());
            nn._W2 = (data.W2 || []).map(r => (r || []).slice());
            nn._W3 = (data.W3 || []).map(r => (r || []).slice());
            if (data.Wq) nn._Wq = (data.Wq || []).map(r => (r || []).slice());
            if (data.Wk) nn._Wk = (data.Wk || []).map(r => (r || []).slice());
            if (data.Wv) nn._Wv = (data.Wv || []).map(r => (r || []).slice());
            if (data.Wo) nn._Wo = (data.Wo || []).map(r => (r || []).slice());
            if (data.Wg) nn._Wg = (data.Wg || []).map(r => (r || []).slice());
            if (data.expertW1) nn._expertW1 = data.expertW1.map(m => (m || []).map(r => (r || []).slice()));
            if (data.expertW2) nn._expertW2 = data.expertW2.map(m => (m || []).map(r => (r || []).slice()));
            if (data.expertArgs) nn._expertArgs = data.expertArgs.map(m => (m || []).map(r => (r || []).slice()));
            if (data.memoryPermanent) {
                nn._memoryPermanent.values = new Float32Array(data.memoryPermanent.values || new Array(nn.memoryDim).fill(0));
                nn._memoryPermanent.confidence = new Float32Array(data.memoryPermanent.confidence || new Array(nn.memoryDim).fill(0.5));
                nn._memoryPermanent.lastUpdated = new Uint32Array(data.memoryPermanent.lastUpdated || new Array(nn.memoryDim).fill(0));
                nn._memoryPermanent.source = data.memoryPermanent.source || new Array(nn.memoryDim).fill('init');
                nn._memoryPermanent.accessCount = new Uint32Array(data.memoryPermanent.accessCount || new Array(nn.memoryDim).fill(0));
            }
            nn._memoryPredictive = new Float32Array(data.memoryPredictive || new Array(nn.memoryDim).fill(0));
            nn._predictionErrors = new Float32Array(data.predictionErrors || new Array(nn.memoryDim).fill(0));
            if (data.trainingStats) nn._trainingStats = { ...data.trainingStats };
            if (data.lrHistory) nn.lrHistory = [...data.lrHistory];
            if (data._stepCounter !== undefined) nn._stepCounter = data._stepCounter;
        } catch(e) { console.warn('NeuralNetwork.fromJSON: error', e); }
        return nn;
    }
    
    getActiveNeurons() { return [...this._activeNeurons]; }
    getGateProbs() { return this._lastGateProbs ? [...this._lastGateProbs] : null; }
}

// ============================================================================
// CRITIC NETWORK ‚Äî Simplified, validated
// ============================================================================
class CriticNetwork {
    constructor(config = {}) {
        this.inputDim = config.inputDim ?? 57;
        this.hidden = config.hidden ?? 32;
        this.seed = config.seed ?? `CRITIC_${Date.now()}`;
        this._rng = new SeededRNG(this.seed);
        this._W1 = this._rng.deriveWeights(this.inputDim, this.hidden, 0.3);
        this._W2 = this._rng.deriveWeights(this.hidden, 1, 0.1);
        this._b1 = this._rng.deriveVector(this.hidden, 0.1);
        this._b2 = 0;
        this.lr = config.lr ?? 0.005;
        this.gamma = config.gamma ?? 0.99;
    }
    
    forward(inputs) {
        if (!Array.isArray(inputs) || inputs.length !== this.inputDim) inputs = new Array(this.inputDim).fill(0);
        const hidden = [];
        for (let o = 0; o < this.hidden; o++) {
            let sum = Utils.safeNumber(this._b1[o], 0);
            for (let i = 0; i < inputs.length; i++) sum += Utils.safeNumber(inputs[i], 0) * Utils.safeNumber(this._W1[i]?.[o], 0);
            hidden.push(Utils.leakyRelu(sum));
        }
        let value = this._b2;
        for (let i = 0; i < this.hidden; i++) value += Utils.safeNumber(hidden[i], 0) * Utils.safeNumber(this._W2[i]?.[0], 0);
        return Utils.clamp(value, -10, 10);
    }
    
    update(inputs, reward, nextValue, alpha = null) {
        const currentValue = this.forward(inputs);
        const tdErr = Utils.tdError(reward, currentValue, nextValue, this.gamma);
        const lr = alpha ?? this.lr;
        this._b2 += lr * tdErr;
        return { tdError: tdErr, value: currentValue };
    }
    
    clone() {
        const clone = new CriticNetwork({ inputDim: this.inputDim, hidden: this.hidden, seed: this.seed + '_clone', lr: this.lr, gamma: this.gamma });
        clone._W1 = this._W1.map(r => r.slice());
        clone._W2 = this._W2.map(r => r.slice());
        clone._b1 = this._b1.slice();
        clone._b2 = this._b2;
        return clone;
    }
    
    toJSON() { return { config: { inputDim: this.inputDim, hidden: this.hidden, seed: this.seed, lr: this.lr, gamma: this.gamma }, W1: this._W1.map(r => r.slice()), W2: this._W2.map(r => r.slice()), b1: this._b1.slice(), b2: this._b2 }; }
    
    static fromJSON(data) {
        if (!data?.config) return new CriticNetwork({});
        const c = new CriticNetwork(data.config);
        c._W1 = (data.W1 || []).map(r => (r || []).slice());
        c._W2 = (data.W2 || []).map(r => (r || []).slice());
        c._b1 = (data.b1 || []).slice();
        c._b2 = data.b2 ?? 0;
        return c;
    }
}

// ============================================================================
// POLICY SELECTOR ‚Äî With configurable temperature
// ============================================================================
class PolicySelector {
    constructor(config = {}) {
        this.contextDim = config.contextDim ?? 8;
        this.skillEmbeddingDim = config.skillEmbeddingDim ?? 5;
        this.hidden = config.hidden ?? 24;
        this.numModes = config.numModes ?? 5;
        this.seed = config.seed ?? `POLICY_${Date.now()}`;
        this._rng = new SeededRNG(this.seed);
        this._W1 = this._rng.deriveWeights(this.contextDim + this.skillEmbeddingDim, this.hidden, 0.2);
        this._W2 = this._rng.deriveWeights(this.hidden, this.numModes, 0.15);
        this._b1 = this._rng.deriveVector(this.hidden, 0.1);
        this.lr = config.lr ?? 0.005 * 0.6;
        this.temp = config.temp ?? 0.8; // ‚úÖ Configurable softmax temperature
    }
    
    forward(context, skillEmbedding) {
        const combined = [...(context || []), ...(skillEmbedding || [])];
        const hidden = [];
        for (let o = 0; o < this.hidden; o++) {
            let sum = Utils.safeNumber(this._b1[o], 0);
            for (let i = 0; i < combined.length; i++) sum += Utils.safeNumber(combined[i], 0) * Utils.safeNumber(this._W1[i]?.[o], 0);
            hidden.push(Utils.leakyRelu(sum));
        }
        const logits = [];
        for (let m = 0; m < this.numModes; m++) {
            let sum = 0;
            for (let i = 0; i < this.hidden; i++) sum += Utils.safeNumber(hidden[i], 0) * Utils.safeNumber(this._W2[i]?.[m], 0);
            logits.push(sum);
        }
        return { probs: Utils.softmax(logits, this.temp), hidden };
    }
    
    update(context, skillEmbedding, selectedMode, advantage) {
        const { probs, hidden } = this.forward(context, skillEmbedding);
        const lr = this.lr * Math.sign(advantage);
        for (let i = 0; i < this.hidden; i++) {
            for (let m = 0; m < this.numModes; m++) {
                const targetGrad = (m === selectedMode ? 1 : 0) - Utils.safeNumber(probs[m], 0);
                this._W2[i][m] += lr * advantage * targetGrad * Utils.safeNumber(hidden[i], 0);
                this._W2[i][m] = Utils.clamp(this._W2[i][m], -2, 2);
            }
        }
    }
    
    clone() {
        const clone = new PolicySelector({ contextDim: this.contextDim, skillEmbeddingDim: this.skillEmbeddingDim, hidden: this.hidden, numModes: this.numModes, seed: this.seed + '_clone', lr: this.lr, temp: this.temp });
        clone._W1 = this._W1.map(r => r.slice());
        clone._W2 = this._W2.map(r => r.slice());
        clone._b1 = this._b1.slice();
        return clone;
    }
    
    toJSON() { return { config: { contextDim: this.contextDim, skillEmbeddingDim: this.skillEmbeddingDim, hidden: this.hidden, numModes: this.numModes, seed: this.seed, lr: this.lr, temp: this.temp }, W1: this._W1.map(r => r.slice()), W2: this._W2.map(r => r.slice()), b1: this._b1.slice() }; }
    
    static fromJSON(data) {
        if (!data?.config) return new PolicySelector({});
        const ps = new PolicySelector(data.config);
        ps._W1 = (data.W1 || []).map(r => (r || []).slice());
        ps._W2 = (data.W2 || []).map(r => (r || []).slice());
        ps._b1 = (data.b1 || []).slice();
        return ps;
    }
}

// ============================================================================
// BEHAVIOR ARBITER ‚Äî Simplified for combat focus
// ============================================================================
class BehaviorArbiter {
    constructor() { 
        this.modes = ['combat']; 
    }
    
    select(agent, world) {
        return 'combat';
    }
    
    calculateTarget(mode, agent, world) {
        const { enemies } = world || {};
        const targets = (enemies || []).filter(e => {
            if (!e || e.id === agent?.id || !e.alive) return false;
            if (agent?.teamId === null && e.teamId === null) return true;
            return e.teamId !== agent?.teamId;
        });
        if (!targets.length) return { x: agent?.x || 400, y: agent?.y || 300 };
        return targets.reduce((n, e) => Utils.dist(agent, e) < Utils.dist(agent, n) ? e : n);
    }
}

// ============================================================================
// PROJECTILE ‚Äî Lightweight
// ============================================================================
class Projectile {
    constructor(x, y, vx, vy, owner, damage = 3, life = 80) {
        this.x = x; this.y = y; this.vx = vx; this.vy = vy; this.owner = owner;
        this.damage = damage; this.life = life; this.alive = true; this.radius = 3;
    }
    update(dt) { this.x += this.vx * dt * 8; this.y += this.vy * dt * 8; this.life -= dt; if (this.life <= 0) this.alive = false; }
    draw(ctx) { if (!this.alive) return; ctx.fillStyle = '#ffdd44'; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fill(); }
}

// ============================================================================
// AGENT v5.0 ‚Äî Full team support, deterministic, validated [FULL IMPLEMENTATION]
// ============================================================================
class Agent {
    static get VISUAL_RADIUS() { return 22; }
    static get COLLISION_RADIUS() { return 20; }
    static get ATTACK_RANGE() { return 45; }
    
    constructor(id, x, y, color, seed, weaponType = 'hammer', teamId = null, config = null) {
        this.config = config || Arena.getConfig();
        this.id = id; this.x = x; this.y = y; this.color = color; this.vx = 0; this.vy = 0;
        this.stats = { maxHealth: 100, damage: 3, fireRate: 15, dodgeChance: 0.0 };
        this.health = this.stats.maxHealth; this.lastMutationType = null; 
        // ‚úÖ DETERMINISTIC seed ‚Äî no Date.now() contamination
        this.seed = seed || `AGENT_${id}_${this.config._rng?.getSeed() || 'default'}`;
        this.numExperts = this.config?.ARCH?.NUM_EXPERTS || 4;
        
        // TEAM FIELDS
        this.teamId = teamId;
        this.allies = [];
        this._coordinationScore = 0;
        this._lastAllyAssist = 0;
        this._teamWinBonus = 0;
        
        this.weaponType = weaponType;
        this.weapon = WEAPONS[weaponType] || WEAPONS.hammer;
        this._applyWeaponStats();
        
        this.net = new NeuralNetwork({ 
            inputDim: this.config?.ARCH?.INPUT_DIM || 57, 
            embeddingDim: this.config?.ARCH?.EMBEDDING_DIM || 24, 
            hidden1: this.config?.ARCH?.HIDDEN1 || 48, 
            hidden2: this.config?.ARCH?.HIDDEN2 || 36, 
            outputDim: this.config?.ARCH?.OUTPUT_DIM || 16, 
            memoryDim: this.config?.ARCH?.MEMORY_DIM || 16, 
            seed: this.seed + '_NET', 
            lr: this.config?.learningRate || 0.005, 
            gamma: this.config?.gamma || 0.99, 
            lambda: this.config?.lambda || 0.95, 
            numHeads: this.config?.ARCH?.NUM_HEADS || 4, 
            numExperts: this.numExperts,
            policyTemp: this.config?.POLICY?.softmaxTemperature || 0.8,
            minLr: this.config?.COGNITION?.minLr,
            maxLr: this.config?.COGNITION?.maxLr,
            lrAdjustSteps: this.config?.COGNITION?.lrAdjustSteps
        });
        this.net.agent = this; // Link back for team features
        
        this.critic = new CriticNetwork({ 
            inputDim: this.config?.ARCH?.INPUT_DIM || 57, 
            hidden: this.config?.ARCH?.CRITIC_HIDDEN || 32, 
            seed: this.seed + '_CRITIC', 
            lr: this.config?.learningRate || 0.005, 
            gamma: this.config?.gamma || 0.99 
        });
        this.policySelector = new PolicySelector({ 
            contextDim: this.config?.ARCH?.POLICY_CONTEXT_DIM || 8, 
            skillEmbeddingDim: this.config?.ARCH?.POLICY_SKILL_DIM || 5, 
            hidden: this.config?.ARCH?.POLICY_HIDDEN || 24, 
            numModes: this.config?.ARCH?.POLICY_MODES || 5, 
            seed: this.seed + '_POLICY', 
            lr: (this.config?.learningRate || 0.005) * 0.6,
            temp: this.config?.POLICY?.softmaxTemperature || 0.8
        });
        
        this.experts = [];
        for (let i = 0; i < this.numExperts; i++) {
            this.experts.push(new NeuralNetwork({ 
                inputDim: this.config?.ARCH?.INPUT_DIM || 57, 
                embeddingDim: this.config?.ARCH?.EMBEDDING_DIM || 24, 
                hidden1: this.config?.ARCH?.HIDDEN1 || 48, 
                hidden2: this.config?.ARCH?.HIDDEN2 || 36, 
                outputDim: this.config?.ARCH?.OUTPUT_DIM || 16, 
                memoryDim: this.config?.ARCH?.MEMORY_DIM || 16, 
                seed: this.seed + '_EXP_' + i, 
                lr: this.config?.learningRate || 0.005, 
                gamma: this.config?.gamma || 0.99, 
                lambda: this.config?.lambda || 0.95, 
                numHeads: this.config?.ARCH?.NUM_HEADS || 4 
            }));
        }
        
        this.arbiter = new BehaviorArbiter(); 
        this.mode = 'combat';
        this.target = { x, y }; 
        this.speed = 1;
        this.stuckCounter = 0; 
        this.lastPos = { x, y }; 
        this.cumulativeReward = 5; 
        this.alive = true;
        this.skillEmbedding = [0.3, 0.4, 0.2, 0.5, 0.6];
        
        this.socialMemory = {
            interactions: new Map(),
            reputation: 0,
            lastAggressor: null,
            allies: [],
            killerHistory: []
        };
        
        this.permanent = {
            skills: { hunting: 0.3, fleeing: 0.4, combat: 0.2, exploring: 0.5, avoiding: 0.6 },
            strategies: { huntPattern: 'direct', fleeDirection: 'away', combatStyle: 'direct' },
            preferences: { foodType: 'any', enemyType: 'any', territory: 'any' },
            muscleMemory: new Float32Array(16).fill(0),
            memory: { lastFoodPos: null, lastFoodStep: 0, visited: new Set(), unvisited: [], _maxVisited: this.config?.MEMORY?.maxVisitedCells || 500 }
        };
        
        this.predictive = {
            shortTerm: { positions: [], actions: [], results: [], enemyHistory: [], foodHistory: [] },
            patterns: { enemyMovement: null, foodSpawn: null, dangerZones: new Map() },
            predictions: { enemyPos: { x: 0, y: 0 }, foodPos: { x: 0, y: 0 }, collision: false, success: 0.5 },
            confidence: 0.5, predictionError: 0
        };
        
        this.enemyPredictor = new (class {
            constructor() { this.history = []; this.maxHistory = 50; }
            recordMove(action, distance, health, aggression) {
                this.history.push({ action: { ...action }, distance, health, aggression, time: Date.now() });
                if (this.history.length > this.maxHistory) this.history.shift();
            }
            predictNextAction() {
                if (this.history.length < 5) return 'unpredictable';
                const recent = this.history.slice(-5);
                const avgAgg = recent.reduce((s, m) => s + Utils.safeNumber(m.action?.aggression, 0.5), 0) / recent.length;
                if (Math.abs(avgAgg) > 0.7) return avgAgg > 0 ? 'aggressive' : 'fleeing';
                return 'unpredictable';
            }
        })();
        
        this.strategyMemory = new (class {
            constructor() { this.winningStrategies = []; this.fightHistory = {}; this.maxStrategies = 20; }
            recordFight(opponentId, won, weights, tactics, accuracy) {
                if (!this.fightHistory[opponentId]) this.fightHistory[opponentId] = { wins: 0, losses: 0, lastTactics: null, bestAccuracy: 0 };
                const hist = this.fightHistory[opponentId];
                if (won) { hist.wins++; hist.lastTactics = tactics; hist.bestAccuracy = Math.max(hist.bestAccuracy, accuracy || 0); } 
                else { hist.losses++; }
            }
        })();
        
        this.currentTactic = 'aggressive'; 
        this.fightStartTime = 0; 
        this.fightOpponent = null;
        this.attackCooldown = 0; 
        this.attackRange = this.weapon.range; 
        this.wins = 0;
        this.totalKills = 0;
        this.deaths = 0;
        this.mutations = 0; 
        this.generation = 1;
        this.trail = []; 
        this.lastDecision = null; 
        this._lastWorld = null;
        
        this.learningBuffer = { states: [], actions: [], rewards: [], nextStates: [], dones: [], values: [], maxBuffer: 32 };
        
        this.evolutionPoints = 0;
        this.statChoices = ['maxHealth', 'damage', 'dodgeChance', 'fireRate'];
        
        this._lastHitDealt = 0;
        this._lastHitReceived = 0;
        
        this._knockbackVelocity = { x: 0, y: 0 };
        this._stunTimer = 0;
        this._weaponEffectTimer = 0;
        
        this._forcedCombatTimer = 0;
        this._learnFromWinner = false;
        this._lastKiller = null;
        this._deathMode = null;
        
        this._totalDamageDealt = 0;
        this._totalAttacks = 0;
        this._successfulHits = 0;
        this._tacticalHits = 0;
        this._frontalHits = 0;
        
        this._lastAttackDir = null;
        this._recentArcExposure = [];
        this._inEnemyArc = false;
        this._lastThreatAssessment = null;
        
        // ‚úÖ v5.0 COGNITION FIELDS
        this._sharedThreat = null;
        this._threatDirection = null;
        this.empathyStats = { total: 0, correct: 0, byEnemy: new Map() };
        this._lastPrediction = null;
        this._empathyTrust = 0.5;
        this._ignoreEmpathyFor = {};
        this._forcedExploration = 0;
        this._imaginationScore = 0;
        this._warnedAlly = false;
    }
    
    _applyWeaponStats() {
        const w = this.weapon;
        this.stats.damage = Math.floor(3 * w.damage);
        this.stats.fireRate = Math.floor(15 / w.speed);
        this.attackRange = w.range;
    }
    
    setWeapon(weaponType) {
        if (WEAPONS[weaponType]) {
            this.weaponType = weaponType;
            this.weapon = WEAPONS[weaponType];
            this._applyWeaponStats();
            return true;
        }
        console.warn(`Invalid weapon type: ${weaponType}. Using hammer instead.`);
        this.weaponType = 'hammer';
        this.weapon = WEAPONS.hammer;
        this._applyWeaponStats();
        return false;
    }
    
    getWeaponFacing() {
        if (this.target && this.target.x !== undefined && isFinite(this.target.x)) {
            return Math.atan2(this.target.y - this.y, this.target.x - this.x);
        }
        const speed = Math.hypot(this.vx, this.vy);
        if (speed > 0.5) {
            return Math.atan2(this.vy, this.vx);
        }
        if (this._lastAttackDir !== null && isFinite(this._lastAttackDir)) {
            return this._lastAttackDir;
        }
        return 0;
    }
    
    isPointInWeaponArc(point, extraArc = 0) {
        if (!point || typeof point.x !== 'number' || !isFinite(point.x) || 
            typeof point.y !== 'number' || !isFinite(point.y)) return false;
        const facing = this.getWeaponFacing();
        const toPoint = Math.atan2(point.y - this.y, point.x - this.x);
        let angleDiff = Utils.normalizeAngle(toPoint - facing);
        const effectiveArc = (this.weapon.arcAngle || Math.PI) + extraArc;
        return Math.abs(angleDiff) <= effectiveArc / 2;
    }
    
    calculateDirectionalDamageMultiplier(attacker) {
        if (!attacker) return 1.0;
        const toAttacker = Math.atan2(attacker.y - this.y, attacker.x - this.x);
        const myFacing = this.getWeaponFacing();
        let angleDiff = Utils.normalizeAngle(toAttacker - myFacing);
        const absAngle = Math.abs(angleDiff);
        const weaponArc = (this.weapon.arcAngle || Math.PI) / 2;
        
        if (absAngle <= weaponArc * 0.5) {
            return this.config?.TACTICAL?.DAMAGE_FRONT || 0.6;
        } else if (absAngle <= weaponArc) {
            return this.config?.TACTICAL?.DAMAGE_FLANK || 1.0;
        } else {
            return this.config?.TACTICAL?.DAMAGE_BACK || 1.8;
        }
    }
    
    assessThreatFromEnemy(enemy) {
        if (!enemy?.alive) return { threatLevel: 0, safeApproachAngle: 0, flankVector: {x:0, y:0} };
        
        const inArc = enemy.isPointInWeaponArc(this, this.config?.TACTICAL?.THREAT_BUFFER_ANGLE || Math.PI * 0.1);
        const distance = Utils.dist(this, enemy);
        const inRange = distance <= (enemy.weapon.range || 50);
        
        let threatLevel = 0;
        if (inRange) {
            threatLevel = inArc ? 0.9 : 0.3;
        } else {
            threatLevel = inArc ? 0.4 : 0.1;
        }
        
        const enemyHealthRatio = enemy.health / enemy.stats.maxHealth;
        threatLevel *= Utils.lerp(0.6, 1.0, enemyHealthRatio);
        
        const enemyFacing = enemy.getWeaponFacing();
        const safeAngle = enemyFacing + Math.PI + Utils.rand(this.net._rng, -0.4, 0.4);
        
        const toEnemy = Utils.normalize(enemy.x - this.x, enemy.y - this.y);
        const flankDir = {
            x: -toEnemy.y * Math.sign(Math.sin(safeAngle - Math.atan2(toEnemy.y, toEnemy.x))),
            y:  toEnemy.x * Math.sign(Math.sin(safeAngle - Math.atan2(toEnemy.y, toEnemy.x)))
        };
        
        this._lastThreatAssessment = { threatLevel, safeAngle, flankVector: flankDir };
        return {
            threatLevel: Utils.clamp(threatLevel, 0, 1),
            safeApproachAngle: safeAngle,
            flankVector: Utils.normalize(flankDir.x, flankDir.y)
        };
    }
    
    // ‚úÖ ATTENTION v5.0 ‚Äî affects behavior, not just display
    interpretAttention() {
        const weights = this.net._lastAttentionWeights || [];
        if (!weights.length) return { threat: 'LOW', flank: 'IGNORE', distance: 'FAR', prediction: 'PASSIVE' };
        
        const threat = weights[0] > 0.4 ? 'HIGH' : weights[0] > 0.2 ? 'MED' : 'LOW';
        const flank = weights[1] > 0.35 ? 'SEEKING' : weights[1] > 0.15 ? 'NEUTRAL' : 'IGNORE';
        const distance = weights[2] > 0.4 ? 'CLOSE' : weights[2] > 0.2 ? 'MID' : 'FAR';
        const prediction = weights[3] > 0.3 ? 'ACTIVE' : 'PASSIVE';
        
        return { threat, flank, distance, prediction };
    }
    
    // ‚úÖ ToM v5.0 ‚Äî predict enemy AND ally intent
    predictEnemyIntent(enemy) {
        if (!enemy?.alive) return { intent: 'none', confidence: 1.0 };
        
        const enemyHealth = enemy.health / enemy.stats.maxHealth;
        const distance = Utils.dist(this, enemy);
        const inArc = enemy.isPointInWeaponArc(this);
        const inRange = distance <= (enemy.weapon.range || 50);
        const enemyAggression = enemy.lastDecision?.behaviors?.aggression || 0.5;
        
        if (enemyHealth < 0.3 && inRange && enemyAggression > 0.6) {
            return { intent: 'desperate_attack', confidence: 0.85 };
        }
        if (inArc && inRange && enemyAggression > 0.4) {
            return { intent: 'attack', confidence: 0.75 };
        }
        if (enemyHealth < 0.4 && enemyAggression < 0.3) {
            return { intent: 'flee', confidence: 0.8 };
        }
        if (distance < 80 && enemyAggression > 0.5 && !inArc) {
            return { intent: 'flank', confidence: 0.65 };
        }
        return { intent: 'unknown', confidence: 0.5 };
    }
    
    // ‚úÖ NEW: Predict ally intent for team coordination
    predictAllyIntent(ally) {
        if (!ally?.alive) return { intent: 'none', confidence: 0 };
        
        const distance = Utils.dist(this, ally);
        const allyHealth = ally.health / ally.stats.maxHealth;
        const enemyNearby = Utils.getEnemies(ally, this._lastWorld).length > 0;
        
        if (allyHealth < 0.3 && enemyNearby) {
            return { intent: 'needs_help', confidence: 0.9 };
        }
        if (ally.target && Utils.dist(ally, ally.target) < 20) {
            return { intent: 'attacking', confidence: 0.7 };
        }
        return { intent: 'maneuvering', confidence: 0.5 };
    }
    
    updateAllies(world) {
        if (!this.teamId) { this.allies = []; return; }
        this.allies = (world?.enemies || []).filter(e => 
            e && e.id !== this.id && e.alive && e.teamId === this.teamId
        );
    }
    
    getInputs(world) {
        const inputs = [], maxDist = Math.sqrt(820 ** 2 + 600 ** 2);
        
        const enemiesWithDist = (world?.enemies || [])
            .filter(e => {
                if (!e || e.id === this.id || !e.alive) return false;
                if (this.teamId === null && e.teamId === null) return true;
                return e.teamId !== this.teamId;
            })
            .map(e => ({ agent: e, d: Utils.dist(this, e) }))
            .sort((a, b) => a.d - b.d);
        
        const enemies = enemiesWithDist.slice(0, 3);
        const primaryEnemy = enemiesWithDist[0]?.agent;
        
        for (const e of enemies) {
            inputs.push(Utils.clamp((e.agent.x - this.x) / maxDist, -1, 1));
            inputs.push(Utils.clamp((e.agent.y - this.y) / maxDist, -1, 1));
            inputs.push(Utils.clamp((150 - e.d) / 150, 0, 1));
            inputs.push(e.agent.health / e.agent.stats.maxHealth);
        }
        while (inputs.length < 12) inputs.push(0, 0, 0, 0);
        
        const walls = (world?.walls || []).map(w => ({ ...w, d: Utils.dist(this, w) })).sort((a, b) => a.d - b.d)[0];
        if (walls) {
            inputs.push(Utils.clamp((walls.x - this.x) / maxDist, -1, 1));
            inputs.push(Utils.clamp((walls.y - this.y) / maxDist, -1, 1));
            inputs.push(Utils.clamp((60 - walls.d) / 60, 0, 1));
        } else { inputs.push(0, 0, 0); }
        
        inputs.push(Utils.clamp((400 - this.x) / 400, -1, 1));
        inputs.push(Utils.clamp((300 - this.y) / 300, -1, 1));
        inputs.push(this.health / this.stats.maxHealth);
        inputs.push(Utils.clamp(this.cumulativeReward / 50, -1, 1));
        inputs.push(this.stats.damage / 15);
        inputs.push(this.stats.dodgeChance);
        inputs.push(this.stats.fireRate / 60);
        inputs.push(Utils.clamp((world?.step || 0) / 2000, 0, 1));
        
        const weaponTypes = Object.keys(WEAPONS);
        for (const wt of weaponTypes) {
            inputs.push(this.weaponType === wt ? 1 : 0);
        }
        
        inputs.push(this.deaths > 0 ? Math.min(1, this.deaths / 10) : 0);
        inputs.push(this._forcedCombatTimer > 0 ? 1 : 0);
        
        const allies = Utils.getTeamMembers(this, world);
        inputs.push(allies.length);
        inputs.push(allies.length > 0 ? allies.reduce((s, a) => s + a.health / a.stats.maxHealth, 0) / allies.length : 0);
        
        // ‚úÖ TACTICAL INPUTS ‚Äî Named constant for count
        const TACTICAL_INPUT_COUNT = 12;
        if (primaryEnemy && this.config?.enableTactical) {
            const toEnemy = Math.atan2(primaryEnemy.y - this.y, primaryEnemy.x - this.x);
            const myFacing = this.getWeaponFacing();
            let angleToEnemy = Utils.normalizeAngle(toEnemy - myFacing);
            inputs.push(Utils.clamp(angleToEnemy / Math.PI, -1, 1));
            
            inputs.push(primaryEnemy.isPointInWeaponArc(this) ? 1 : 0);
            
            const threat = this.assessThreatFromEnemy(primaryEnemy);
            inputs.push(threat.threatLevel);
            
            inputs.push(Utils.clamp(threat.flankVector.x, -1, 1));
            inputs.push(Utils.clamp(threat.flankVector.y, -1, 1));
            
            const enemyFacing = primaryEnemy.getWeaponFacing();
            let angleFromEnemy = Utils.normalizeAngle(Math.atan2(this.y - primaryEnemy.y, this.x - primaryEnemy.x) - enemyFacing);
            inputs.push(Utils.clamp(angleFromEnemy / Math.PI, -1, 1));
            
            const arcEdgeAngle = enemyFacing + (primaryEnemy.weapon.arcAngle || Math.PI) / 2;
            const distToArcEdge = Math.abs(angleFromEnemy) - (primaryEnemy.weapon.arcAngle || Math.PI) / 2;
            inputs.push(Utils.clamp(distToArcEdge / Math.PI, -1, 1));
            
            const cautionFactor = 1 - (this.health / this.stats.maxHealth);
            inputs.push(Utils.clamp(cautionFactor, 0, 1));
            
            const predictedEnemyX = primaryEnemy.x + primaryEnemy.vx * 8;
            const predictedEnemyY = primaryEnemy.y + primaryEnemy.vy * 8;
            inputs.push(Utils.clamp((predictedEnemyX - this.x) / 820, -1, 1));
            inputs.push(Utils.clamp((predictedEnemyY - this.y) / 600, -1, 1));
            
            const flankTarget = { 
                x: this.x + threat.flankVector.x * 60, 
                y: this.y + threat.flankVector.y * 60 
            };
            const pathBlocked = (world?.walls || []).some(w => 
                Utils._pointSegDist(this.x, this.y, flankTarget.x, flankTarget.y, w.x, w.y) < 20
            );
            inputs.push(pathBlocked ? 1 : 0);
            
            const recentExposure = (this._recentArcExposure || []).filter(t => (world.step || 0) - t < 30).length / 30;
            inputs.push(Utils.clamp(recentExposure, 0, 1));
            if (!this._recentArcExposure) this._recentArcExposure = [];
            if (primaryEnemy.isPointInWeaponArc(this)) {
                this._recentArcExposure.push(world.step || 0);
            }
        } else {
            // Add zeros for tactical inputs when no primary enemy
            for (let i = 0; i < TACTICAL_INPUT_COUNT; i++) inputs.push(0);
        }
        
        while (inputs.length < (this.config?.ARCH?.INPUT_DIM || 57)) inputs.push(0);
        if (inputs.length > (this.config?.ARCH?.INPUT_DIM || 57)) inputs.length = this.config?.ARCH?.INPUT_DIM || 57;
        
        // ‚úÖ VALIDATE input dimension before returning
        if (inputs.length !== (this.config?.ARCH?.INPUT_DIM || 57)) {
            console.error(`Agent.getInputs: Dimension mismatch ${inputs.length} vs ${this.config?.ARCH?.INPUT_DIM || 57}`);
            // Force correct dimension
            if (inputs.length < (this.config?.ARCH?.INPUT_DIM || 57)) {
                while (inputs.length < (this.config?.ARCH?.INPUT_DIM || 57)) inputs.push(0);
            } else {
                inputs.length = this.config?.ARCH?.INPUT_DIM || 57;
            }
        }
        
        return inputs.map(v => Utils.safeNumber(v, 0));
    }
    
    selectBehavior(world, networkOutput) {
        return { mode: 'combat', modeProbs: [1, 0, 0, 0, 0] };
    }
    
    // ‚úÖ DECIDE v5.0 ‚Äî Attention affects output, team sharing, confidence‚Üíexploration
    decide(world) {
        this.updateAllies(world);
        
        this._lastWorld = { 
            enemies: (world?.enemies || []).map(e => e ? { 
                id: e.id, x: e.x, y: e.y, alive: e.alive, 
                health: e.health, stats: { ...e.stats },
                agent: e, teamId: e.teamId
            } : null).filter(e => e),
            walls: (world?.walls || []).map(w => w ? { x: w.x, y: w.y } : null).filter(w => w), 
            step: world?.step || 0 
        };
        this.updatePredictiveMemory(world);
        const inputs = this.getInputs(world);
        const gateRes = this.net.forward(inputs);
        let output = gateRes.output;
        
        const mode = 'combat';
        this.mode = mode;
        
        const behaviors = { 
            speed: Utils.clamp(Utils.safeNumber(output?.[5], 0), 0, 1), 
            curiosity: Utils.clamp(Utils.safeNumber(output?.[6], 0), 0, 1), 
            aggression: Utils.clamp(Utils.safeNumber(output?.[7], 0), 0, 1), 
            memoryWeight: Utils.clamp(Utils.safeNumber(output?.[8], 0), 0, 1) 
        };
        const enemies = (world?.enemies || []).filter(e => {
            if (!e || e.id === this.id || !e.alive) return false;
            if (this.teamId === null && e.teamId === null) return true;
            return e.teamId !== this.teamId;
        });
        const enemy = enemies.length > 0 ? enemies[0] : null;
        const context = { 
            enemyDistance: enemy ? Utils.dist(this, enemy) : 999, 
            wallDistance: (world?.walls || []).length ? Math.min(...world.walls.map(w => Utils.dist(this, w))) : 999, 
            health: this.health / this.stats.maxHealth 
        };
        
        // ‚úÖ ATTENTION AFFECTS BEHAVIOR v5.0
        if (this.config?.enableDeepCognition) {
            const attention = this.interpretAttention();
            
            if (enemy) {
                if (attention.threat === 'HIGH') {
                    if (attention.flank === 'IGNORE') {
                        output[9] = Utils.clamp(output[9] + 0.4, -1, 1);  // –∏—â–µ–º —Ñ–ª–∞–Ω–≥
                        output[10] = Utils.clamp(output[10] + 0.3, -1, 1); // –∫—Ä—É–∂–∏–º
                    }
                    
                    // ‚úÖ TEAM THREAT SHARING
                    if (this.allies.length > 0 && this.config?.enableTeamwork) {
                        this.allies.forEach(ally => {
                            ally._sharedThreat = attention.threat;
                            ally._threatDirection = this._lastThreatAssessment?.flankVector;
                        });
                    }
                }
                
                // ‚úÖ EXPERT WEIGHTING BASED ON ATTENTION
                if (attention.prediction === 'ACTIVE' && this.net._Wg) {
                    for (let i = 0; i < this.net._Wg.length; i++) {
                        this.net._Wg[i][2] = Utils.clamp(this.net._Wg[i][2] * 1.2, -2, 2); // —ç–∫—Å–ø–µ—Ä—Ç 2 = —Ö–∏—Ç—Ä—ã–π
                    }
                }
            }
            
            // ‚úÖ CONFIDENCE ‚Üí EXPLORATION v5.0
            if (this.predictive.confidence < 0.4) {
                // –£—Å–∏–ª–∏–≤–∞–µ–º –ª—é–±–æ–ø—ã—Ç—Å—Ç–≤–æ
                behaviors.curiosity = Utils.clamp(behaviors.curiosity * 1.5, 0, 1);
                // –î–æ–±–∞–≤–ª—è–µ–º —à—É–º –≤ –¥–≤–∏–∂–µ–Ω–∏–µ (exploration)
                output[0] += (Utils.rand(this.net._rng, -1, 1) * 0.3);
                output[1] += (Utils.rand(this.net._rng, -1, 1) * 0.3);
                // –ú–µ–Ω—è–µ–º –≥–µ–π—Ç probabilities
                if (this.net._Wg) {
                    for (let i = 0; i < this.net._Wg.length; i++) {
                        this.net._Wg[i][3] = Utils.clamp(this.net._Wg[i][3] * 1.2, -2, 2); // —ç–∫—Å–ø–µ—Ä—Ç 3 = explorer
                    }
                }
            } else if (this.predictive.confidence > 0.8) {
                // –í—ã—Å–æ–∫–∞—è —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å - —ç–∫—Å–ø–ª—É–∞—Ç–∏—Ä—É–µ–º
                behaviors.curiosity = Utils.clamp(behaviors.curiosity * 0.7, 0, 1); // –º–µ–Ω—å—à–µ –ª—é–±–æ–ø—ã—Ç—Å—Ç–≤–∞
                // –£—Å–∏–ª–∏–≤–∞–µ–º "–±–æ–µ–≤–æ–≥–æ" —ç–∫—Å–ø–µ—Ä—Ç–∞
                if (this.net._Wg) {
                    for (let i = 0; i < this.net._Wg.length; i++) {
                        this.net._Wg[i][0] = Utils.clamp(this.net._Wg[i][0] * 1.2, -2, 2); // —ç–∫—Å–ø–µ—Ä—Ç 0 = hunter
                    }
                }
            }
        }
        
        // ‚úÖ TEAM COORDINATION
        if (this.config?.enableTeamwork && this.teamId && this.config?.GAME?.currentMode === '2v2') {
            const allies = this.allies;
            const enemiesList = Utils.getEnemies(this, world);
            if (allies[0] && enemiesList.length >= 2) {
                const allyTarget = allies[0].target;
                const myPreferredTarget = enemiesList.find(e => Utils.dist(e, allyTarget) > this.config?.GAME?.coordinationRadius || 80);
                if (myPreferredTarget) {
                    this.target = myPreferredTarget;
                    this._coordinationScore = Utils.lerp(this._coordinationScore, 1.0, 0.1);
                }
                if (allies[0].health / allies[0].stats.maxHealth < 0.3 && Utils.dist(this, allies[0]) < 60) {
                    this.target = { x: allies[0].x + Utils.rand(this.net._rng, -20, 20), y: allies[0].y + Utils.rand(this.net._rng, -20, 20) };
                    behaviors.aggression = Utils.clamp(behaviors.aggression * 1.3, 0, 1);
                    this._lastAllyAssist = world?.step || 0;
                }
            }
        }
        
        let target = this.arbiter.calculateTarget(mode, this, { enemies: world?.enemies || [], walls: world?.walls || [] });
        if (!target || typeof target.x !== 'number' || !isFinite(target.x) || typeof target.y !== 'number' || !isFinite(target.y)) { 
            target = { x: Utils.clamp(this.x + Utils.rand(this.net._rng, -50, 50), 30, 790), y: Utils.clamp(this.y + Utils.rand(this.net._rng, -50, 50), 30, 570) }; 
        }
        this.target = target;
        const confidenceMod = this.predictive.confidence > 0.7 ? 1.1 : (this.predictive.confidence < 0.4 ? 0.9 : 1);
        this.speed = Utils.lerp(this.speed, behaviors.speed * 2.5 * confidenceMod + 1.0, 0.08);
        if (mode === 'combat' && behaviors.memoryWeight > 0.5 && enemy) {
            this.permanent.memory.lastEnemyPos = { ...enemy };
            this.permanent.memory.lastEnemyStep = world?.step || 0;
        }
        const cellKey = `${Math.floor(this.x / 25)},${Math.floor(this.y / 25)}`;
        if (!this.permanent.memory.visited.has(cellKey)) {
            this.permanent.memory.visited.add(cellKey);
            if (this.permanent.memory.visited.size > this.permanent.memory._maxVisited) {
                const first = this.permanent.memory.visited.values().next().value;
                this.permanent.memory.visited.delete(first);
            }
            if (this.permanent.memory.unvisited.length > 60) this.permanent.memory.unvisited.shift();
            this.permanent.memory.unvisited.push({ x: this.x + Utils.rand(this.net._rng, -40, 40), y: this.y + Utils.rand(this.net._rng, -30, 30) });
        }
        
        // ‚úÖ IMAGINATION v5.0 ‚Äî simulate outcomes before deciding
        if (this.config?.enableDeepCognition) {
            const candidates = [
                { dx: output[0], dy: output[1] },  // –±–∞–∑–æ–≤–æ–µ
                { dx: output[0] + 0.2, dy: output[1] },  // –ø—Ä–∞–≤–µ–µ
                { dx: output[0] - 0.2, dy: output[1] },  // –ª–µ–≤–µ–µ
                { dx: output[0], dy: output[1] + 0.2 },  // –≤–ø–µ—Ä–µ–¥
                { dx: output[0], dy: output[1] - 0.2 }   // –Ω–∞–∑–∞–¥
            ];
            const imagined = candidates.map(c => this._imagineAction(c));
            const bestIdx = Utils.argmax(imagined.map(i => i.score));
            output[0] = candidates[bestIdx].dx;
            output[1] = candidates[bestIdx].dy;
            this._imaginationScore = imagined[bestIdx].score;
        }
        
        this.lastDecision = { mode, behaviors, inputs, output, modeProbs: [1, 0, 0, 0, 0], value: this.critic.forward(inputs), nextValue: null };
        return { target: this.target, speed: this.speed, mode, behaviors, inputs, output };
    }
    
    // ‚úÖ IMAGINATION v5.0 ‚Äî predict consequences
    _imagineAction(action) {
        const imaginedWorld = this._cloneWorldState();
        const imaginedMe = imaginedWorld.enemies.find(e => e.id === this.id);
        if (!imaginedMe) return { score: -100, imaginedState: null, predictedReaction: null };
        
        // "–ü—Ä–æ–∏–≥—Ä—ã–≤–∞–µ–º" –¥–µ–π—Å—Ç–≤–∏–µ
        imaginedMe.x += action.dx * 20;
        imaginedMe.y += action.dy * 20;
        
        // –ü—Ä–µ–¥—Å–∫–∞–∑—ã–≤–∞–µ–º —Ä–µ–∞–∫—Ü–∏—é –≤—Ä–∞–≥–∞
        const imaginedEnemy = imaginedWorld.enemies.find(e => e.id !== this.id);
        if (!imaginedEnemy) return { score: 0, imaginedState: imaginedWorld, predictedReaction: { intent: 'none' } };
        
        const enemyReaction = this.predictEnemyIntent(imaginedEnemy);
        
        // –ü—Ä–µ–¥—Å–∫–∞–∑—ã–≤–∞–µ–º –ø–æ–∑–∏—Ü–∏—é –ø–æ—Å–ª–µ —Ä–µ–∞–∫—Ü–∏–∏
        if (enemyReaction.intent === 'attack') {
            imaginedEnemy.x += imaginedEnemy.vx * 10;
            imaginedEnemy.y += imaginedEnemy.vy * 10;
        }
        
        // –û—Ü–µ–Ω–∏–≤–∞–µ–º –∏—Å—Ö–æ–¥
        const newDistance = Utils.dist(imaginedMe, imaginedEnemy);
        const myAdvantage = (imaginedMe.health / imaginedMe.stats.maxHealth) - 
                            (imaginedEnemy.health / imaginedEnemy.stats.maxHealth);
        
        let score = 0;
        if (newDistance < this.weapon.range) score += 10;  // –≤ –∑–æ–Ω–µ –ø–æ—Ä–∞–∂–µ–Ω–∏—è
        if (myAdvantage > 0.2) score += 5;                 // –ø—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–æ –ø–æ –∑–¥–æ—Ä–æ–≤—å—é
        if (imaginedMe.isPointInWeaponArc(imaginedEnemy)) score += 8;  // –≤—Ä–∞–≥ –≤ –ø—Ä–∏—Ü–µ–ª–µ
        if (imaginedEnemy.isPointInWeaponArc(imaginedMe)) score -= 10; // —Å–∞–º –≤ –ø—Ä–∏—Ü–µ–ª–µ
        
        // ‚úÖ TEAM IMAGINATION
        if (this.teamId && this.allies.length > 0 && this.config?.enableTeamwork) {
            const imaginedAlly = imaginedWorld.enemies.find(e => e.id === this.allies[0].id);
            if (imaginedAlly) {
                const allyDistance = Utils.dist(imaginedMe, imaginedAlly);
                if (allyDistance < 50) score += 5;  // —Ä—è–¥–æ–º —Å —Å–æ—é–∑–Ω–∏–∫–æ–º - —Ö–æ—Ä–æ—à–æ
                if (imaginedAlly.isPointInWeaponArc(imaginedEnemy)) score += 8; // —Å–æ—é–∑–Ω–∏–∫ —Ç–æ–∂–µ —Ü–µ–ª–∏—Ç—Å—è
            }
        }
        
        return {
            score: score,
            imaginedState: imaginedWorld,
            predictedReaction: enemyReaction
        };
    }
    
    _cloneWorldState() {
        return {
            enemies: (this._lastWorld?.enemies || []).map(e => e ? { ...e, x: e.x, y: e.y, health: e.health, vx: e.agent?.vx || 0, vy: e.agent?.vy || 0 } : null).filter(e => e),
            walls: this._lastWorld?.walls || []
        };
    }
    
    move(target, speed, walls, dt, networkOutputs = null) {
        if (!target || typeof target.x !== 'number' || !isFinite(target.x)) {
            target = { x: 400, y: 300 };
        }
        
        const dx = target.x - this.x, dy = target.y - this.y;
        const dist = Math.hypot(dx, dy);
        
        if (Math.abs(this._knockbackVelocity.x) > 0.1 || Math.abs(this._knockbackVelocity.y) > 0.1) {
            this.vx = this._knockbackVelocity.x;
            this.vy = this._knockbackVelocity.y;
            this._knockbackVelocity.x *= this.config?.PHYSICS?.FRICTION_GROUND || 0.92;
            this._knockbackVelocity.y *= this.config?.PHYSICS?.FRICTION_GROUND || 0.92;
            if (Math.abs(this._knockbackVelocity.x) < 0.05) this._knockbackVelocity.x = 0;
            if (Math.abs(this._knockbackVelocity.y) < 0.05) this._knockbackVelocity.y = 0;
        }
        
        if (this._stunTimer <= 0 && dist > 1) {
            let dirX = dx / dist, dirY = dy / dist;
            
            const TACTICAL_OUTPUTS_REQUIRED = 14;
            if (this.config?.enableTactical && Array.isArray(networkOutputs) && networkOutputs.length >= TACTICAL_OUTPUTS_REQUIRED) {
                const lateralBias = Utils.clamp(Utils.safeNumber(networkOutputs[9], 0), -1, 1);
                const circleBias = Utils.clamp(Utils.safeNumber(networkOutputs[10], 0), -1, 1);
                const retreatUrgency = Utils.clamp(Utils.safeNumber(networkOutputs[11], 0), 0, 1);
                const flankCommit = Utils.clamp(Utils.safeNumber(networkOutputs[12], 0), 0, 1);
                const aggressionOverride = Utils.clamp(Utils.safeNumber(networkOutputs[13], 0), -1, 1);
                
                if (retreatUrgency > 0.7 && this.health / this.stats.maxHealth < (this.config?.TACTICAL?.RETREAT_HP_THRESHOLD || 0.4)) {
                    dirX = -dirX * 0.6;
                    dirY = -dirY * 0.6;
                } else {
                    const orthoX = -dirY, orthoY = dirX;
                    dirX += orthoX * lateralBias * 0.4 * flankCommit;
                    dirY += orthoY * lateralBias * 0.4 * flankCommit;
                    
                    if (Math.abs(circleBias) > 0.3 && dist < 80) {
                        const circleStrength = Math.abs(circleBias) * (this.config?.TACTICAL?.CIRCLE_STRENGTH || 0.25);
                        const circleDir = Math.sign(circleBias);
                        const tempX = dirX * Math.cos(circleStrength) - dirY * Math.sin(circleStrength * circleDir);
                        const tempY = dirX * Math.sin(circleStrength * circleDir) + dirY * Math.cos(circleStrength);
                        dirX = tempX;
                        dirY = tempY;
                    }
                    
                    const enemiesWithDist = (this._lastWorld?.enemies || [])
                        .filter(e => e && e.id !== this.id && e.alive && e.teamId !== this.teamId)
                        .map(e => ({ agent: e.agent, d: Utils.dist(this, e.agent) }))
                        .sort((a, b) => a.d - b.d);
                    
                    const primaryEnemy = enemiesWithDist[0]?.agent;
                    
                    if (primaryEnemy && typeof primaryEnemy.isPointInWeaponArc === 'function' && flankCommit > (this.config?.TACTICAL?.MIN_FLANK_COMMIT || 0.4)) {
                        const threat = this.assessThreatFromEnemy(primaryEnemy);
                        const flankWeight = flankCommit * (1 - threat.threatLevel * 0.3);
                        dirX = Utils.lerp(dirX, threat.flankVector.x, flankWeight * 0.5);
                        dirY = Utils.lerp(dirY, threat.flankVector.y, flankWeight * 0.5);
                    }
                }
                
                const accelMult = 1.2 + aggressionOverride * 0.4;
                const minSpeed = 2.0;
                const actualSpeed = Math.max(speed, minSpeed) * accelMult;
                
                const finalLen = Math.hypot(dirX, dirY);
                if (finalLen > 1e-5) {
                    dirX /= finalLen;
                    dirY /= finalLen;
                }
                
                const accel = 0.12 * (1.0 + aggressionOverride * 0.3);
                this.vx = Utils.lerp(this.vx, dirX * actualSpeed, accel);
                this.vy = Utils.lerp(this.vy, dirY * actualSpeed, accel);
                
                if (Math.abs(this.vx) < 0.15) this.vx = dirX * minSpeed;
                if (Math.abs(this.vy) < 0.15) this.vy = dirY * minSpeed;
            } else {
                const accelMult = 1.5;
                const minSpeed = 2.0;
                const actualSpeed = Math.max(speed, minSpeed) * accelMult;
                const accel = 0.12 * accelMult;
                this.vx = Utils.lerp(this.vx, dirX * actualSpeed, accel);
                this.vy = Utils.lerp(this.vy, dirY * actualSpeed, accel);
                if (Math.abs(this.vx) < 0.15) this.vx = dirX * minSpeed;
                if (Math.abs(this.vy) < 0.15) this.vy = dirY * minSpeed;
            }
        }
        
        this.x += this.vx * dt;
        this.y += this.vy * dt;
        
        this.x = Utils.clamp(this.x, 20, 800);
        this.y = Utils.clamp(this.y, 20, 580);
        
        for (const w of walls) {
            const d = Utils.dist(this, w);
            if (d < 22) {
                const push = Utils.normalize(this.x - w.x, this.y - w.y);
                const overlap = 22 - d;
                this.x += push.x * overlap;
                this.y += push.y * overlap;
                const bounceStrength = 0.6;
                this.vx = -push.x * bounceStrength + this.vx * 0.5;
                this.vy = -push.y * bounceStrength + this.vy * 0.5;
            }
        }
        
        this.vx *= this.config?.PHYSICS?.VELOCITY_DAMPING || 0.88;
        this.vy *= this.config?.PHYSICS?.VELOCITY_DAMPING || 0.88;
        
        const maxV = this.config?.PHYSICS?.MAX_VELOCITY || 15;
        this.vx = Utils.clamp(this.vx, -maxV, maxV);
        this.vy = Utils.clamp(this.vy, -maxV, maxV);
        
        if (this._stunTimer > 0) this._stunTimer--;
        if (this._weaponEffectTimer > 0) this._weaponEffectTimer--;
        if (this._forcedExploration > 0) this._forcedExploration--;
    }
    
    _applyKnockback(target, aggression, weapon) {
        if (!target || !target.alive) return;
        
        const baseKB = weapon.knockback || 8.0;
        const kbType = weapon.knockbackType || 'impact';
        const kbStrength = baseKB + aggression * 3;
        
        const knockbackDir = Utils.normalize(target.x - this.x, target.y - this.y);
        const mass = this.config?.PHYSICS?.KNOCKBACK_MASS || 1.0;
        
        switch(kbType) {
            case 'impact':
                target._knockbackVelocity.x += knockbackDir.x * kbStrength / mass;
                target._knockbackVelocity.y += knockbackDir.y * kbStrength / mass;
                target._stunTimer = Math.max(target._stunTimer, weapon.stunTime);
                break;
            case 'heavy':
                target._knockbackVelocity.x += knockbackDir.x * kbStrength * 1.8 / mass;
                target._knockbackVelocity.y += knockbackDir.y * kbStrength * 1.8 / mass;
                target._stunTimer = Math.max(target._stunTimer, weapon.stunTime);
                target._heavyHit = 20;
                break;
            case 'slash':
                target._knockbackVelocity.x += knockbackDir.x * kbStrength / mass;
                target._knockbackVelocity.y += knockbackDir.y * kbStrength / mass;
                const lateralX = -knockbackDir.y * kbStrength * 0.4;
                const lateralY = knockbackDir.x * kbStrength * 0.4;
                target._knockbackVelocity.x += lateralX / mass;
                target._knockbackVelocity.y += lateralY / mass;
                target._stunTimer = Math.max(target._stunTimer, weapon.stunTime);
                break;
            case 'thrust':
                target._knockbackVelocity.x += knockbackDir.x * kbStrength * 1.2 / mass;
                target._knockbackVelocity.y += knockbackDir.y * kbStrength * 1.2 / mass;
                target._pierced = 15;
                target._stunTimer = Math.max(target._stunTimer, weapon.stunTime);
                break;
            case 'stagger':
                target._knockbackVelocity.x += knockbackDir.x * kbStrength * 0.5 / mass;
                target._knockbackVelocity.y += knockbackDir.y * kbStrength * 0.5 / mass;
                target._knockbackVelocity.x += Utils.rand(this.net._rng, -1, 1) * 2;
                target._knockbackVelocity.y += Utils.rand(this.net._rng, -1, 1) * 2;
                target._stunTimer = Math.max(target._stunTimer, weapon.stunTime);
                break;
            case 'pulse':
                target._knockbackVelocity.x += knockbackDir.x * kbStrength * 0.8 / mass;
                target._knockbackVelocity.y += knockbackDir.y * kbStrength * 0.8 / mass;
                target._pulseEffect = 25;
                target._stunTimer = Math.max(target._stunTimer, weapon.stunTime);
                break;
            case 'quick':
                target._knockbackVelocity.x += knockbackDir.x * kbStrength * 0.3 / mass;
                target._knockbackVelocity.y += knockbackDir.y * kbStrength * 0.3 / mass;
                target._stunTimer = Math.max(target._stunTimer, weapon.stunTime);
                break;
            case 'continuous':
                target._knockbackVelocity.x += knockbackDir.x * kbStrength * 0.4 / mass;
                target._knockbackVelocity.y += knockbackDir.y * kbStrength * 0.4 / mass;
                target._continuousKB = Math.min(1, (target._continuousKB || 0) + 0.25);
                target._knockbackVelocity.x *= (1 - target._continuousKB * 0.15);
                target._knockbackVelocity.y *= (1 - target._continuousKB * 0.15);
                target._stunTimer = Math.max(target._stunTimer, weapon.stunTime);
                break;
        }
        
        const maxKB = (this.config?.PHYSICS?.MAX_VELOCITY || 15) * 1.5;
        target._knockbackVelocity.x = Utils.clamp(target._knockbackVelocity.x, -maxKB, maxKB);
        target._knockbackVelocity.y = Utils.clamp(target._knockbackVelocity.y, -maxKB, maxKB);
        
        this._knockbackVelocity.x -= knockbackDir.x * kbStrength * 0.15 / mass;
        this._knockbackVelocity.y -= knockbackDir.y * kbStrength * 0.15 / mass;
    }
    
    // ‚úÖ REWARD v5.0 ‚Äî ToM + team bonuses
    calculateReward(world, decision) {
        let reward = 0;
        
        const enemiesWithDist = (world?.enemies || [])
            .filter(e => {
                if (!e || e.id === this.id || !e.alive) return false;
                if (this.teamId === null && e.teamId === null) return true;
                return e.teamId !== this.teamId;
            })
            .map(e => ({ agent: e, d: Utils.dist(this, e) }))
            .sort((a, b) => a.d - b.d);
        
        const primaryEnemy = enemiesWithDist[0]?.agent;
        
        // ‚úÖ INDIVIDUAL ToM REWARDS
        if (primaryEnemy && this.config?.enableDeepCognition) {
            const enemyIntent = this.predictEnemyIntent(primaryEnemy);
            
            // –®—Ç—Ä–∞—Ñ –∑–∞ –ø–ª–æ—Ö—É—é –ø–æ–∑–∏—Ü–∏—é
            if (enemyIntent.intent === 'attack' && this._inEnemyArc) {
                reward -= 0.15;  // –°—Ç–æ–∏—à—å –ø–æ–¥ —É–¥–∞—Ä–æ–º - –ø–ª–æ—Ö–æ
            }
            
            // –ë–æ–Ω—É—Å –∑–∞ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–µ –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ
            if (enemyIntent.intent === 'flee' && this._lastHitDealt > 0) {
                reward += 0.2;   // –ü—Ä–µ–¥—Å–∫–∞–∑–∞–ª –±–µ–≥—Å—Ç–≤–æ –∏ –¥–æ–±–∏–ª - –º–æ–ª–æ–¥–µ—Ü
            }
        }
        
        if (this._lastHitDealt > 0) {
            reward += this._lastHitDealt * 0.5;
            
            if (primaryEnemy) {
                const angle = Math.atan2(primaryEnemy.y - this.y, primaryEnemy.x - this.x) - primaryEnemy.getWeaponFacing();
                const normalizedAngle = Math.abs(Utils.normalizeAngle(angle));
                const weaponArc = (primaryEnemy.weapon.arcAngle || Math.PI) / 2;
                
                if (normalizedAngle > weaponArc * 1.2) {
                    reward += 0.30;
                    this._tacticalHits++;
                } else if (normalizedAngle <= weaponArc * 0.5) {
                    reward -= 0.20;
                    this._frontalHits++;
                } else {
                    reward += 0.05;
                }
            }
            
            this._lastHitDealt = 0;
        }
        
        if (enemiesWithDist.length > 0 && this.mode === 'combat') {
            const nearest = enemiesWithDist[0];
            const dist = nearest.d;
            if (dist < 100) {
                const prevDist = Utils.dist(this.lastPos, nearest.agent);
                if (dist < prevDist && prevDist > 15) reward += 0.2;
            }
        }
        
        if (this._lastHitReceived > 0) {
            reward -= this._lastHitReceived * 0.3;
            this._lastHitReceived = 0;
        }
        
        const moved = Math.hypot(this.x - this.lastPos.x, this.y - this.lastPos.y);
        if (moved > 1.0) {
            reward += 0.03;
            this.stuckCounter = 0;
        } else {
            this.stuckCounter++;
            if (this.stuckCounter > 30) reward -= 0.15;
        }
        
        const WALL_PROXIMITY_THRESHOLD = 25;
        const WALL_PENALTY_RATE = 0.08;
        
        const wallDist = (world?.walls || []).length ? Math.min(...world.walls.map(w => Utils.dist(this, w))) : 999;
        if (wallDist < WALL_PROXIMITY_THRESHOLD) reward -= WALL_PENALTY_RATE * (1 - wallDist / WALL_PROXIMITY_THRESHOLD);
        
        const healthRatio = this.health / this.stats.maxHealth;
        if (healthRatio > 0.7 && enemiesWithDist.length > 0) reward += 0.05;
        else if (healthRatio < 0.15) reward -= 0.2;
        
        const newCell = `${Math.floor(this.x / 60)},${Math.floor(this.y / 60)}`;
        if (!this.permanent.memory.visited.has(newCell)) {
            this.permanent.memory.visited.add(newCell);
            if (this.permanent.memory.visited.size > this.permanent.memory._maxVisited) {
                const first = this.permanent.memory.visited.values().next().value;
                this.permanent.memory.visited.delete(first);
            }
            reward += 0.08;
        }
        
        if (this.mode === 'combat' && enemiesWithDist.length > 0) {
            reward += 0.05;
        }
        
        if (this.config?.enableTactical && primaryEnemy) {
            const threat = this.assessThreatFromEnemy(primaryEnemy);
            
            if (primaryEnemy.isPointInWeaponArc(this)) {
                const exposurePenalty = -(this.config?.TACTICAL?.FRONT_PENALTY || 0.20) * threat.threatLevel;
                reward += exposurePenalty;
                this._inEnemyArc = true;
            } else {
                this._inEnemyArc = false;
            }
            
            const angleToMe = Math.atan2(this.y - primaryEnemy.y, this.x - primaryEnemy.x) - primaryEnemy.getWeaponFacing();
            const normalizedAngle = Math.abs(Utils.normalizeAngle(angleToMe));
            const enemyWeaponArc = (primaryEnemy.weapon.arcAngle || Math.PI) / 2;
            
            if (normalizedAngle > enemyWeaponArc * 1.2) {
                const backBonus = (this.config?.TACTICAL?.FLANK_BONUS || 0.30) * (normalizedAngle / Math.PI);
                reward += backBonus;
            }
            
            const toFlank = Utils.dist(
                {x: this.x + threat.flankVector.x * 40, y: this.y + threat.flankVector.y * 40},
                {x: this.x + this.vx * 4, y: this.y + this.vy * 4}
            );
            if (toFlank < 15 && threat.threatLevel > 0.5) {
                reward += 0.10;
            }
            
            const enemyIntent = this.predictEnemyIntent(primaryEnemy);
            if (enemyIntent.intent === 'attack' && this._inEnemyArc) {
                reward -= 0.1;
            } else if (enemyIntent.intent === 'flee' && Utils.dist(this, primaryEnemy) > 100) {
                reward -= 0.05;
            } else if (enemyIntent.intent === 'desperate_attack' && enemyIntent.confidence > 0.7 && this.health > 0.5) {
                reward += 0.08;
            }
        }
        
        // ‚úÖ TEAM ToM REWARDS v5.0
        if (this.teamId && this.config?.enableTeamwork && this.config?.GAME?.currentMode !== '1v1' && this.config?.enableDeepCognition) {
            const allies = this.allies;
            const enemiesList = Utils.getEnemies(this, world);
            const teamAlive = allies.length + 1;
            const enemyAlive = enemiesList.length;
            
            if (teamAlive > 1) reward += 0.1;
            if (teamAlive > enemyAlive) reward += 0.05 * (teamAlive - enemyAlive);
            
            const ally = allies[0];
            if (ally && ally.health / ally.stats.maxHealth < 0.3) reward -= 0.1;
            if (this._coordinationScore > 0.5) reward += (this.config?.TACTICAL?.TEAM_COORDINATION_BONUS || 0.15) * this._coordinationScore;
            
            if (ally && Utils.dist(this, ally) < 50 && enemiesList.length > 0) {
                reward += this.config?.TACTICAL?.ALLY_PROTECTION_BONUS || 0.2;
            }
            
            // ‚úÖ SYNC ATTACK BONUS
            const allyIntent = this.predictAllyIntent(ally);
            if (allyIntent.intent === 'attacking' && Utils.dist(this, ally) < 50 && this.target === ally.target) {
                reward += 0.15;  // –°–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è –∞—Ç–∞–∫–∞
            }
            
            // ‚úÖ SAVE ALLY BONUS
            if (this._warnedAlly && ally && ally._inEnemyArc) {
                reward += 0.1;   // –°–ø–∞—Å —Ç–æ–≤–∞—Ä–∏—â–∞
                this._warnedAlly = false;
            }
        }
        
        this.lastPos = { x: this.x, y: this.y };
        this.cumulativeReward = Math.max(this.cumulativeReward + reward, -100);
        
        return reward;
    }
    
    learn(reward, decision, nextInputs = null) {
        if (!decision || !this.config?.enableTraining) return;
        const currentValue = decision.value, nextValue = nextInputs ? this.critic.forward(nextInputs) : 0;
        const criticResult = this.critic.update(decision.inputs, reward, nextValue);
        const tdResult = this.net.tdLearn(decision.inputs, decision.output, reward, currentValue, nextValue, decision.modeProbs ? Utils.logSoftmax(decision.modeProbs.map(p => Math.log(Math.max(p, 1e-10)) * 10), this.net.policyTemp) : null);
        this.net.updateDiagnostics({ win: null, collected: false, survival: this.health / this.stats.maxHealth, reward });
        if (reward > 3 && this.config?.enableSkillEvolution) this.updatePermanentSkills(reward, decision.mode, this.config?.skillGrowthRate || 0.04);
        if (reward > 4) this.updateMuscleMemory(decision.output, reward);
        this.learningBuffer.states.push(decision.inputs); this.learningBuffer.actions.push(decision.output);
        this.learningBuffer.rewards.push(reward); this.learningBuffer.values.push(currentValue);
        if (this.learningBuffer.states.length >= this.learningBuffer.maxBuffer) this._batchLearn();
    }
    
    _batchLearn() {
        if (!this.config?.enableTraining) { this._clearLearningBuffer(); return; }
        const advantages = Utils.computeGAE(this.learningBuffer.rewards, this.learningBuffer.values, 0, this.net.gamma, this.net.lambda);
        for (let t = 0; t < advantages.length; t++) {
            if (this.lastDecision?.modeProbs) {
                const modeIdx = 0;
                const enemies = (this._lastWorld?.enemies || []).filter(e => {
                    if (!e || e.id === this.id || !e.alive) return false;
                    if (this.teamId === null && e.teamId === null) return true;
                    return e.teamId !== this.teamId;
                });
                const context = [
                    enemies.length > 0 ? Utils.clamp(Utils.dist(this, enemies[0]?.agent || enemies[0]) / 200, 0, 1) : 1,
                    (this._lastWorld?.walls || []).length ? Utils.clamp(Math.min(...this._lastWorld.walls.map(w => Utils.dist(this, w))) / 60, 0, 1) : 0,
                    this.health / this.stats.maxHealth,
                    Utils.clamp(Utils.safeNumber(this.lastDecision.output?.[5], 0.5), 0, 1),
                    Utils.clamp(Utils.safeNumber(this.lastDecision.output?.[6], 0.5), 0, 1),
                    Utils.clamp(Utils.safeNumber(this.lastDecision.output?.[7], 0.5), 0, 1),
                    this.permanent.skills.hunting, this.permanent.skills.fleeing
                ];
                this.policySelector.update(context, this.skillEmbedding, modeIdx, advantages[t]);
            }
        }
        if (typeof requestIdleCallback !== 'undefined') {
            requestIdleCallback(() => this._clearLearningBuffer(), { timeout: 100 });
        } else {
            setTimeout(() => this._clearLearningBuffer(), 0);
        }
    }
    
    _clearLearningBuffer() { this.learningBuffer = { states: [], actions: [], rewards: [], nextStates: [], dones: [], values: [], maxBuffer: 32 }; this._lastWorld = null; }
    
    updatePermanentSkills(reward, mode, skillGrowthRate) {
        if (reward <= 3 || !this.config?.enableSkillEvolution) return;
        const skillKey = 'combat';
        if (skillKey && this.permanent.skills[skillKey] !== undefined) {
            const growth = skillGrowthRate * reward * (this.config?.EVOLUTION?.COMBAT_SKILL_GROWTH || 0.15);
            this.permanent.skills[skillKey] = Utils.clamp(this.permanent.skills[skillKey] + growth, 0, 1);
            this.skillEmbedding = [this.permanent.skills.hunting, this.permanent.skills.fleeing, this.permanent.skills.combat, this.permanent.skills.exploring, this.permanent.skills.avoiding];
        }
    }
    
    updateMuscleMemory(outputs, reward) {
        if (reward < 4) return;
        for (let i = 0; i < Math.min(16, outputs.length); i++) { 
            const diff = Math.abs(outputs[i] - this.permanent.muscleMemory[i]); 
            if (diff > 0.12 && Math.abs(outputs[i]) > 0.4) { 
                this.permanent.muscleMemory[i] = Utils.lerp(this.permanent.muscleMemory[i], outputs[i], 0.08); 
            } 
        }
    }
    
    updatePredictiveMemory(world) {
        this.predictive.shortTerm.positions.push({ x: this.x, y: this.y });
        if (this.predictive.shortTerm.positions.length > 20) this.predictive.shortTerm.positions.shift();
        const enemies = (world?.enemies || []).filter(e => {
            if (!e || e.id === this.id || !e.alive) return false;
            if (this.teamId === null && e.teamId === null) return true;
            return e.teamId !== this.teamId;
        });
        if (enemies.length > 0) {
            const enemy = enemies[0];
            this.predictive.shortTerm.enemyHistory.push({ x: enemy.x, y: enemy.y });
            if (this.predictive.shortTerm.enemyHistory.length > 5) this.predictive.shortTerm.enemyHistory.shift();
            const hist = this.predictive.shortTerm.enemyHistory;
            if (hist.length >= 2) { 
                const [prev, last] = [hist[hist.length - 2], hist[hist.length - 1]]; 
                const dx = last.x - prev.x, dy = last.y - prev.y; 
                this.predictive.predictions.enemyPos = { x: last.x + dx * 0.75, y: last.y + dy * 0.75 }; 
                const error = Utils.dist(enemy, this.predictive.predictions.enemyPos); 
                this.predictive.predictionError = Utils.lerp(this.predictive.predictionError, error / 50, 0.1); 
                const accuracy = Math.max(0, 1 - error / 100); 
                this.predictive.confidence = Utils.lerp(this.predictive.confidence, accuracy, 0.05); 
            }
        } else { 
            this.predictive.confidence = Utils.lerp(this.predictive.confidence, 0.5, 0.02); 
        }
    }
    
    selectCombatTactic(enemyDistance, enemyHealth, myHealth, enemyPrediction) {
        if (enemyPrediction === 'fleeing') return 'aggressive';
        if (enemyPrediction === 'aggressive') return myHealth < 0.4 ? 'defensive' : 'kite';
        if (enemyHealth < 0.3) return 'aggressive';
        if (myHealth < 0.3) return 'defensive';
        if (enemyDistance < 20) return 'bait';
        return 'adaptive';
    }
    
    decideCombatAction(enemy, world) {
        const distance = Utils.dist(this, enemy);
        const prediction = this.enemyPredictor.predictNextAction();
        
        if (!this.socialMemory.interactions.has(enemy.id)) {
            this.socialMemory.interactions.set(enemy.id, { fights: 0, wins: 0, trust: 0 });
        }
        const record = this.socialMemory.interactions.get(enemy.id);
        record.fights++;
        
        const enemyHealth = enemy.health / enemy.stats.maxHealth;
        const myHealth = this.health / this.stats.maxHealth;
        
        if (enemyHealth < 0.3 && myHealth > 0.7) {
            this.currentTactic = record.trust > 0 ? 'merciful' : 'aggressive';
        } else if (enemyHealth < 0.3 && myHealth < 0.3) {
            this.currentTactic = this.net._rng.next() < 0.8 ? 'aggressive' : 'defensive';
        } else {
            this.currentTactic = this.selectCombatTactic(distance, enemyHealth, myHealth, prediction);
        }
        
        this.fightOpponent = enemy.id;
        this.fightStartTime = this.net._rng.getSimTime(); // ‚úÖ DETERMINISTIC timestamp
        return this.currentTactic;
    }
    
    applyEvolutionPoints() {
        if (this.evolutionPoints <= 0) return;
        this.evolutionPoints = Math.max(0, this.evolutionPoints);
        const priorities = {
            maxHealth: this.health < this.stats.maxHealth * 0.5 ? 2 : 1,
            damage: this.permanent.skills.combat > 0.5 ? 1.5 : 1,
            dodgeChance: this.permanent.skills.fleeing > 0.5 ? 1.3 : 1,
            fireRate: this.permanent.skills.combat > 0.4 ? 1.2 : 1
        };
        const sorted = this.statChoices.sort((a, b) => priorities[b] - priorities[a]);
        const useDouble = this.net._rng.next() < 0.3;
        if (useDouble) {
            this._applyStatBonus(sorted[0], 2);
        } else {
            this._applyStatBonus(sorted[0], 1);
            this._applyStatBonus(sorted[1], 1);
        }
        this.evolutionPoints = 0;
    }
    
    _applyStatBonus(stat, points) {
        const safePoints = Math.max(0, Math.floor(points));
        if (safePoints <= 0) return;
        const MIN_STATS = { maxHealth: 50, damage: 1, dodgeChance: 0, fireRate: 5 };
        const MAX_STATS = { maxHealth: 300, damage: 15, dodgeChance: 0.5, fireRate: 60 };
        switch(stat) {
            case 'maxHealth':
                this.stats.maxHealth = Utils.clamp(this.stats.maxHealth + safePoints * 10, MIN_STATS.maxHealth, MAX_STATS.maxHealth);
                this.health = Math.min(this.stats.maxHealth, this.health + safePoints * 10);
                break;
            case 'damage':
                this.stats.damage = Utils.clamp(this.stats.damage + safePoints * 1, MIN_STATS.damage, MAX_STATS.damage);
                break;
            case 'dodgeChance':
                this.stats.dodgeChance = Utils.clamp(this.stats.dodgeChance + safePoints * 0.1, MIN_STATS.dodgeChance, MAX_STATS.dodgeChance);
                break;
            case 'fireRate':
                this.stats.fireRate = Utils.clamp(this.stats.fireRate + safePoints * 3, MIN_STATS.fireRate, MAX_STATS.fireRate);
                break;
            default:
                console.warn(`Unknown stat: ${stat}`);
                return;
        }
        this.lastMutationType = stat;
    }
    
    // ‚úÖ EMPATHY VALIDATION v5.0
    validateLastPrediction() {
        if (!this._lastPrediction || !this.config?.enableDeepCognition) return;
        
        const enemy = this._lastWorld?.enemies.find(e => e.id === this._lastPrediction.enemyId);
        if (!enemy) return;
        
        // –ß—Ç–æ –≤—Ä–∞–≥ —Ä–µ–∞–ª—å–Ω–æ –¥–µ–ª–∞–ª?
        let actualIntent = 'unknown';
        if (enemy.lastDecision?.behaviors?.aggression > 0.7) {
            actualIntent = 'attack';
        } else if (enemy.lastDecision?.behaviors?.aggression < 0.3) {
            actualIntent = 'flee';
        }
        
        const wasCorrect = actualIntent === this._lastPrediction.intent;
        
        // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
        this.empathyStats.total++;
        if (wasCorrect) this.empathyStats.correct++;
        
        const enemyStats = this.empathyStats.byEnemy.get(enemy.id) || { total: 0, correct: 0 };
        enemyStats.total++;
        if (wasCorrect) enemyStats.correct++;
        this.empathyStats.byEnemy.set(enemy.id, enemyStats);
        
        // –¢–æ—á–Ω–æ—Å—Ç—å –≤–ª–∏—è–µ—Ç –Ω–∞ –¥–æ–≤–µ—Ä–∏–µ
        const accuracy = this.empathyStats.total > 0 ? this.empathyStats.correct / this.empathyStats.total : 0;
        this._empathyTrust = accuracy;
        
        // –ï—Å–ª–∏ –∫ —ç—Ç–æ–º—É –≤—Ä–∞–≥—É –Ω–∏–∑–∫–∞—è —Ç–æ—á–Ω–æ—Å—Ç—å - –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º —ç–º–ø–∞—Ç–∏—é
        const enemyAccuracy = enemyStats.total > 0 ? enemyStats.correct / enemyStats.total : 0;
        if (enemyAccuracy < 0.4) {
            this._ignoreEmpathyFor[enemy.id] = true;
        }
        
        // ‚úÖ TEAM STAT SHARING
        if (this.allies.length > 0 && this.config?.enableTeamwork) {
            this.allies.forEach(ally => {
                if (!ally.empathyStats.byEnemy.has(enemy.id)) {
                    ally.empathyStats.byEnemy.set(enemy.id, {
                        total: enemyStats.total,
                        correct: enemyStats.correct,
                        shared: true
                    });
                }
            });
        }
    }
    
    getLearningMetrics() {
        return {
            avgTDError: this.net._trainingStats.tdErrorHistory.reduce((a,b)=>a+b,0)/Math.max(1,this.net._trainingStats.tdErrorHistory.length),
            avgPredictionError: Array.from(this.net._predictionErrors).reduce((a,b)=>a+b,0)/Math.max(1,this.net._predictionErrors.length),
            avgPolicyEntropy: this.net._trainingStats.policyEntropyHistory.reduce((a,b)=>a+b,0)/Math.max(1,this.net._trainingStats.policyEntropyHistory.length),
            winRate: this.wins / Math.max(1, this.wins + this.deaths),
            avgDamage: this._totalDamageDealt / Math.max(1, this._totalAttacks),
            accuracy: this._successfulHits / Math.max(1, this._totalAttacks),
            tacticalRate: this._tacticalHits / Math.max(1, this._successfulHits),
            teamWins: this.net._trainingStats.teamWins
        };
    }
    
    evolve(mutationRate = 0.1) {
        if (!this.config?.enableEvolution) return 0;
        const actualRate = this._learnFromWinner ? (this.config?.EVOLUTION?.MUTATION_ON_DEATH || 0.2) : mutationRate;
        const mutations = this.net.mutate(actualRate, 0.15);
        if (this.critic?._W1) this.critic._W1.forEach(row => { if (!row) return; row.forEach((v, i) => { if (this.net._rng.next() < actualRate) { row[i] += (this.net._rng.next() * 2 - 1) * 0.15; row[i] = Utils.clamp(row[i], -2, 2); } }); });
        this.mutations += mutations; return mutations;
    }
    
    reset(x, y) {
        this.x = x; this.y = y; this.vx = 0; this.vy = 0; this.health = this.stats.maxHealth; this.stuckCounter = 0;
        this.lastPos = { x, y }; this.cumulativeReward = 5; this.mode = 'combat'; this.target = { x, y }; this.trail = [];
        this.predictive.confidence = 0.5; this.predictive.predictionError = 0; this.attackCooldown = 0;
        this._clearLearningBuffer();
        this.predictive.shortTerm = { positions: [], actions: [], results: [], enemyHistory: [], foodHistory: [] };
        this._lastHitDealt = 0;
        this._knockbackVelocity = { x: 0, y: 0 };
        this._stunTimer = 0;
        this._weaponEffectTimer = 0;
        this._heavyHit = 0;
        this._pierced = 0;
        this._pulseEffect = 0;
        this._continuousKB = 0;
        this._forcedCombatTimer = this.config?.EVOLUTION?.FORCED_COMBAT_AFTER_DEATH || 30;
        this._recentArcExposure = [];
        this._inEnemyArc = false;
        this._lastThreatAssessment = null;
        this._coordinationScore = 0;
        this._lastAllyAssist = 0;
        this.permanent.memory.visited.clear();
        this.socialMemory = {
            interactions: new Map(),
            reputation: 0,
            lastAggressor: null,
            allies: [],
            killerHistory: []
        };
        this.empathyStats = { total: 0, correct: 0, byEnemy: new Map() };
        this._lastPrediction = null;
        this._empathyTrust = 0.5;
        this._ignoreEmpathyFor = {};
        this._forcedExploration = 0;
        this._imaginationScore = 0;
        this._warnedAlly = false;
        this._sharedThreat = null;
        this._threatDirection = null;
    }
    
    learnFromWinner(winner) {
        if (!winner || !this.config?.enableWeightInheritance) return;
        this._learnFromWinner = true;
        const inheritRate = this.config?.EVOLUTION?.LEARN_FROM_WINNER_RATE || 0.85;
        const inheritWeights = (child, parent) => {
            if (!child || !parent) return;
            for (let i = 0; i < Math.min(child.length, parent.length); i++) {
                if (Array.isArray(child[i]) && Array.isArray(parent[i])) {
                    for (let j = 0; j < Math.min(child[i].length, parent[i].length); j++) {
                        if (this.net._rng.next() < inheritRate) {
                            child[i][j] = parent[i][j];
                        }
                    }
                }
            }
        };
        inheritWeights(this.net._W1, winner.net._W1);
        inheritWeights(this.net._W2, winner.net._W2);
        inheritWeights(this.net._W3, winner.net._W3);
        inheritWeights(this.net._inputEmbedding, winner.net._inputEmbedding);
        this.socialMemory.killerHistory.push({
            killer: winner.id,
            weapon: winner.weaponType,
            mode: winner.mode,
            step: this.net._rng.getSimTime(), // ‚úÖ DETERMINISTIC timestamp
            myHealth: this.health / this.stats.maxHealth,
            theirHealth: winner.health / winner.stats.maxHealth
        });
        if (this.socialMemory.killerHistory.length > 10) {
            this.socialMemory.killerHistory.shift();
        }
    }
    
    // ‚úÖ DRAW with v5.0 visual feedback
    draw(ctx, showVision = false, showTrail = true) {
        if (showTrail && this.trail.length > 1) { 
            ctx.beginPath(); ctx.moveTo(this.trail[0].x, this.trail[0].y); 
            for (let i = 1; i < this.trail.length; i++) { 
                const t = this.trail[i], alpha = 1 - t.age / 80; 
                ctx.strokeStyle = this.color + Math.floor(alpha * 40).toString(16).padStart(2, '0'); 
                ctx.lineTo(t.x, t.y); 
            } 
            ctx.stroke(); 
        }
        
        let drawColor = this.color;
        
        // ‚úÖ FIX: Assign default colors for 1v1 mode based on agent ID if color is default white
        if (!drawColor || drawColor === '#fff' || drawColor === '#ffffff') {
            if (this.id.includes('0') || this.id === 'agent0') {
                drawColor = '#00d4ff'; // Cyan
            } else if (this.id.includes('1') || this.id === 'agent1') {
                drawColor = '#ff5577'; // Pink/Red
            } else if (this.id.includes('2') || this.id === 'agent2') {
                drawColor = '#00ff9d'; // Green
            } else if (this.id.includes('3') || this.id === 'agent3') {
                drawColor = '#ffdd44'; // Yellow
            } else {
                drawColor = '#888888'; // Gray fallback
            }
        }
        
        if (this._lastHitReceived > 0) drawColor = '#ff8888';
        else if (this.lastMutationType === 'dmg') drawColor = '#ff4444';
        else if (this.lastMutationType === 'spd') drawColor = '#4444ff';
        else if (this.lastMutationType === 'hp') drawColor = '#44ff44';
        else if (this.lastMutationType === 'dod') drawColor = '#aa88ff';
        
        ctx.fillStyle = drawColor; 
        ctx.beginPath(); ctx.arc(this.x, this.y, Agent.VISUAL_RADIUS, 0, Math.PI * 2); ctx.fill();
        
        if (this.teamId) {
            ctx.strokeStyle = this.config?.GAME?.teamColors?.[this.teamId] || '#fff';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(this.x, this.y, Agent.VISUAL_RADIUS + 6, 0, Math.PI * 2);
            ctx.stroke();
        }
        
        ctx.strokeStyle = this._knockbackVelocity.x !== 0 || this._knockbackVelocity.y !== 0 ? '#ff0000' : '#fff';
        ctx.lineWidth = this._knockbackVelocity.x !== 0 || this._knockbackVelocity.y !== 0 ? 3 : 2;
        ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(this.x + this.vx * 8, this.y + this.vy * 8); ctx.stroke();
        
        const modeColors = { combat: '#ffaa00' };
        ctx.strokeStyle = modeColors[this.mode] || '#ffaa00'; ctx.lineWidth = 2.5;
        ctx.beginPath(); ctx.arc(this.x, this.y, Agent.VISUAL_RADIUS + 4, 0, Math.PI * 2); ctx.stroke();
        
        ctx.fillStyle = this.weapon.color || '#ffaa00';
        ctx.font = '18px Arial'; ctx.textAlign = 'center';
        ctx.fillText(this.weapon.icon, this.x, this.y + 6);
        ctx.textAlign = 'left';
        
        ctx.fillStyle = this.predictive.confidence > 0.7 ? '#00ff9d' : (this.predictive.confidence < 0.4 ? '#ff5577' : '#ffaa00'); 
        ctx.beginPath(); ctx.arc(this.x + 14, this.y - 14, 3, 0, Math.PI * 2); ctx.fill();
        
        if (this.health < this.stats.maxHealth) { 
            ctx.fillStyle = '#222';
            ctx.fillRect(this.x - Agent.VISUAL_RADIUS, this.y - Agent.VISUAL_RADIUS - 12, Agent.VISUAL_RADIUS * 2, 4); 
            ctx.fillStyle = this.health > this.stats.maxHealth / 2 ? '#00ff9d' : '#ff5577';
            ctx.fillRect(this.x - Agent.VISUAL_RADIUS, this.y - Agent.VISUAL_RADIUS - 12, Agent.VISUAL_RADIUS * 2 * (this.health / this.stats.maxHealth), 4); 
        }
        
        ctx.fillStyle = '#fff'; ctx.font = '9px monospace'; ctx.textAlign = 'center';
        ctx.fillText(`HP:${Math.round(this.stats.maxHealth)} DMG:${this.stats.damage}`, this.x, this.y - 25);
        ctx.fillText(`${this.weapon.name} W:${this.wins}`, this.x, this.y - 16);
        ctx.textAlign = 'left';
        
        if (showVision && this.mode === 'combat') { 
            ctx.strokeStyle = 'rgba(255,170,0,0.3)';
            ctx.fillStyle = 'rgba(255,170,0,0.1)';
            ctx.beginPath(); ctx.moveTo(this.x, this.y);
            ctx.arc(this.x, this.y, this.attackRange, Math.atan2(this.vy, this.vx) - 0.6, Math.atan2(this.vy, this.vx) + 0.6);
            ctx.closePath(); ctx.fill(); ctx.stroke(); 
        }
        
        ctx.strokeStyle = 'rgba(255,255,255,0.35)'; ctx.setLineDash([4, 3]);
        ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(this.target.x, this.target.y); ctx.stroke(); ctx.setLineDash([]);
        
        if (this.trail.length === 0 || this.trail[this.trail.length - 1].age > 4) { 
            this.trail.push({ x: this.x, y: this.y, age: 0 }); 
            if (this.trail.length > 35) this.trail.shift(); 
        }
        this.trail.forEach(t => t.age++);
        
        if (Math.abs(this._knockbackVelocity.x) > 1 || Math.abs(this._knockbackVelocity.y) > 1) {
            ctx.strokeStyle = 'rgba(255,50,50,0.8)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(this.x, this.y, Agent.VISUAL_RADIUS + 8, 0, Math.PI * 2);
            ctx.stroke();
        }
        
        if (this._stunTimer > 0) {
            ctx.strokeStyle = 'rgba(255,255,0,0.6)';
            ctx.setLineDash([2, 3]);
            ctx.beginPath();
            ctx.arc(this.x, this.y, Agent.VISUAL_RADIUS + 10, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);
        }
        
        if (this._forcedCombatTimer > 0) {
            ctx.strokeStyle = 'rgba(255,0,0,0.5)';
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.arc(this.x, this.y, Agent.VISUAL_RADIUS + 12, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);
        }
        
        if (window.arenaGame?.debug) {
            ctx.strokeStyle = 'rgba(255,255,0,0.4)';
            ctx.setLineDash([3, 2]);
            ctx.beginPath();
            ctx.arc(this.x, this.y, Agent.COLLISION_RADIUS, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);
        }
        
        if ((showVision || window.arenaGame?.debug) && this.config?.enableTactical) {
            const facing = this.getWeaponFacing();
            const arc = this.weapon.arcAngle || Math.PI;
            
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(facing);
            
            ctx.fillStyle = 'rgba(255, 80, 80, 0.25)';
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.arc(0, 0, this.weapon.range, -arc/2, arc/2);
            ctx.closePath();
            ctx.fill();
            
            ctx.fillStyle = 'rgba(255, 170, 0, 0.15)';
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.arc(0, 0, this.weapon.range * 0.7, -arc/4, arc/4);
            ctx.closePath();
            ctx.fill();
            
            ctx.strokeStyle = this.weapon.color;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(this.weapon.mountOffset.x, this.weapon.mountOffset.y);
            ctx.lineTo(this.weapon.mountOffset.x + 12, this.weapon.mountOffset.y);
            ctx.stroke();
            
            ctx.restore();
            
            const enemies = (this._lastWorld?.enemies || []).filter(e => {
                if (!e || e.id !== this.id || !e.alive) return false;
                if (this.teamId === null && e.teamId === null) return true;
                return e.teamId !== this.teamId;
            });
            const primaryEnemy = enemies[0]?.agent;
            if (primaryEnemy && typeof primaryEnemy.assessThreatFromEnemy === 'function' && showVision) {
                const threat = this.assessThreatFromEnemy(primaryEnemy);
                if (threat.threatLevel > 0.5) {
                    ctx.strokeStyle = 'rgba(0, 255, 157, 0.6)';
                    ctx.setLineDash([3, 4]);
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(
                        this.x + threat.flankVector.x * 50,
                        this.y + threat.flankVector.y * 50
                    );
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }
        }
        
        if (this._inEnemyArc && showVision) {
            ctx.strokeStyle = 'rgba(255, 50, 50, 0.8)';
            ctx.setLineDash([2, 2]);
            ctx.beginPath();
            ctx.arc(this.x, this.y, Agent.VISUAL_RADIUS + 14, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);
        }
        
        // ‚úÖ v5.0: Show imagination score if high
        if (this.config?.enableDeepCognition && this._imaginationScore > 5 && showVision) {
            ctx.fillStyle = 'rgba(0, 255, 157, 0.3)'; ctx.font = '8px monospace'; ctx.textAlign = 'center';
            ctx.fillText(`üß†${this._imaginationScore.toFixed(1)}`, this.x, this.y - 35);
        }
    }
    
    getDebugInfo() {
        const metrics = this.getLearningMetrics();
        const attention = this.interpretAttention();
        const enemyIntent = this.predictEnemyIntent(
            (this._lastWorld?.enemies || []).find(e => {
                if (!e?.id || e.id === this.id || !e?.alive) return false;
                if (this.teamId === null && e.teamId === null) return true;
                return e.teamId !== this.teamId;
            })?.agent
        );
        const empathyAcc = this.empathyStats.total > 0 ? this.empathyStats.correct / this.empathyStats.total : 0;
        const memConf = Array.from(this.net._memoryPermanent.confidence).reduce((a,b) => a+b, 0) / this.net.memoryDim;
        
        return {
            mode: this.mode, 
            weapon: this.weapon.icon + ' ' + this.weapon.name, 
            target: `${Math.round(this.target.x)},${Math.round(this.target.y)}`, 
            speed: this.speed.toFixed(2),
            aggro: this.lastDecision?.behaviors?.aggression?.toFixed(2) || '‚Äî', 
            memory: (this.permanent.memory.visited.size / 100).toFixed(2),
            neurons: this.net.getActiveNeurons().slice(0, 3).join(','), 
            reward: this.cumulativeReward.toFixed(2), 
            stuck: this.stuckCounter,
            confidence: this.predictive.confidence.toFixed(2), 
            predError: metrics.avgPredictionError.toFixed(3),
            health: `${Math.round(this.health)}/${this.stats.maxHealth}`, 
            mutations: this.mutations, 
            generation: this.generation,
            tdError: metrics.avgTDError.toFixed(4), 
            policyEntropy: metrics.avgPolicyEntropy.toFixed(3),
            winRate: metrics.winRate.toFixed(2), 
            collectionRate: metrics.collectionRate.toFixed(2),
            gate0: this.net.getGateProbs()?.[0]?.toFixed(3) || '‚Äî', 
            gate1: this.net.getGateProbs()?.[1]?.toFixed(3) || '‚Äî',
            expert0: this.net._lastActiveExperts?.[0] || '‚Äî', 
            expert1: this.net._lastActiveExperts?.[1] || '‚Äî',
            loadBal: Utils.computeLoadBalance(this.net._lastGateProbs || []).toFixed(3),
            hebbian: this.config?.enableHebbian ? 'ON' : 'OFF',
            socialRep: this.socialMemory.reputation.toFixed(2),
            archetype: this.permanent.skills.combat > 0.6 ? 'fighter' : 'aggressor',
            wins: this.wins,
            deaths: this.deaths,
            kbVel: `${this._knockbackVelocity.x.toFixed(1)},${this._knockbackVelocity.y.toFixed(1)}`,
            stun: this._stunTimer,
            forcedCombat: this._forcedCombatTimer,
            threat: this._lastThreatAssessment?.threatLevel?.toFixed(2) || '‚Äî',
            flank: this._lastThreatAssessment ? `${this._lastThreatAssessment.flankVector.x.toFixed(2)},${this._lastThreatAssessment.flankVector.y.toFixed(2)}` : '‚Äî',
            attThreat: attention.threat,
            attFlank: attention.flank,
            attDist: attention.distance,
            attPred: attention.prediction,
            enemyIntent: enemyIntent.intent,
            intentConf: enemyIntent.confidence.toFixed(2),
            teamId: this.teamId || '‚Äî',
            coordination: this._coordinationScore.toFixed(2),
            allyAssist: this._lastAllyAssist > 0 ? 'YES' : 'NO',
            teamWins: metrics.teamWins,
            lr: this.net.lr.toFixed(4),
            empathy: empathyAcc.toFixed(2),
            memConf: memConf.toFixed(2),
            imagination: this._imaginationScore.toFixed(1)
        };
    }
    
    clone() {
        const agent = new Agent(this.id, this.x, this.y, this.color, this.seed + '_clone_' + this.net._rng.next().toString(36).slice(2,10), this.weaponType, this.teamId, this.config);
        agent.net = this.net.clone(); agent.net.agent = agent; agent.critic = this.critic.clone(); agent.policySelector = this.policySelector.clone();
        agent.experts = this.experts.map(e => e.clone());
        agent.health = this.health; agent.stats = { ...this.stats }; agent.lastMutationType = this.lastMutationType;
        agent.cumulativeReward = this.cumulativeReward; agent.wins = this.wins; agent.totalKills = this.totalKills; agent.deaths = this.deaths; agent.mutations = this.mutations; agent.generation = this.generation + 1;
        agent.permanent = { skills: { ...this.permanent.skills }, strategies: { ...this.permanent.strategies }, preferences: { ...this.permanent.preferences }, muscleMemory: new Float32Array(this.permanent.muscleMemory), memory: { lastFoodPos: this.permanent.memory.lastFoodPos ? { ...this.permanent.memory.lastFoodPos } : null, lastFoodStep: this.permanent.memory.lastFoodStep || 0, visited: new Set(this.permanent.memory.visited), unvisited: this.permanent.memory.unvisited.map(p => ({ ...p })), _maxVisited: this.permanent.memory._maxVisited } };
        agent.predictive = { shortTerm: { positions: [], actions: [], results: [], enemyHistory: [], foodHistory: [] }, patterns: { enemyMovement: null, foodSpawn: null, dangerZones: new Map() }, predictions: { enemyPos: { x: 0, y: 0 }, foodPos: { x: 0, y: 0 }, collision: false, success: 0.5 }, confidence: this.predictive.confidence, predictionError: this.predictive.predictionError };
        agent.skillEmbedding = this.skillEmbedding.slice(); agent.attackCooldown = this.attackCooldown || 0;
        agent.socialMemory = {
            interactions: new Map(this.socialMemory.interactions),
            reputation: this.socialMemory.reputation,
            lastAggressor: this.socialMemory.lastAggressor,
            allies: [...this.socialMemory.allies],
            killerHistory: [...this.socialMemory.killerHistory]
        };
        agent.evolutionPoints = this.evolutionPoints;
        agent.statChoices = [...this.statChoices];
        agent._lastHitDealt = this._lastHitDealt;
        agent._knockbackVelocity = { ...this._knockbackVelocity };
        agent._stunTimer = this._stunTimer;
        agent._weaponEffectTimer = this._weaponEffectTimer;
        agent._heavyHit = this._heavyHit;
        agent._pierced = this._pierced;
        agent._pulseEffect = this._pulseEffect;
        agent._continuousKB = this._continuousKB;
        agent._forcedCombatTimer = this._forcedCombatTimer;
        agent._learnFromWinner = this._learnFromWinner;
        agent._lastKiller = this._lastKiller;
        agent._deathMode = this._deathMode;
        agent._lastAttackDir = this._lastAttackDir;
        agent._recentArcExposure = this._recentArcExposure ? [...this._recentArcExposure] : [];
        agent._inEnemyArc = this._inEnemyArc;
        agent._lastThreatAssessment = this._lastThreatAssessment ? { ...this._lastThreatAssessment } : null;
        agent._totalDamageDealt = this._totalDamageDealt;
        agent._totalAttacks = this._totalAttacks;
        agent._successfulHits = this._successfulHits;
        agent._tacticalHits = this._tacticalHits;
        agent._frontalHits = this._frontalHits;
        agent._coordinationScore = this._coordinationScore;
        agent._lastAllyAssist = this._lastAllyAssist;
        agent.empathyStats = { total: this.empathyStats.total, correct: this.empathyStats.correct, byEnemy: new Map(this.empathyStats.byEnemy) };
        agent._lastPrediction = this._lastPrediction ? { ...this._lastPrediction } : null;
        agent._empathyTrust = this._empathyTrust;
        agent._ignoreEmpathyFor = { ...this._ignoreEmpathyFor };
        agent._forcedExploration = this._forcedExploration;
        agent._imaginationScore = this._imaginationScore;
        agent._warnedAlly = this._warnedAlly;
        agent._sharedThreat = this._sharedThreat;
        agent._threatDirection = this._threatDirection ? { ...this._threatDirection } : null;
        return agent;
    }
    
    toJSON() {
        return {
            id: this.id, seed: this.seed, x: this.x, y: this.y, health: this.health, stats: this.stats, lastMutationType: this.lastMutationType,
            cumulativeReward: this.cumulativeReward, wins: this.wins, totalKills: this.totalKills, deaths: this.deaths, mutations: this.mutations, generation: this.generation,
            teamId: this.teamId, weaponType: this.weaponType,
            net: this.net.toJSON(), critic: this.critic.toJSON(), policySelector: this.policySelector.toJSON(),
            experts: this.experts ? this.experts.map(e => e.toJSON()) : [],
            permanent: { skills: this.permanent.skills, strategies: this.permanent.strategies, preferences: this.permanent.preferences, muscleMemory: Array.from(this.permanent.muscleMemory), memory: { lastFoodPos: this.permanent.memory.lastFoodPos, lastFoodStep: this.permanent.memory.lastFoodStep, visited: Array.from(this.permanent.memory.visited).slice(0, 100), unvisited: this.permanent.memory.unvisited.slice(0, 30), _maxVisited: this.permanent.memory._maxVisited } },
            predictive: { confidence: this.predictive.confidence, predictionError: this.predictive.predictionError },
            skillEmbedding: this.skillEmbedding.slice(),
            strategyMemory: { winningStrategies: this.strategyMemory.winningStrategies.slice(0, 5), fightHistory: this.strategyMemory.fightHistory },
            trainingStats: this.net._trainingStats,
            socialMemory: {
                interactions: Array.from(this.socialMemory.interactions.entries()).map(([k, v]) => [k, { ...v }]),
                reputation: this.socialMemory.reputation,
                lastAggressor: this.socialMemory.lastAggressor,
                allies: [...this.socialMemory.allies],
                killerHistory: this.socialMemory.killerHistory
            },
            evolutionPoints: this.evolutionPoints,
            statChoices: [...this.statChoices],
            _lastHitDealt: this._lastHitDealt,
            _knockbackVelocity: this._knockbackVelocity,
            _stunTimer: this._stunTimer,
            _forcedCombatTimer: this._forcedCombatTimer,
            _learnFromWinner: this._learnFromWinner,
            _lastKiller: this._lastKiller,
            _deathMode: this._deathMode,
            _lastAttackDir: this._lastAttackDir,
            _recentArcExposure: this._recentArcExposure,
            _inEnemyArc: this._inEnemyArc,
            _lastThreatAssessment: this._lastThreatAssessment,
            _totalDamageDealt: this._totalDamageDealt,
            _totalAttacks: this._totalAttacks,
            _successfulHits: this._successfulHits,
            _tacticalHits: this._tacticalHits,
            _frontalHits: this._frontalHits,
            _coordinationScore: this._coordinationScore,
            _lastAllyAssist: this._lastAllyAssist,
            empathyStats: { total: this.empathyStats.total, correct: this.empathyStats.correct, byEnemy: Array.from(this.empathyStats.byEnemy.entries()) },
            _lastPrediction: this._lastPrediction,
            _empathyTrust: this._empathyTrust,
            _ignoreEmpathyFor: this._ignoreEmpathyFor,
            _forcedExploration: this._forcedExploration,
            _imaginationScore: this._imaginationScore,
            _warnedAlly: this._warnedAlly,
            _sharedThreat: this._sharedThreat,
            _threatDirection: this._threatDirection
        };
    }
    
    static fromJSON(data, color, config = null) {
        const agent = new Agent(data.id, data.x, data.y, color, data.seed, data.weaponType || 'hammer', data.teamId || null, config);
        agent.net = NeuralNetwork.fromJSON(data.net);
        agent.net.agent = agent;
        if (data.critic) agent.critic = CriticNetwork.fromJSON(data.critic);
        if (data.policySelector) agent.policySelector = PolicySelector.fromJSON(data.policySelector);
        if (data.experts?.length) agent.experts = data.experts.map(e => NeuralNetwork.fromJSON(e));
        agent.health = data.health ?? 100; agent.stats = data.stats || { maxHealth: 100, damage: 3, fireRate: 15, dodgeChance: 0.0 };
        agent.lastMutationType = data.lastMutationType || null; agent.cumulativeReward = data.cumulativeReward ?? 5;
        agent.wins = data.wins ?? 0; agent.totalKills = data.totalKills ?? 0; agent.deaths = data.deaths ?? 0; agent.mutations = data.mutations ?? 0; agent.generation = data.generation ?? 1;
        if (data.permanent) {
            agent.permanent.skills = { ...(data.permanent.skills || agent.permanent.skills) };
            agent.permanent.strategies = { ...(data.permanent.strategies || agent.permanent.strategies) };
            agent.permanent.preferences = { ...(data.permanent.preferences || agent.permanent.preferences) };
            if (data.permanent.muscleMemory) agent.permanent.muscleMemory = new Float32Array(data.permanent.muscleMemory);
            if (data.permanent.memory) { agent.permanent.memory.lastFoodPos = data.permanent.memory.lastFoodPos; agent.permanent.memory.lastFoodStep = data.permanent.memory.lastFoodStep || 0; agent.permanent.memory.visited = new Set(data.permanent.memory.visited || []); agent.permanent.memory.unvisited = data.permanent.memory.unvisited || []; agent.permanent.memory._maxVisited = data.permanent.memory._maxVisited || 500; }
        }
        if (data.strategyMemory) { agent.strategyMemory.winningStrategies = data.strategyMemory.winningStrategies || []; agent.strategyMemory.fightHistory = data.strategyMemory.fightHistory || {}; }
        if (data.predictive) { agent.predictive.confidence = data.predictive.confidence ?? 0.5; agent.predictive.predictionError = data.predictive.predictionError ?? 0; }
        if (data.skillEmbedding) agent.skillEmbedding = data.skillEmbedding.slice();
        if (data.trainingStats) agent.net._trainingStats = { ...data.trainingStats };
        if (data.socialMemory) {
            agent.socialMemory.interactions = new Map(data.socialMemory.interactions || []);
            agent.socialMemory.reputation = data.socialMemory.reputation ?? 0;
            agent.socialMemory.lastAggressor = data.socialMemory.lastAggressor || null;
            agent.socialMemory.allies = data.socialMemory.allies || [];
            agent.socialMemory.killerHistory = data.socialMemory.killerHistory || [];
        }
        if (data.evolutionPoints !== undefined) agent.evolutionPoints = data.evolutionPoints;
        if (data.statChoices) agent.statChoices = [...data.statChoices];
        if (data._lastHitDealt !== undefined) agent._lastHitDealt = data._lastHitDealt;
        if (data._knockbackVelocity) agent._knockbackVelocity = { ...data._knockbackVelocity };
        if (data._stunTimer !== undefined) agent._stunTimer = data._stunTimer;
        if (data._forcedCombatTimer !== undefined) agent._forcedCombatTimer = data._forcedCombatTimer;
        if (data._learnFromWinner !== undefined) agent._learnFromWinner = data._learnFromWinner;
        if (data._lastKiller) agent._lastKiller = data._lastKiller;
        if (data._deathMode) agent._deathMode = data._deathMode;
        if (data._lastAttackDir !== undefined) agent._lastAttackDir = data._lastAttackDir;
        if (data._recentArcExposure) agent._recentArcExposure = [...data._recentArcExposure];
        if (data._inEnemyArc !== undefined) agent._inEnemyArc = data._inEnemyArc;
        if (data._lastThreatAssessment) agent._lastThreatAssessment = { ...data._lastThreatAssessment };
        if (data._totalDamageDealt !== undefined) agent._totalDamageDealt = data._totalDamageDealt;
        if (data._totalAttacks !== undefined) agent._totalAttacks = data._totalAttacks;
        if (data._successfulHits !== undefined) agent._successfulHits = data._successfulHits;
        if (data._tacticalHits !== undefined) agent._tacticalHits = data._tacticalHits;
        if (data._frontalHits !== undefined) agent._frontalHits = data._frontalHits;
        if (data._coordinationScore !== undefined) agent._coordinationScore = data._coordinationScore;
        if (data._lastAllyAssist !== undefined) agent._lastAllyAssist = data._lastAllyAssist;
        if (data.empathyStats) {
            agent.empathyStats.total = data.empathyStats.total || 0;
            agent.empathyStats.correct = data.empathyStats.correct || 0;
            agent.empathyStats.byEnemy = new Map(data.empathyStats.byEnemy || []);
        }
        if (data._lastPrediction) agent._lastPrediction = data._lastPrediction;
        if (data._empathyTrust !== undefined) agent._empathyTrust = data._empathyTrust;
        if (data._ignoreEmpathyFor) agent._ignoreEmpathyFor = { ...data._ignoreEmpathyFor };
        if (data._forcedExploration !== undefined) agent._forcedExploration = data._forcedExploration;
        if (data._imaginationScore !== undefined) agent._imaginationScore = data._imaginationScore;
        if (data._warnedAlly !== undefined) agent._warnedAlly = data._warnedAlly;
        if (data._sharedThreat) agent._sharedThreat = data._sharedThreat;
        if (data._threatDirection) agent._threatDirection = data._threatDirection;
        if (data.teamId) agent.teamId = data.teamId;
        return agent;
    }
}

// ============================================================================
// WORLD ‚Äî Complete team win logic, race condition fixed [v5.0]
// ============================================================================
class World {
    constructor(width, height, config = null) {
        this.config = config || Arena.getConfig();
        this.logicalWidth = width; this.logicalHeight = height; this.step = 0; this.episode = 0; this.totalFights = 0;
        this.walls = []; this.enemies = []; this.projectiles = [];
        this.teamWins = { blue: 0, red: 0, green: 0, yellow: 0 };
        this.episodeInProgress = true;
    }
    
    reset() {
        this.step = 0;
        this.walls = [];
        for (let i = 0; i < 12; i++) this.walls.push({ x: 60 + Utils.rand(this.config._rng, 0, 700), y: 60 + Utils.rand(this.config._rng, 0, 460) });
        this.projectiles = [];
        this.episodeInProgress = true;
    }
    
    spawnAgents(mode = '1v1', weaponMap = {}) {
        this.enemies = [];
        const spawnPositions = {
            '1v1': [
                { x: 150, y: 150, team: null }, 
                { x: 670, y: 450, team: null }
            ],
            '2v2': [
                { x: 100, y: 150, team: 'blue' }, 
                { x: 150, y: 200, team: 'blue' }, 
                { x: 670, y: 450, team: 'red' }, 
                { x: 720, y: 400, team: 'red' }
            ],
            '4way': [
                { x: 150, y: 150, team: 'blue' }, 
                { x: 670, y: 150, team: 'red' }, 
                { x: 150, y: 450, team: 'green' }, 
                { x: 670, y: 450, team: 'yellow' }
            ]
        };
        const positions = spawnPositions[mode] || spawnPositions['1v1'];
        const maxAgents = this.config?.GAME?.maxAgents?.[mode] || 2;
        
        for (let i = 0; i < Math.min(maxAgents, positions.length); i++) {
            const pos = positions[i];
            // ‚úÖ DETERMINISTIC seed ‚Äî no Date.now()
            const uniqueSeed = `${this.config.seed}_AGENT${i}_${this.config._rng?.next().toString(36).slice(2,10)}`;
            const weapon = weaponMap[pos.team || `agent${i}`] || 'hammer';
            
            // ‚úÖ FIX: Assign colors for 1v1 mode (when teamId is null)
            let color;
            if (pos.team) {
                color = this.config?.GAME?.teamColors?.[pos.team] || '#fff';
            } else {
                // Default distinct colors for 1v1 agents
                const defaultColors = ['#00d4ff', '#ff5577', '#00ff9d', '#ffdd44'];
                color = defaultColors[i % defaultColors.length];
            }
            
            const agentId = pos.team || `agent${i}`;
            const teamId = pos.team || null;
            const agent = new Agent(agentId, pos.x, pos.y, color, uniqueSeed, weapon, teamId, this.config);
            agent.stats.maxHealth = 100; 
            agent.stats.damage = 3; 
            agent.stats.fireRate = 15; 
            agent.stats.dodgeChance = 0.0;
            
            this.enemies.push(agent);
        }
        
        for (const agent of this.enemies) {
            if (agent.teamId) {
                agent.updateAllies(this);
            }
        }
    }
    
    _selectBestTarget(agent, opponents) {
        if (!opponents?.length) return null;
        return opponents.reduce((best, enemy) => {
            const dist = Utils.dist(agent, enemy);
            const healthRatio = enemy.health / enemy.stats.maxHealth;
            const threatScore = (1 - healthRatio) * 0.6 + (150 - Math.min(dist, 150)) / 150 * 0.4;
            const bestDist = Utils.dist(agent, best);
            const bestHealth = best.health / best.stats.maxHealth;
            const bestThreat = (1 - bestHealth) * 0.6 + (150 - Math.min(bestDist, 150)) / 150 * 0.4;
            return threatScore > bestThreat ? enemy : best;
        });
    }
    
    _resolveAgentCollisions(dt) {
        const COLLISION_RADIUS = Agent.COLLISION_RADIUS;
        const REPULSION_STRENGTH = this.config?.PHYSICS?.AGENT_REPULSION_STRENGTH || 2.5;
        const MIN_SEPARATION = COLLISION_RADIUS * 2 + 4;
        const MAX_V = this.config?.PHYSICS?.MAX_VELOCITY || 15;
        
        for (let i = 0; i < this.enemies.length; i++) {
            const agentA = this.enemies[i];
            if (!agentA || !agentA.alive) continue;
            for (let j = i + 1; j < this.enemies.length; j++) {
                const agentB = this.enemies[j];
                if (!agentB || !agentB.alive) continue;
                const isAlly = agentA.teamId && agentA.teamId === agentB.teamId;
                const repulsion = isAlly ? REPULSION_STRENGTH * 0.3 : REPULSION_STRENGTH;
                const dx = agentB.x - agentA.x, dy = agentB.y - agentA.y;
                const dist = Math.hypot(dx, dy);
                if (dist < MIN_SEPARATION && dist > 0) {
                    const overlap = MIN_SEPARATION - dist;
                    const pushX = (dx / dist) * overlap * 0.5, pushY = (dy / dist) * overlap * 0.5;
                    agentA.x -= pushX; agentA.y -= pushY;
                    agentB.x += pushX; agentB.y += pushY;
                    const repulseX = (dx / dist) * repulsion, repulseY = (dy / dist) * repulsion;
                    agentA.vx -= repulseX * dt; agentA.vy -= repulseY * dt;
                    agentB.vx += repulseX * dt; agentB.vy += repulseY * dt;
                    agentA.vx = Utils.clamp(agentA.vx, -MAX_V, MAX_V);
                    agentA.vy = Utils.clamp(agentA.vy, -MAX_V, MAX_V);
                    agentB.vx = Utils.clamp(agentB.vx, -MAX_V, MAX_V);
                    agentB.vy = Utils.clamp(agentB.vy, -MAX_V, MAX_V);
                }
            }
        }
    }
    
    update(dt) {
        if (!this.enemies || this.enemies.length === 0) {
            console.error('World.update: No agents in world');
            return { episode: this.episode, totalFights: this.totalFights, winner: null };
        }
        
        this.step++;
        if (!this.enemies?.length || this.enemies.length < 2) { 
            console.error('World.update: Invalid agents'); 
            return { episode: this.episode, totalFights: this.totalFights, winner: null }; 
        }
        
        // ‚úÖ WIN CHECK AT START OF FRAME
        if (this.episodeInProgress) {
            const winResult = Utils.checkTeamWin(this);
            if (winResult) {
                this._endEpisode(winResult);
                return { episode: this.episode, totalFights: this.totalFights, winner: winResult.winner };
            }
        }
        
        // ‚úÖ RACE CONDITION FIX: Check episodeInProgress at start of each agent loop
        for (const agent of this.enemies) {
            if (!this.episodeInProgress) break; // ‚úÖ Stop processing if episode ended
            if (!agent || !agent.alive) continue;
            
            if (agent._heavyHit > 0) { agent._heavyHit--; }
            if (agent._pierced > 0) { agent._pierced--; }
            if (agent._pulseEffect > 0) { agent._pulseEffect--; }
            if (agent._continuousKB > 0) { agent._continuousKB = Math.max(0, agent._continuousKB - 0.03); }
            
            const enemies = Utils.getEnemies(agent, this);
            if (enemies.length > 0) { 
                const enemy = enemies[0], distance = Utils.dist(agent, enemy); 
                if (distance < 150) { 
                    agent.enemyPredictor.recordMove(agent.lastDecision?.behaviors || {}, distance, enemy.health / enemy.stats.maxHealth, agent.lastDecision?.behaviors?.aggression || 0.5); 
                    if (distance < 100) agent.decideCombatAction(enemy, this); 
                } 
            }
            const decision = agent.decide(this); 
            agent.move(decision.target, decision.speed, this.walls, dt, decision.output);
            agent.attackCooldown = Math.max(0, (agent.attackCooldown || 0) - 1);
            
            if (this.config?.enableFighting) {
                const opponents = Utils.getEnemies(agent, this);
                if (opponents.length > 0) {
                    const enemy = this._selectBestTarget(agent, opponents);
                    if (!enemy) continue;
                    
                    const dist = Utils.dist(agent, enemy), range = agent.attackRange || Agent.ATTACK_RANGE;
                    if (dist <= range && (agent.attackCooldown || 0) <= 0) {
                        if (!agent.isPointInWeaponArc(enemy)) {
                            agent.attackCooldown = Math.floor(agent.stats.fireRate * 0.4);
                            continue;
                        }
                        
                        this.totalFights++;
                        const aggression = agent.lastDecision?.behaviors?.aggression || 0.5;
                        const skill = agent.permanent?.skills?.combat || 0.3;
                        const baseDmg = agent.stats.damage;
                        
                        const directionalMult = enemy.calculateDirectionalDamageMultiplier(agent);
                        const damage = Math.floor(Utils.clamp(
                            baseDmg * (0.8 + aggression * 0.4) * (0.7 + skill * 0.6) * directionalMult, 
                            1, 15
                        ));
                        
                        const dodgeRoll = agent.net._rng.next();
                        if (dodgeRoll < enemy.stats.dodgeChance) {
                        } else {
                            enemy.health -= damage;
                            enemy._lastHitReceived = damage;
                            agent._lastHitDealt = damage;
                            
                            agent._totalAttacks++;
                            agent._totalDamageDealt += damage;
                            agent._successfulHits++;
                            
                            if (directionalMult >= 1.5) {
                                agent._tacticalHits++;
                            } else if (directionalMult <= 0.7) {
                                agent._frontalHits++;
                            }
                            
                            agent._lastAttackDir = Math.atan2(enemy.y - agent.y, enemy.x - agent.x);
                            agent._applyKnockback(enemy, aggression, agent.weapon);
                            
                            if (enemy.health <= 0) {
                                enemy.health = 0; 
                                enemy.alive = false;
                                
                                // ‚úÖ WIN CHECK AFTER DEATH
                                if (this.episodeInProgress) {
                                    const winResult = Utils.checkTeamWin(this);
                                    if (winResult) {
                                        this._endEpisode(winResult);
                                        return { episode: this.episode, totalFights: this.totalFights, winner: winResult.winner };
                                    }
                                }
                            }
                        }
                        agent.attackCooldown = agent.stats.fireRate;
                    } else if (this.config?.enableRanged && (agent.attackCooldown || 0) <= 0) {
                        if (agent.weapon.type === 'ranged') {
                            const aggr = agent.lastDecision?.behaviors?.aggression || 0.4;
                            if (aggr > 0.3 && dist > range && dist <= 200) {
                                const dir = Utils.normalize(enemy.x - agent.x, enemy.y - agent.y);
                                const speed = 10 + agent.net._rng.next() * 4;
                                const dmg = Math.floor(Utils.clamp(agent.stats.damage * 0.5 * (0.8 + aggr * 0.8), 1, 5));
                                const p = new Projectile(agent.x + dir.x * 12, agent.y + dir.y * 12, dir.x * speed, dir.y * speed, agent.id, dmg, 80);
                                this.projectiles.push(p); agent.attackCooldown = agent.stats.fireRate + 5; 
                            }
                        }
                    }
                }
            }
            const reward = agent.calculateReward(this, decision), nextInputs = agent.getInputs(this); 
            agent.learn(reward, decision, nextInputs);
            
            // ‚úÖ EMPATHY VALIDATION every N steps
            if (this.config?.enableDeepCognition && this.step % (this.config?.COGNITION?.empathyValidationSteps || 10) === 0) {
                agent.validateLastPrediction();
            }
        }
        
        this._resolveAgentCollisions(dt);
        
        for (const p of this.projectiles) {
            if (!p?.alive) continue; p.update(dt);
            for (const w of this.walls) { if (Utils.dist(p, w) < 14 + p.radius) { p.alive = false; break; } }
            if (!p.alive) continue;
            for (const e of this.enemies) { 
                if (!e || !e.alive || e.id === p.owner) continue; 
                const ownerAgent = this.enemies.find(a => a && a.id === p.owner);
                if (!ownerAgent) {
                    p.alive = false; // ‚úÖ Despawn invalid projectile
                    continue;
                }
                if (Utils.dist(p, e) < 15) { 
                    const dodgeRoll = e.net._rng.next();
                    if (dodgeRoll >= e.stats.dodgeChance) { 
                        e.health -= p.damage; 
                        e._lastHitReceived = p.damage; 
                    } 
                    p.alive = false; 
                    if (e.health <= 0) { 
                        e.health = 0; e.alive = false;
                        if (this.episodeInProgress) {
                            const winResult = Utils.checkTeamWin(this);
                            if (winResult) {
                                this._endEpisode(winResult);
                                return { episode: this.episode, totalFights: this.totalFights, winner: winResult.winner };
                            }
                        }
                    } 
                    break; 
                } 
            }
        }
        this.projectiles = this.projectiles.filter(p => p?.alive);
        
        return { episode: this.episode, totalFights: this.totalFights, winner: null };
    }
    
    _endEpisode(winResult) {
        this.episodeInProgress = false;
        this.episode++;
        this.teamWins[winResult.winner] = (this.teamWins[winResult.winner] || 0) + 1;
        
        const winningTeam = this.enemies.filter(a => a?.teamId === winResult.winner);
        winningTeam.forEach(a => {
            if (a && a.alive) {
                a.net.updateDiagnostics({ teamWin: true });
                a.cumulativeReward += this.config?.EVOLUTION?.TEAM_WIN_BONUS || 100;
                a.wins++;
            }
        });
        
        if (window.arenaGame) {
            window.arenaGame.showWinnerBanner(winResult.winner, winResult.type);
        }
        
        Logger.log(`üèÜ –ü–û–ë–ï–î–ê: ${winResult.winner.toUpperCase()} (${winResult.type})`, 'success');
        
        setTimeout(() => {
            if (window.arenaGame) window.arenaGame.resetEpisode();
        }, 3000);
    }
    
    resetEpisode() { 
        const banner = document.getElementById('winnerBanner');
        if (banner) banner.classList.remove('active');
        
        const mode = this.config?.GAME?.currentMode || '1v1';
        const spawnPositions = {
            '1v1': [{ x: 150, y: 150, team: null }, { x: 670, y: 450, team: null }],
            '2v2': [{ x: 100, y: 150, team: 'blue' }, { x: 150, y: 200, team: 'blue' }, { x: 670, y: 450, team: 'red' }, { x: 720, y: 400, team: 'red' }],
            '4way': [{ x: 150, y: 150, team: 'blue' }, { x: 670, y: 150, team: 'red' }, { x: 150, y: 450, team: 'green' }, { x: 670, y: 450, team: 'yellow' }]
        };
        const positions = spawnPositions[mode] || spawnPositions['1v1'];
        
        for (let i = 0; i < this.enemies.length; i++) {
            const agent = this.enemies[i];
            const pos = positions[i];
            if (agent && pos) {
                agent.reset(pos.x, pos.y);
                agent.alive = true;
                agent.teamId = pos.team || null;
                if (agent.teamId) {
                    agent.updateAllies(this);
                } else {
                    agent.allies = [];
                }
            }
        }
        
        this.enemies.forEach(a => a._clearLearningBuffer());
        
        this.episodeInProgress = true;
        Logger.log(`üîÑ –ù–æ–≤—ã–π —ç–ø–∏–∑–æ–¥ ${this.episode}`, 'info');
    }
    
    draw(ctx, vision = false, trail = true) {
        if (!ctx) return; 
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        const grad = ctx.createLinearGradient(0, 0, this.logicalWidth, this.logicalHeight); 
        grad.addColorStop(0, '#0a0a15'); grad.addColorStop(1, '#1a1a2e'); 
        ctx.fillStyle = grad; ctx.fillRect(0, 0, this.logicalWidth, this.logicalHeight);
        ctx.strokeStyle = 'rgba(50,50,90,0.25)'; ctx.lineWidth = 1;
        for (let x = 0; x < this.logicalWidth; x += 50) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, this.logicalHeight); ctx.stroke(); }
        for (let y = 0; y < this.logicalHeight; y += 50) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(this.logicalWidth, y); ctx.stroke(); }
        ctx.fillStyle = '#4a4a7a'; 
        for (const w of this.walls) { 
            ctx.beginPath(); ctx.arc(w.x, w.y, 14, 0, Math.PI * 2); ctx.fill(); 
            ctx.strokeStyle = '#6a6a9a'; ctx.lineWidth = 2; ctx.stroke(); 
        }
        for (const pr of this.projectiles || []) if (pr) pr.draw(ctx);
        for (const a of this.enemies) if (a) a.draw(ctx, vision, trail);
        ctx.fillStyle = 'rgba(100,100,140,0.5)'; ctx.font = '10px monospace'; 
        ctx.fillText(`Step: ${this.step} | Ep: ${this.episode} | Fights: ${this.totalFights}`, 12, this.logicalHeight - 12);
    }
}

// ============================================================================
// GAME ENGINE v5.0 ‚Äî Complete, optimized, validated
// ============================================================================
class GameEngine {
    constructor(config = null) {
        this.config = config || Arena.getConfig();
        this.canvas = document.getElementById('gameCanvas');
        if (!this.canvas) { console.error('Canvas element not found'); alert('–û—à–∏–±–∫–∞: Canvas —ç–ª–µ–º–µ–Ω—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω!'); return; }
        this.ctx = this.canvas.getContext('2d');
        if (!this.ctx) { console.error('Failed to get canvas context'); alert('–û—à–∏–±–∫–∞: –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∫–æ–Ω—Ç–µ–∫—Å—Ç canvas!'); return; }
        this.settings = { ...this.config };
        this.logicalWidth = this.config?.ARCH?.LOGICAL_WIDTH || 820; this.logicalHeight = this.config?.ARCH?.LOGICAL_HEIGHT || 600;
        this.resize();
        this.world = new World(this.logicalWidth, this.logicalHeight, this.config);
        this.running = false; this.lastTime = 0; this.fps = 60; this.vision = false; this.debug = false; this.showMetrics = true;
        this.selectedAgent = null; this.rafId = null;
        this._onResize = this._onResize.bind(this); this._onClick = this._onClick.bind(this); this._onKey = this._onKey.bind(this);
        this._onTouchStart = this._onTouchStart.bind(this);
        this.setupEvents(); this.init();
    }
    
    resize() { 
        const parent = this.canvas?.parentElement; 
        if (!parent) return; 
        const dpr = window.devicePixelRatio || 1;
        this.canvas.width = parent.clientWidth * dpr;
        this.canvas.height = parent.clientHeight * dpr;
        this.ctx.scale(dpr, dpr);
        this.scaleX = (parent.clientWidth * dpr) / this.logicalWidth;
        this.scaleY = (parent.clientHeight * dpr) / this.logicalHeight;
    }
    _onResize() { this.resize(); }
    
    _debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    }
    
    _onTouchStart(e) {
        e.preventDefault();
    }
    
    setupEvents() {
        const debouncedResize = this._debounce(this._onResize, 150);
        window.addEventListener('resize', debouncedResize);
        const handlePointer = (e) => { 
            const rect = this.canvas.getBoundingClientRect(), 
                  scaleX = this.canvas.width / rect.width, 
                  scaleY = this.canvas.height / rect.height, 
                  clientX = e.touches?.[0]?.clientX ?? e.clientX, 
                  clientY = e.touches?.[0]?.clientY ?? e.clientY, 
                  x = (clientX - rect.left) * scaleX, 
                  y = (clientY - rect.top) * scaleY; 
            this._onClick({ x, y }); 
        };
        this.canvas.addEventListener('click', handlePointer); 
        this.canvas.addEventListener('touchend', handlePointer); 
        this.canvas.addEventListener('touchstart', this._onTouchStart, { passive: false });
        document.addEventListener('keydown', this._onKey); 
        this.canvas.setAttribute('tabindex', '0'); 
        this.canvas.setAttribute('role', 'application'); 
        this.canvas.setAttribute('aria-label', 'AI Arena simulation canvas');
        const bindClick = (id, handler) => { const btn = document.getElementById(id); if (btn) btn.addEventListener('click', handler); };
        bindClick('btnStart', () => this.toggle()); 
        bindClick('btnReset', () => this.reset()); 
        bindClick('btnSave', () => this.save()); 
        bindClick('btnLoad', () => this.load()); 
        bindClick('btnExport', () => this.exportWeights());
        bindClick('btnImport', () => document.getElementById('fileImport')?.click()); 
        bindClick('btnDebug', () => this.toggleDebug()); 
        bindClick('btnVision', () => { this.vision = !this.vision; this.updateBtns(); }); 
        bindClick('btnApplyWeapons', () => this.applyWeapons());
        bindClick('btnRandomWeapons', () => this.randomWeapons());
        const fileImport = document.getElementById('fileImport');
        if (fileImport) fileImport.addEventListener('change', (e) => this.importWeights(e)); 
        const bindSlider = (id, key, displayId) => { 
            const slider = document.getElementById(id), display = document.getElementById(displayId); 
            if (!slider || !display) return; 
            slider.addEventListener('input', (e) => { 
                const value = parseFloat(e.target.value); 
                this.settings[key] = value; 
                display.textContent = value; 
                if (this.world?.enemies) { 
                    this.world.enemies.forEach(a => { 
                        if (a?.net) { a.net.lr = this.settings.learningRate; a.net.lambda = this.settings.lambda; a.net.gamma = this.settings.gamma; a.net.entropyCoeff = this.settings.entropyCoeff; a.net.policyTemp = this.settings.policyTemperature; } 
                        if (a?.critic) a.critic.lr = this.settings.learningRate; 
                        if (a?.policySelector) a.policySelector.lr = this.settings.learningRate * 0.6; 
                    }); 
                } 
            }); 
        };
        bindSlider('learningRate', 'learningRate', 'learningRateValue'); 
        bindSlider('lambda', 'lambda', 'lambdaValue'); 
        bindSlider('mutationRate', 'mutationRate', 'mutationRateValue');
        bindSlider('policyTemp', 'policyTemperature', 'policyTempValue');
        const bindToggle = (id, key) => { 
            const toggle = document.getElementById(id); 
            if (toggle) toggle.addEventListener('change', (e) => { this.settings[key] = e.target.checked; }); 
        };
        bindToggle('enableTraining', 'enableTraining'); 
        bindToggle('enableEvolution', 'enableEvolution'); 
        bindToggle('enableFighting', 'enableFighting'); 
        bindToggle('enableRanged', 'enableRanged');
        bindToggle('enableWeightInheritance', 'enableWeightInheritance');
        bindToggle('enableTactical', 'enableTactical');
        bindToggle('enableTeamwork', 'enableTeamwork');
        bindToggle('enableDeepCognition', 'enableDeepCognition');
        
        // ‚úÖ PATCH: MODE SELECTOR with proper error handling
        const modeSelect = document.getElementById('gameModeSelect');
        if (modeSelect) {
            modeSelect.value = this.config?.GAME?.currentMode || '1v1';
            modeSelect.addEventListener('change', (e) => {
                try {
                    const newMode = e.target.value;
                    console.log('üéÆ Mode change requested:', newMode);
                    
                    // ‚úÖ Validate config exists
                    if (!this.config) {
                        throw new Error('Config is undefined');
                    }
                    
                    // ‚úÖ Validate GAME object exists
                    if (!this.config.GAME) {
                        throw new Error('config.GAME is undefined');
                    }
                    
                    // ‚úÖ Safely set mode
                    this.config.GAME.currentMode = newMode;
                    
                    // ‚úÖ Also update settings for consistency
                    if (this.settings && this.settings.GAME) {
                        this.settings.GAME.currentMode = newMode;
                    }
                    
                    // ‚úÖ Reset game with new mode
                    this.reset();
                    
                    Logger.log(`üéÆ –†–µ–∂–∏–º –∏–∑–º–µ–Ω–µ–Ω –Ω–∞: ${newMode}`, 'success');
                    console.log('‚úÖ Mode changed successfully to:', newMode);
                } catch (err) {
                    console.error('‚ùå Mode change failed:', err);
                    Logger.log(`‚ùå –û—à–∏–±–∫–∞ —Å–º–µ–Ω—ã —Ä–µ–∂–∏–º–∞: ${err.message}`, 'error');
                    
                    // ‚úÖ Reset select to current mode
                    modeSelect.value = this.config?.GAME?.currentMode || '1v1';
                }
            });
            
            console.log('‚úÖ Mode select handler attached successfully');
        }
    }
    
    _onKey(e) { 
        if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code)) e.preventDefault(); 
        switch (e.key) { 
            case ' ': e.preventDefault(); this.toggle(); break; 
            case '1': this.selectedAgent = this.world?.enemies?.[0]; this.updateDebugPanel(); break; 
            case '2': this.selectedAgent = this.world?.enemies?.[1]; this.updateDebugPanel(); break; 
            case '3': this.selectedAgent = this.world?.enemies?.[2]; this.updateDebugPanel(); break; 
            case '4': this.selectedAgent = this.world?.enemies?.[3]; this.updateDebugPanel(); break; 
            case 'Tab': e.preventDefault(); const focusable = document.querySelectorAll('button, input, [tabindex="0"]'), idx = Array.from(focusable).indexOf(document.activeElement); focusable[(idx + 1) % focusable.length]?.focus(); break; 
            case 'Escape': if (this.debug) { this.debug = false; this.updateDebugPanel(); } break; 
        } 
    }
    
    _onClick({ x, y }) { 
        if (!this.debug) return; 
        const lx = x / this.scaleX, ly = y / this.scaleY; 
        let nearest = null, minD = 25; 
        for (const a of this.world?.enemies || []) { 
            if (!a) continue; 
            const d = Math.hypot(a.x - lx, a.y - ly); 
            if (d < minD) { minD = d; nearest = a; } 
        } 
        this.selectedAgent = nearest; 
        if (nearest) Logger.log(`üîç –í—ã–±—Ä–∞–Ω –∞–≥–µ–Ω—Ç ${nearest.id}`, 'info'); 
        this.updateDebugPanel(); 
    }
    
    updateUI() {
        const mode = this.config?.GAME?.currentMode || '1v1';
        const maxAgents = this.config?.GAME?.maxAgents?.[mode] || 2;
        const container = document.getElementById('agentsContainer');
        const weaponControls = document.getElementById('weaponControls');
        const teamStatus = document.getElementById('teamStatus');
        if (!container || !weaponControls) return;
        
        if (teamStatus && this.world) {
            const teams = Utils.getAllTeams(this.world);
            teamStatus.innerHTML = teams.map(teamId => {
                const alive = Utils.getTeamAliveCount(teamId, this.world);
                const total = this.world.enemies.filter(a => a?.teamId === teamId).length;
                const color = this.config?.GAME?.teamColors?.[teamId];
                return `
                    <div class="team-status-item ${teamId}">
                        <span style="color:${color};font-weight:700">${teamId.toUpperCase()}</span>
                        <span class="team-status-count">${alive}/${total}</span>
                        <span class="${alive > 0 ? 'team-status-alive' : 'team-status-dead'}">‚óè</span>
                    </div>
                `;
            }).join('');
        }
        
        container.innerHTML = '';
        weaponControls.innerHTML = '';
        
        for (let i = 0; i < maxAgents; i++) {
            const agent = this.world?.enemies?.[i];
            const teamColor = agent?.teamId ? this.config?.GAME?.teamColors?.[agent.teamId] : agent?.color || '#fff';
            const teamBadge = agent?.teamId ? `<span class="team-badge ${agent.teamId}">${agent.teamId.toUpperCase()}</span>` : '';
            
            const card = document.createElement('article');
            card.className = `agent-card team-${agent?.teamId || 'blue'}${!agent?.alive ? ' dead' : ''}`;
            card.innerHTML = `
                <header class="agent-header">
                    <span style="color:${teamColor}">‚óè</span> ${agent?.id?.toUpperCase() || `AGENT${i+1}`} ${teamBadge}
                    <span class="mode-badge mode-combat" id="${agent?.id}-mode">COMBAT</span>
                </header>
                <div class="health-bar"><div class="health-fill" id="${agent?.id}-health" style="width:${agent?.alive ? (agent.health / agent.stats.maxHealth) * 100 : 0}%"></div></div>
                <div class="agent-stats">
                    <span>Reward: <b id="${agent?.id}-reward">${agent?.cumulativeReward.toFixed(2) || '0.00'}</b></span>
                    <span>Wins: <b id="${agent?.id}-wins">${agent?.wins || 0}</b></span>
                    <span>Gen: <b id="${agent?.id}-gen">${agent?.generation || 1}</b></span>
                </div>
                <div style="font-size:0.5rem;margin-top:0.0625rem;color:var(--text-dim)">
                    <span class="stat-badge stat-hp" id="${agent?.id}-stat-hp">HP:${agent?.stats.maxHealth || 100}</span>
                    <span class="stat-badge stat-str" id="${agent?.id}-stat-dmg">DMG:${agent?.stats.damage || 3}</span>
                    <span class="stat-badge stat-spd" id="${agent?.id}-stat-spd">SPD:${agent?.stats.fireRate || 15}</span>
                    <span class="stat-badge stat-dod" id="${agent?.id}-stat-dod">DOD:${Math.round((agent?.stats.dodgeChance || 0) * 100)}%</span>
                </div>
                <div class="weapon-badge" id="${agent?.id}-weapon">${agent?.weapon?.icon || 'üî®'} ${agent?.weapon?.name?.toUpperCase() || 'HAMMER'}</div>
            `;
            container.appendChild(card);
            
            const weaponCtrl = document.createElement('div');
            weaponCtrl.className = 'control-group';
            weaponCtrl.innerHTML = `
                <label class="control-label"><span style="color:${teamColor}">‚óè ${agent?.id?.toUpperCase() || `AGENT${i+1}`}</span></label>
                <select id="${agent?.id}-weapon-select">
                    ${Object.entries(WEAPONS).map(([k,v]) => `<option value="${k}"${agent?.weaponType === k ? ' selected' : ''}>${v.icon} ${v.name}</option>`).join('')}
                </select>
            `;
            weaponControls.appendChild(weaponCtrl);
        }
    }
    
    init() { 
        this.world.reset(); 
        const mode = this.config?.GAME?.currentMode || '1v1';
        
        const weaponMap = {};
        const positions = {
            '1v1': [{ x: 150, y: 150, team: null }, { x: 670, y: 450, team: null }],
            '2v2': [{ x: 100, y: 150, team: 'blue' }, { x: 150, y: 200, team: 'blue' }, { x: 670, y: 450, team: 'red' }, { x: 720, y: 400, team: 'red' }],
            '4way': [{ x: 150, y: 150, team: 'blue' }, { x: 670, y: 150, team: 'red' }, { x: 150, y: 450, team: 'green' }, { x: 670, y: 450, team: 'yellow' }]
        }[mode] || [{ x: 150, y: 150, team: null }, { x: 670, y: 450, team: null }];
        const maxAgents = this.config?.GAME?.maxAgents?.[mode] || 2;
        for (let i = 0; i < Math.min(maxAgents, positions.length); i++) {
            const pos = positions[i];
            const agentKey = pos.team || `agent${i}`;
            weaponMap[agentKey] = 'hammer';
        }
        
        this.world.spawnAgents(mode, weaponMap);
        this.updateUI();
        
        this.world.enemies.forEach(a => { 
            if (!a) return; 
            a.net.lr = this.settings.learningRate; 
            a.net.lambda = this.settings.lambda; 
            a.net.gamma = this.settings.gamma; 
            a.net.policyTemp = this.settings.policyTemperature;
            if (a.critic) a.critic.lr = this.settings.learningRate; 
            if (a.policySelector) a.policySelector.lr = this.settings.learningRate * 0.6; 
        }); 
        
        this.updateStats(); 
        this.updateMetrics(); 
        if (this.world.enemies[0] && this.world.enemies[1]) {
            this.world.draw(this.ctx, false, true); 
        }
        
        Logger.log('üöÄ AI ARENA v5.0 Professional [DEEP COGNITION] –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞', 'success'); 
        Logger.log(`üîß –†–µ–∂–∏–º: ${mode} (${this.config?.GAME?.maxAgents?.[mode]||2} –∞–≥–µ–Ω—Ç–æ–≤)`, 'success'); 
        Logger.log('üèÜ –ü–æ–±–µ–¥–∞ —Ç–æ–ª—å–∫–æ –ø—Ä–∏ —É—Å—Ç—Ä–∞–Ω–µ–Ω–∏–∏ –í–°–ï–ô –∫–æ–º–∞–Ω–¥—ã', 'success');
        Logger.log('üë• –ö–æ–º–∞–Ω–¥–Ω–∞—è –∏–≥—Ä–∞: –∫–æ–æ—Ä–¥–∏–Ω–∞—Ü–∏—è + –∑–∞—â–∏—Ç–∞ —Å–æ—é–∑–Ω–∏–∫–æ–≤', 'success');
        Logger.log('üß† Deep Cognition: Attention+ToM+MetaMemory+Imagination', 'success');
    }
    
    toggle() { 
        this.running = !this.running; 
        const btn = document.getElementById('btnStart'); 
        if (btn) { 
            btn.textContent = this.running ? '‚è∏ –ü–∞—É–∑–∞' : '‚ñ∂ –°—Ç–∞—Ä—Ç'; 
            btn.className = this.running ? 'btn-danger' : 'btn-primary'; 
            btn.setAttribute('aria-pressed', String(this.running)); 
        } 
        Logger.log(this.running ? '‚ñ∂ –°–∏–º—É–ª—è—Ü–∏—è –∑–∞–ø—É—â–µ–Ω–∞' : '‚è∏ –ü–∞—É–∑–∞', 'info'); 
        if (this.running) { this.lastTime = performance.now(); this.loop(); } 
    }
    
    // ‚úÖ PATCH: Fixed reset() with proper cleanup
    reset() { 
        console.log('üîÑ GameEngine.reset() called');
        
        // ‚úÖ CRITICAL: Cancel any existing animation frame FIRST
        if (this.rafId) {
            cancelAnimationFrame(this.rafId);
            this.rafId = null;
            console.log('‚èπÔ∏è Cancelled existing animation frame');
        }
        
        // ‚úÖ Stop running state
        this.running = false;
        
        // ‚úÖ Update UI button state
        const btn = document.getElementById('btnStart'); 
        if (btn) { 
            btn.textContent = '‚ñ∂ –°—Ç–∞—Ä—Ç'; 
            btn.className = 'btn-primary'; 
            btn.setAttribute('aria-pressed', 'false'); 
        }
        
        const mode = this.config?.GAME?.currentMode || '1v1';
        
        // ‚úÖ Create weaponMap with proper keys
        const weaponMap = {};
        const positions = {
            '1v1': [{ x: 150, y: 150, team: null }, { x: 670, y: 450, team: null }],
            '2v2': [{ x: 100, y: 150, team: 'blue' }, { x: 150, y: 200, team: 'blue' }, { x: 670, y: 450, team: 'red' }, { x: 720, y: 400, team: 'red' }],
            '4way': [{ x: 150, y: 150, team: 'blue' }, { x: 670, y: 150, team: 'red' }, { x: 150, y: 450, team: 'green' }, { x: 670, y: 450, team: 'yellow' }]
        }[mode] || [{ x: 150, y: 150, team: null }, { x: 670, y: 450, team: null }];
        
        const maxAgents = this.config?.GAME?.maxAgents?.[mode] || 2;
        for (let i = 0; i < Math.min(maxAgents, positions.length); i++) {
            const pos = positions[i];
            const agentKey = pos.team || `agent${i}`;
            weaponMap[agentKey] = 'hammer';
        }
        
        // ‚úÖ Create NEW world instance
        this.world = new World(this.logicalWidth, this.logicalHeight, this.config); 
        this.world.reset(); 
        this.world.spawnAgents(mode, weaponMap);
        
        // ‚úÖ Update UI
        this.updateUI();
        
        // ‚úÖ Configure agent neural networks
        this.world.enemies?.forEach(a => { 
            if (!a) return; 
            a.net.lr = this.settings.learningRate; 
            a.net.lambda = this.settings.lambda; 
            a.net.gamma = this.settings.gamma; 
            a.net.policyTemp = this.settings.policyTemperature;
            if (a.critic) a.critic.lr = this.settings.learningRate; 
            if (a.policySelector) a.policySelector.lr = this.settings.learningRate * 0.6; 
        }); 
        
        Logger.log('üîÑ –°–∏–º—É–ª—è—Ü–∏—è —Å–±—Ä–æ—à–µ–Ω–∞', 'warn'); 
        this.updateStats(); 
        this.updateMetrics(); 
        
        console.log('‚úÖ GameEngine.reset() completed successfully');
    }
    
    resetEpisode() {
        this.world.resetEpisode();
        this.updateUI();
        this.updateStats();
    }
    
    loop() { 
        if (!this.running) return; 
        if (!this.ctx || !this.world) { console.error('Context or world lost'); this.running = false; return; } 
        if (!this.world.enemies?.length || this.world.enemies.length < 2) { 
            console.error('Invalid agents in world'); 
            this.running = false; 
            Logger.log('‚ùå –û—à–∏–±–∫–∞: –∞–≥–µ–Ω—Ç—ã –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –∏–ª–∏ –Ω–µ–≤–∞–ª–∏–¥–Ω—ã', 'error'); 
            return; 
        } 
        const now = performance.now(), 
              dt = Math.min((now - this.lastTime) / 16.67, 3), 
              fps = Math.round(1000 / (now - this.lastTime + 0.001)); 
        this.fps = fps; 
        this.lastTime = now; 
        const fpsEl = document.getElementById('fpsCounter'); 
        if (fpsEl) fpsEl.textContent = `FPS: ${this.fps}`; 
        try { 
            const state = this.world.update(dt); 
            this.world.draw(this.ctx, this.vision); 
            this.updateStats(state); 
            if (this.showMetrics) this.updateMetrics(); 
            if (this.debug) this.updateDebugPanel(); 
            // ‚úÖ THROTTLED UI updates: every 6 frames (~10 FPS)
            if (this.world.episodeInProgress && this.world.step % 6 === 0) {
                this.updateUI(); 
            }
        } catch (e) { 
            console.error('Loop error:', e); 
            Logger.log(`‚ùå –û—à–∏–±–∫–∞ –≤ —Ü–∏–∫–ª–µ: ${e.message}`, 'error'); 
            this.running = false; 
            return; 
        } 
        this.rafId = requestAnimationFrame(() => this.loop()); 
    }
    
    updateStats(state = null) { 
        if (!state) { 
            if (!this.world?.enemies?.length) return; 
            state = { episode: this.world.episode, totalFights: this.world.totalFights, winner: null }; 
        } 
        const { episode, totalFights } = state; 
        const updateText = (id, val) => { const el = document.getElementById(id); if (el) el.textContent = typeof val === 'number' ? val.toFixed(2) : val; }; 
        updateText('episodeStat', episode); 
        updateText('stepStat', this.world.step); 
        updateText('totalFightsStat', totalFights); 
        const totalWins = Object.values(this.world.teamWins).reduce((s, v) => s + v, 0);
        updateText('winsStat', totalWins);
        const progressEl = document.getElementById('episodeProgress'); 
        if (progressEl) { progressEl.style.width = `${(episode % 10) * 10}%`; progressEl.setAttribute('aria-valuenow', String((episode % 10) * 10)); }
    
        for (const agent of this.world.enemies) {
            if (!agent) continue;
            const healthEl = document.getElementById(`${agent.id}-health`);
            const rewardEl = document.getElementById(`${agent.id}-reward`);
            const winsEl = document.getElementById(`${agent.id}-wins`);
            const genEl = document.getElementById(`${agent.id}-gen`);
            const hpEl = document.getElementById(`${agent.id}-stat-hp`);
            const dmgEl = document.getElementById(`${agent.id}-stat-dmg`);
            const spdEl = document.getElementById(`${agent.id}-stat-spd`);
            const dodEl = document.getElementById(`${agent.id}-stat-dod`);
            const weaponEl = document.getElementById(`${agent.id}-weapon`);
            const card = document.querySelector(`.agent-card.team-${agent.teamId || 'blue'}`);
            
            if (healthEl) healthEl.style.width = `${agent.alive ? (agent.health / agent.stats.maxHealth) * 100 : 0}%`;
            if (rewardEl) rewardEl.textContent = agent.cumulativeReward.toFixed(2);
            if (winsEl) winsEl.textContent = agent.wins;
            if (genEl) genEl.textContent = agent.generation;
            if (dodEl) dodEl.textContent = `DOD:${Math.round(agent.stats.dodgeChance * 100)}%`;
            if (weaponEl) weaponEl.textContent = `${agent.weapon.icon} ${agent.weapon.name.toUpperCase()}`;
            if (card) {
                if (agent.alive) card.classList.remove('dead');
                else card.classList.add('dead');
            }
        }
    }
    
    // ‚úÖ METRICS v5.0 with all new fields
    updateMetrics() {
        if (!this.showMetrics || !this.world?.enemies?.length) return;
        const blue = this.world.enemies[0], red = this.world.enemies[1];
        if (!blue || !red) return;
        const blueMetrics = blue.getLearningMetrics(), redMetrics = red.getLearningMetrics(),
              avgTD = (blueMetrics.avgTDError + redMetrics.avgTDError) / 2,
              avgWin = (blueMetrics.winRate + redMetrics.winRate) / 2,
              avgDmg = (blueMetrics.avgDamage + redMetrics.avgDamage) / 2,
              avgAcc = (blueMetrics.accuracy + redMetrics.accuracy) / 2;
        
        const tdEl = document.getElementById('metricTDError'),
              winEl = document.getElementById('metricWinRate'),
              dmgEl = document.getElementById('metricDamage'),
              accEl = document.getElementById('metricAccuracy');
        
        if (tdEl) { tdEl.textContent = avgTD.toFixed(4); tdEl.className = `metric-value${avgTD < 0.5 ? ' good' : avgTD > 2 ? ' degrading' : ''}`; }
        if (winEl) winEl.textContent = avgWin.toFixed(2);
        if (dmgEl) dmgEl.textContent = avgDmg.toFixed(2);
        if (accEl) accEl.textContent = avgAcc.toFixed(2);
        
        // ‚úÖ v5.0 NEW METRICS
        const lrEl = document.getElementById('currentLR');
        if (lrEl) lrEl.textContent = blue.net.lr.toFixed(4);
        
        const empAcc = (blue.empathyStats.total > 0 ? blue.empathyStats.correct / blue.empathyStats.total : 0);
        const empEl = document.getElementById('empathyAcc');
        if (empEl) empEl.textContent = empAcc.toFixed(2);
        
        const memConf = Array.from(blue.net._memoryPermanent.confidence).reduce((a,b) => a+b, 0) / blue.net.memoryDim;
        const memEl = document.getElementById('memoryConf');
        if (memEl) memEl.textContent = memConf.toFixed(2);
        
        const gateProbs = blue.net.getGateProbs();
        const expEl = document.getElementById('expertLoad');
        if (expEl && gateProbs) expEl.textContent = gateProbs.map(p => p.toFixed(2)).join('/');
        
        const tdHistory = blue.net._trainingStats.tdErrorHistory;
        const curveEl = document.getElementById('learningCurve');
        if (curveEl && tdHistory.length > 0) {
            const recentAvg = tdHistory.slice(-10).reduce((a,b) => a+b, 0) / 10;            const curveWidth = 100 - Math.min(100, recentAvg * 20);
            curveEl.style.width = curveWidth + '%';
        }
    }
    
    updateDebugPanel() {
        const panel = document.getElementById('debugPanel'), isActive = this.debug && this.selectedAgent;
        panel.classList.toggle('active', isActive);
        panel.hidden = !isActive;
        if (!isActive || !this.selectedAgent) return;
        const info = this.selectedAgent.getDebugInfo(),
              setDebugValue = (id, value) => { const el = document.getElementById(id); if (el) el.textContent = value; };
        setDebugValue('dbgMode', info.mode);
        setDebugValue('dbgWeapon', info.weapon);
        setDebugValue('dbgHealth', info.health);
        setDebugValue('dbgTeam', info.teamId);
        setDebugValue('dbgWins', info.wins);
        setDebugValue('dbgTDErr', info.tdError);
        setDebugValue('dbgThreat', info.threat);
        setDebugValue('dbgFlank', info.flank);
        setDebugValue('dbgLR', info.lr);
        setDebugValue('dbgEmp', info.empathy);
        setDebugValue('dbgMemC', info.memConf);
        setDebugValue('dbgImag', info.imagination);
    }
    
    toggleDebug() {
        this.debug = !this.debug;
        const btn = document.getElementById('btnDebug');
        if (btn) { btn.classList.toggle('active', this.debug); btn.setAttribute('aria-pressed', String(this.debug)); }
        this.updateDebugPanel();
        Logger.log(`üîç Debug ${this.debug ? '–≤–∫–ª—é—á—ë–Ω' : '–≤—ã–∫–ª—é—á–µ–Ω'}`, this.debug ? 'success' : 'info');
    }
    
    updateBtns() {
        const visionBtn = document.getElementById('btnVision');
        if (visionBtn) { visionBtn.classList.toggle('active', this.vision); visionBtn.setAttribute('aria-pressed', String(this.vision)); }
    }
    
    save() {
        try {
            const data = {
                version: '5.0',
                timestamp: Date.now(),
                settings: this.settings,
                mode: this.config?.GAME?.currentMode,
                world: { episode: this.world.episode, step: this.world.step, totalFights: this.world.totalFights, walls: this.world.walls.map(w => ({ x: w.x, y: w.y })), teamWins: this.world.teamWins },
                agents: this.world.enemies.map(a => a ? a.toJSON() : null).filter(a => a)
            };
            localStorage.setItem('aiArenaV5Pro', JSON.stringify(data));            Logger.log('üíæ –°–æ—Ö—Ä–∞–Ω–µ–Ω–æ (v5.0 Professional)', 'success');
        } catch (e) {
            if (e.name === 'QuotaExceededError') Logger.log('üíæ –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω–æ: –ø—Ä–µ–≤—ã—à–µ–Ω –ª–∏–º–∏—Ç —Ö—Ä–∞–Ω–∏–ª–∏—â–∞', 'error');
            else Logger.log(`‚ùå –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è: ${e.message}`, 'error');
        }
    }
    
    load() {
        try {
            const raw = localStorage.getItem('aiArenaV5Pro');
            if (!raw) { Logger.log('‚ùå –ù–µ—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–π v5.0', 'error'); return; }
            const data = JSON.parse(raw);
            if (data.version !== '5.0') { Logger.log('‚ö†Ô∏è –¢—Ä–µ–±—É–µ—Ç—Å—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ v5.0', 'warn'); return; }
            this.config.GAME.currentMode = data.mode || '1v1';
            document.getElementById('gameModeSelect').value = this.config.GAME.currentMode;
            this.settings = { ...this.settings, ...data.settings };
            document.getElementById('learningRate').value = this.settings.learningRate;
            document.getElementById('lambda').value = this.settings.lambda;
            document.getElementById('learningRateValue').textContent = this.settings.learningRate;
            document.getElementById('lambdaValue').textContent = this.settings.lambda;
            document.getElementById('mutationRate').value = this.settings.mutationRate;
            document.getElementById('mutationRateValue').textContent = this.settings.mutationRate;
            document.getElementById('policyTemp').value = this.settings.policyTemperature;
            document.getElementById('policyTempValue').textContent = this.settings.policyTemperature;
            this.world.episode = data.world?.episode || 0;
            this.world.step = data.world?.step || 0;
            this.world.totalFights = data.world?.totalFights || 0;
            this.world.teamWins = data.world?.teamWins || { blue: 0, red: 0, green: 0, yellow: 0 };
            this.world.walls = data.world?.walls || [];
            this.world.enemies = data.agents?.map((a, i) => a ? Agent.fromJSON(a, this.config?.GAME?.teamColors?.[a.teamId] || '#fff', this.config) : null).filter(a => a) || [];
            this.world.enemies.forEach(a => {
                if (!a) return;
                a.net.lr = this.settings.learningRate;
                a.net.lambda = this.settings.lambda;
                a.net.gamma = this.settings.gamma;
                a.net.policyTemp = this.settings.policyTemperature;
                if (a.critic) a.critic.lr = this.settings.learningRate;
                if (a.policySelector) a.policySelector.lr = this.settings.learningRate * 0.6;
                if (a.teamId) a.updateAllies(this.world);
            });
            Logger.log('üìÇ –ó–∞–≥—Ä—É–∂–µ–Ω–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ v5.0', 'success');
            this.updateStats({ episode: this.world.episode, totalFights: this.world.totalFights });
            this.updateMetrics();
        } catch (e) { Logger.log(`‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏: ${e.message}`, 'error'); }
    }
    
    exportWeights() {
        try {
            const data = { version: '5.0', timestamp: Date.now(), mode: this.config?.GAME?.currentMode, agents: this.world.enemies.map(a => a?.toJSON() || null).filter(a => a) },
                  blob = new Blob([JSON.stringify(data)], { type: 'application/json' }),                  url = URL.createObjectURL(blob),
                  a = document.createElement('a');
            a.href = url; a.download = `arena-v5.0-pro-${Date.now()}.json`; a.click();
            URL.revokeObjectURL(url);
            Logger.log('üì§ –ê–≥–µ–Ω—Ç—ã —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω—ã', 'success');
        } catch (e) { Logger.log(`‚ùå –û—à–∏–±–∫–∞ —ç–∫—Å–ø–æ—Ä—Ç–∞: ${e.message}`, 'error'); }
    }
    
    importWeights(e) {
        const file = e.target.files?.[0];
        if (!file) return;
        if (file.size > 10 * 1024 * 1024) { Logger.log('‚ùå –§–∞–π–ª —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π (–º–∞–∫—Å. 10MB)', 'error'); e.target.value = ''; return; }
        const reader = new FileReader();
        reader.onload = (ev) => {
            try {
                const result = ev.target?.result;
                if (typeof result !== 'string') throw new Error('Invalid file content');
                const data = JSON.parse(result);
                if (!data.version) throw new Error('Missing version field');
                if (data.version !== '5.0') throw new Error('–¢—Ä–µ–±—É–µ—Ç—Å—è —Ñ–æ—Ä–º–∞—Ç v5.0');
                if (!data.agents || !Array.isArray(data.agents)) throw new Error('Missing or invalid agents array');
                if (!data.settings || typeof data.settings !== 'object') throw new Error('Missing or invalid settings');
                if (!data.world || typeof data.world !== 'object') throw new Error('Missing or invalid world data');
                this.config.GAME.currentMode = data.mode || '1v1';
                document.getElementById('gameModeSelect').value = this.config.GAME.currentMode;
                this.world.enemies = data.agents?.map((a, i) => a ? Agent.fromJSON(a, this.config?.GAME?.teamColors?.[a.teamId] || '#fff', this.config) : null).filter(a => a) || [];
                this.world.enemies.forEach(a => {
                    if (!a) return;
                    a.net.lr = this.settings.learningRate;
                    a.net.lambda = this.settings.lambda;
                    a.net.gamma = this.settings.gamma;
                    a.net.policyTemp = this.settings.policyTemperature;
                    if (a.critic) a.critic.lr = this.settings.learningRate;
                    if (a.policySelector) a.policySelector.lr = this.settings.learningRate * 0.6;
                    if (a.teamId) a.updateAllies(this.world);
                });
                Logger.log('üì• –ê–≥–µ–Ω—Ç—ã –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω—ã', 'success');
            } catch (err) { Logger.log(`‚ùå –û—à–∏–±–∫–∞ –∏–º–ø–æ—Ä—Ç–∞: ${err.message}`, 'error'); }
            finally { e.target.value = ''; }
        };
        reader.readAsText(file);
    }
    
    // ‚úÖ PATCH: Enhanced destroy() with proper cleanup
    destroy() {
        console.log('üóëÔ∏è GameEngine.destroy() called');
        
        // ‚úÖ Cancel animation frame
        if (this.rafId) {
            cancelAnimationFrame(this.rafId);            this.rafId = null;
            console.log('‚èπÔ∏è Animation frame cancelled');
        }
        
        // ‚úÖ Stop running state
        this.running = false;
        
        // ‚úÖ Remove global event listeners
        window.removeEventListener('resize', this._onResize);
        document.removeEventListener('keydown', this._onKey);
        
        // ‚úÖ Remove canvas event listeners
        if (this.canvas) {
            this.canvas.removeEventListener('click', this._onClick);
            this.canvas.removeEventListener('touchend', this._onClick);
            this.canvas.removeEventListener('touchstart', this._onTouchStart);
            
            // ‚úÖ Clear canvas
            const ctx = this.canvas.getContext('2d');
            if (ctx) {
                ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            }
        }
        
        // ‚úÖ Cleanup button listeners
        const cleanupBtn = (id) => {
            const btn = document.getElementById(id);
            if (btn) {
                const newBtn = btn.cloneNode(true);
                btn.parentNode.replaceChild(newBtn, btn);
            }
        };
        
        cleanupBtn('btnStart');
        cleanupBtn('btnReset');
        cleanupBtn('btnSave');
        cleanupBtn('btnLoad');
        cleanupBtn('btnExport');
        cleanupBtn('btnDebug');
        cleanupBtn('btnVision');
        cleanupBtn('btnApplyWeapons');
        cleanupBtn('btnRandomWeapons');
        
        const fileImport = document.getElementById('fileImport');
        if (fileImport) {
            const newFileImport = fileImport.cloneNode(true);
            fileImport.parentNode.replaceChild(newFileImport, fileImport);
        }
        
        const modeSelect = document.getElementById('gameModeSelect');        if (modeSelect) {
            const newModeSelect = modeSelect.cloneNode(true);
            modeSelect.parentNode.replaceChild(newModeSelect, modeSelect);
        }
        
        console.log('‚úÖ GameEngine.destroy() completed');
    }
    
    applyWeapons() {
        const mode = this.config?.GAME?.currentMode || '1v1';
        const maxAgents = this.config?.GAME?.maxAgents?.[mode] || 2;
        for (let i = 0; i < maxAgents; i++) {
            const agent = this.world.enemies[i];
            const select = document.getElementById(`${agent?.id}-weapon-select`);
            if (agent && select) {
                agent.setWeapon(select.value);
                Logger.log(`${agent.id.toUpperCase()} weapon: ${WEAPONS[select.value].icon} ${WEAPONS[select.value].name}`, 'success');
            }
        }
        this.updateStats();
    }
    
    randomWeapons() {
        const mode = this.config?.GAME?.currentMode || '1v1';
        const maxAgents = this.config?.GAME?.maxAgents?.[mode] || 2;
        const weaponTypes = Object.keys(WEAPONS);
        for (let i = 0; i < maxAgents; i++) {
            const agent = this.world.enemies[i];
            const select = document.getElementById(`${agent?.id}-weapon-select`);
            if (agent && select) {
                const w = weaponTypes[Utils.randInt(this.config._rng, 0, weaponTypes.length - 1)];
                select.value = w;
                agent.setWeapon(w);
            }
        }
        this.applyWeapons();
        Logger.log(`üé≤ Random weapons applied`, 'info');
    }
    
    showWinnerBanner(winner, type) {
        const banner = document.getElementById('winnerBanner');
        const title = document.getElementById('winnerTitle');
        const team = document.getElementById('winnerTeam');
        const text = document.getElementById('winnerText');
        const episode = document.getElementById('winnerEpisode');
        if (!banner || !title || !team || !text || !episode) return;
        
        const color = this.config?.GAME?.teamColors?.[winner] || '#fff';
        const winText = type === 'teamElimination' ? '–ö–æ–º–∞–Ω–¥–∞ —É–Ω–∏—á—Ç–æ–∂–µ–Ω–∞' : '–ü–æ—Å–ª–µ–¥–Ω–∏–π –≤—ã–∂–∏–≤—à–∏–π';
                title.textContent = `üèÜ –ü–û–ë–ï–î–ê!`;
        title.style.color = color;
        team.textContent = winner.toUpperCase();
        team.style.color = color;
        text.textContent = winText;
        episode.textContent = `–≠–ø–∏–∑–æ–¥ ${this.world.episode}`;
        banner.classList.add('active');
        
        setTimeout(() => {
            banner.classList.remove('active');
        }, 3000);
    }
}

// ============================================================================
// GLOBAL INITIALIZATION ‚Äî FIXED v5.0
// ============================================================================
(function() {
    'use strict';
    
    let initialized = false;
    let initPromise = null;
    window.arenaGame = null;
    window.arenaConfig = null;
    
    async function initArena() {
        if (initialized) {
            console.warn('‚ö†Ô∏è Arena already initialized, skipping duplicate init call');
            return initPromise;
        }
        if (initPromise) {
            return initPromise;
        }
        initialized = true;
        initPromise = (async () => {
            try {
                console.log('üîß Initializing AI Arena v5.0 Deep Cognition...');
                const seedHash = Math.floor(Math.random() * 1e9).toString(36);
                const config = Arena._mergeConfig({
                    seed: 'ARENA_V5_PRO_' + seedHash,
                    timestamp: Date.now()
                });
                
                // Initialize global config reference for compatibility
                window.arenaConfig = config;
                
                // ‚úÖ Clean up any existing game first
                if (window.arenaGame) {
                    console.log('üîÑ Cleaning up existing game instance...');
                    window.arenaGame.destroy();                    window.arenaGame = null;
                }
                
                window.arenaGame = Arena.init(config);
                if (window.arenaGame) {
                    console.log('‚úÖ AI Arena v5.0 Professional initialized successfully');
                    console.log('üîê Seed:', config.seed);
                    console.log('üéÆ Mode:', config.GAME.currentMode);
                    console.log('üß† Features: Attention+ToM+DynamicLR+MetaMemory+Empathy+Debates+Imagination');
                } else {
                    throw new Error('Arena.init() returned null');
                }
            } catch (e) {
                console.error('‚ùå Failed to initialize AI Arena:', e);
                console.error('Stack:', e.stack);
                initialized = false;
                initPromise = null;
                alert('–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏: ' + e.message);
                throw e;
            }
        })();
        return initPromise;
    }
    
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initArena, { once: true, capture: true });
    } else {
        setTimeout(initArena, 0);
    }
    
    window.addEventListener('beforeunload', () => {
        console.log('üëã Cleaning up Arena on page unload...');
        if (window.arenaGame) {
            window.arenaGame.destroy();
            window.arenaGame = null;
        }
        window.arenaConfig = null;
        initialized = false;
        initPromise = null;
    });
    
    // ‚úÖ Expose test harness for determinism verification
    window.ArenaTest = {
        runDeterminismTest: function(seed, steps = 100) {
            return Arena.testDeterminism(seed, steps);
        },
        reset: function() {
            console.log('üîÑ ArenaTest.reset() called');
            initialized = false;
            initPromise = null;            if (window.arenaGame) {
                window.arenaGame.destroy();
                window.arenaGame = null;
            }
            setTimeout(initArena, 100);
        },
        getStatus: function() {
            return {
                initialized,
                hasGame: !!window.arenaGame,
                hasConfig: !!window.arenaConfig,
                gameRunning: window.arenaGame?.running || false,
                fps: window.arenaGame?.fps || 0
            };
        }
    };
    
    console.log('üì¶ Arena v5.0 module loaded, waiting for DOM...');
    
})();
</script>
</body>
</html>
