<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline';">
    <meta name="description" content="AI Football v8.0.3 Professional ‚Äî Cortex-2 Neural Network Football Simulation">
    <meta name="theme-color" content="#0a0a15">
    <title>‚öΩ AI FOOTBALL v8.0.3 Professional</title>
    <style>
        :root {
            --bg: #0a0a15; --bg-gradient-start: #0a0a15; --bg-gradient-end: #1a1a2e;
            --panel: #121225; --panel-alpha: rgba(18, 18, 37, 0.95);
            --text: #e0e0ff; --text-dim: #b0b0d0; --text-muted: #707090;
            --primary: #00f2ff; --primary-dark: #00c4d4; --accent: #ff0066;
            --success: #00ff9d; --warning: #ffaa00; --danger: #ff4444;
            --border: #2a2a45; --border-light: #3a3a5a;
            --purple: #aa88ff; --yellow: #ffdd44; --pink: #ff66cc; --cyan: #00d4ff;
            --sidebar-width: 420px; --header-height: 48px; --panel-radius: 12px;
            --btn-radius: 8px; --input-radius: 6px; --card-radius: 10px;
            --transition-fast: 150ms ease; --transition-normal: 250ms ease;
            --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.3); --shadow-md: 0 4px 8px rgba(0, 0, 0, 0.4);
            --z-canvas: 1; --z-sidebar: 10; --z-header: 100; --z-modal: 1000;
        }
        *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }
        html { font-size: 16px; -webkit-text-size-adjust: 100%; scroll-behavior: smooth; }
        body {
            background: linear-gradient(135deg, var(--bg-gradient-start) 0%, var(--bg-gradient-end) 100%);
            color: var(--text); font-family: 'Segoe UI', system-ui, sans-serif;
            font-size: 0.875rem; line-height: 1.4; overflow: hidden; user-select: none;
            touch-action: manipulation; text-rendering: optimizeLegibility;
            -webkit-font-smoothing: antialiased;
        }
        :focus-visible { outline: 2px solid var(--primary); outline-offset: 2px; }
        button:focus-visible, input:focus-visible, select:focus-visible {
            outline: 2px solid var(--primary); outline-offset: 2px;
            box-shadow: 0 0 0 4px rgba(0, 242, 255, 0.2);
        }
        .skip-link { position: absolute; top: -40px; left: 0; background: var(--primary); color: #000; padding: 0.5rem 1rem; z-index: var(--z-modal); }
        .skip-link:focus { top: 0; }
        .container {
            display: grid; grid-template-columns: 1fr var(--sidebar-width);
            grid-template-rows: var(--header-height) 1fr; grid-template-areas: "header header" "canvas sidebar";
            height: 100vh; width: 100vw;
        }
        .header {
            grid-area: header; background: var(--panel); border-bottom: 1px solid var(--border);
            padding: 0.5rem 1rem; display: flex; justify-content: space-between; align-items: center;
            z-index: var(--z-header);
        }
        .header h1 { font-size: 1rem; font-weight: 700; color: var(--primary); display: flex; align-items: center; gap: 0.5rem; margin: 0; }
        .version-badge { background: var(--accent); color: #fff; padding: 0.125rem 0.375rem; border-radius: 0.25rem; font-size: 0.625rem; font-weight: 600; }
        .fps-counter { font-family: monospace; color: var(--success); font-weight: 700; font-size: 0.875rem; background: rgba(0, 255, 157, 0.1); padding: 0.25rem 0.5rem; border-radius: 0.375rem; min-width: 70px; text-align: center; }
        #gameCanvas { grid-area: canvas; width: 100%; height: 100%; display: block; cursor: crosshair; touch-action: none; background: #1a4a1a; }
        .sidebar {
            grid-area: sidebar; background: var(--panel); border-left: 1px solid var(--border);
            padding: 0.625rem; overflow-y: auto; display: flex; flex-direction: column; gap: 0.5rem;
            scrollbar-width: thin; scrollbar-color: var(--border) var(--bg);
        }
        .sidebar::-webkit-scrollbar { width: 0.25rem; }
        .sidebar::-webkit-scrollbar-track { background: var(--bg); }
        .sidebar::-webkit-scrollbar-thumb { background: var(--border); border-radius: 0.125rem; }
        .panel {
            background: var(--panel-alpha); border: 1px solid var(--border); border-radius: var(--panel-radius);
            padding: 0.5rem; backdrop-filter: blur(4px);
        }
        .panel-title { color: var(--primary); font-size: 0.75rem; font-weight: 700; margin-bottom: 0.375rem; display: flex; align-items: center; gap: 0.3125rem; padding-bottom: 0.25rem; border-bottom: 1px solid var(--border); text-transform: uppercase; letter-spacing: 0.5px; }
        .stat-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.25rem; }
        .stat { background: rgba(0, 0, 0, 0.2); padding: 0.25rem 0.375rem; border-radius: 0.375rem; font-size: 0.625rem; border: 1px solid transparent; }
        .stat:hover { border-color: var(--border-light); background: rgba(0, 0, 0, 0.25); }
        .stat-label { color: var(--text-dim); display: block; margin-bottom: 0.0625rem; font-size: 0.5625rem; }
        .stat-value { color: var(--primary); font-weight: 700; font-family: monospace; font-size: 0.6875rem; }
        .stat-value.good { color: var(--success); } .stat-value.bad { color: var(--danger); }
        .control-group { margin-bottom: 0.375rem; }
        .control-label { display: flex; justify-content: space-between; align-items: center; font-size: 0.6875rem; margin-bottom: 0.125rem; color: var(--text-dim); }
        input[type="range"] { width: 100%; height: 0.25rem; background: var(--border); border-radius: 0.125rem; appearance: none; cursor: pointer; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 0.75rem; height: 0.75rem; background: var(--primary); border-radius: 50%; cursor: pointer; border: 2px solid var(--bg); }
        select { width: 100%; padding: 0.375rem 0.5rem; background: rgba(0, 0, 0, 0.3); border: 1px solid var(--border); border-radius: var(--input-radius); color: var(--text); font-size: 0.6875rem; cursor: pointer; }
        .btn-group { display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.25rem; margin-top: 0.25rem; }
        .btn-group-3 { display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.25rem; margin-top: 0.25rem; }
        button {
            padding: 0.375rem 0.5rem; border: none; border-radius: var(--btn-radius); font-weight: 700;
            cursor: pointer; font-size: 0.6875rem; background: var(--border); color: var(--text);
            min-height: 2rem; transition: all var(--transition-fast); text-transform: uppercase; letter-spacing: 0.5px;
            display: flex; align-items: center; justify-content: center; gap: 0.25rem; position: relative; overflow: hidden;
        }
        button:hover:not(:disabled) { background: var(--border-light); }
        button:active { transform: translateY(1px); }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-primary { background: var(--primary); color: #000; }
        .btn-danger { background: var(--danger); color: #fff; }
        .btn-success { background: var(--success); color: #000; }
        .btn-secondary { background: var(--border); color: var(--text); }
        .btn-toggle.active { background: var(--accent); color: #fff; }
        .toggle { display: flex; align-items: center; gap: 0.25rem; font-size: 0.6875rem; margin-bottom: 0.1875rem; color: var(--text-dim); cursor: pointer; user-select: none; }
        .toggle input { accent-color: var(--primary); width: 0.875rem; height: 0.875rem; cursor: pointer; }
        .log {
            background: #000; border: 1px solid var(--border); border-radius: 0.5rem; padding: 0.375rem;
            height: 5.625rem; overflow-y: auto; font-size: 0.5625rem; font-family: monospace;
            word-break: break-word; white-space: pre-wrap;
        }
        .log-entry { margin-bottom: 0.125rem; padding-bottom: 0.125rem; border-bottom: 1px solid #111; line-height: 1.3; }
        .log-entry.info { color: var(--primary); } .log-entry.success { color: var(--success); }
        .log-entry.warn { color: var(--warning); } .log-entry.error { color: var(--danger); }
        .progress-bar { height: 0.25rem; background: rgba(0, 0, 0, 0.3); border-radius: 0.1875rem; overflow: hidden; margin-top: 0.1875rem; }
        .progress-fill { height: 100%; background: linear-gradient(90deg, var(--primary), var(--success)); transition: width var(--transition-normal); }
        .agent-card {
            display: flex; flex-direction: column; gap: 0.25rem; padding: 0.375rem;
            background: rgba(0, 0, 0, 0.2); border-radius: var(--card-radius); margin-bottom: 0.375rem;
            border-left: 3px solid transparent;
        }
        .agent-card.blue { border-left-color: var(--primary); }
        .agent-card.red { border-left-color: var(--accent); }
        .agent-header { display: flex; align-items: center; gap: 0.25rem; font-size: 0.6875rem; font-weight: 600; }
        .health-bar { height: 0.1875rem; background: rgba(0, 0, 0, 0.3); border-radius: 0.125rem; overflow: hidden; }
        .health-fill { height: 100%; background: linear-gradient(90deg, var(--success), var(--primary)); transition: width var(--transition-fast); }
        .agent-stats { display: flex; justify-content: space-between; font-size: 0.5625rem; color: var(--text-dim); flex-wrap: wrap; gap: 0.125rem; }
        .agent-stats b { color: var(--text); font-weight: 600; }
        .role-badge {
            display: inline-flex; align-items: center; gap: 0.125rem; padding: 0.0625rem 0.25rem;
            border-radius: 0.25rem; font-size: 0.5rem; font-weight: 600; margin-top: 0.125rem;
            background: rgba(0, 212, 255, 0.15); color: var(--cyan); border: 1px solid var(--cyan);
        }
        .learning-metrics { display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.1875rem; margin-top: 0.25rem; }
        .metric-item { background: rgba(0, 0, 0, 0.2); padding: 0.1875rem 0.25rem; border-radius: 0.25rem; font-size: 0.5rem; }
        .metric-label { color: var(--text-dim); display: block; font-size: 0.4375rem; }
        .metric-value { color: var(--success); font-weight: 600; font-family: monospace; }
        .learning-progress { display: flex; flex-direction: column; gap: 0.125rem; margin-top: 0.25rem; }
        .progress-row { display: flex; align-items: center; gap: 0.25rem; font-size: 0.5rem; }
        .progress-label { width: 4.375rem; color: var(--text-dim); flex-shrink: 0; }
        .progress-track { flex: 1; height: 0.1875rem; background: rgba(0, 0, 0, 0.3); border-radius: 0.125rem; overflow: hidden; }
        .progress-track.td .progress-fill { background: linear-gradient(90deg, var(--danger), var(--warning), var(--success)); }
        .debug-panel {
            background: rgba(0, 0, 0, 0.4); border: 1px solid var(--border); border-radius: 0.5rem;
            padding: 0.375rem; font-size: 0.5625rem; display: none;
        }
        .debug-panel.active { display: block; }
        .debug-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.125rem 0.25rem; }
        .debug-item { display: flex; justify-content: space-between; padding: 0.0625rem 0; }
        .debug-label { color: var(--text-dim); }
        .debug-value { color: var(--primary); font-weight: 600; font-family: monospace; }
        .separator { height: 1px; background: var(--border); margin: 0.375rem 0; }
        .match-score {
            display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.5rem;
            text-align: center; padding: 0.5rem; background: rgba(0, 0, 0, 0.3);
            border-radius: 0.5rem; margin-bottom: 0.5rem;
        }
        .score-value { font-size: 2rem; font-weight: 700; font-family: monospace; }
        .score-blue { color: var(--primary); }
        .score-red { color: var(--accent); }
        .score-time { color: var(--warning); font-size: 1.25rem; }
        input[type="file"] { display: none; }
        .professional-badge {
            background: linear-gradient(135deg, var(--purple), var(--accent));
            color: #fff; padding: 0.125rem 0.5rem; border-radius: 0.375rem;
            font-size: 0.5rem; font-weight: 700; text-transform: uppercase;
            letter-spacing: 1px; margin-left: 0.5rem;
        }
        @media (max-width: 1100px) {
            .container { grid-template-columns: 1fr !important; grid-template-rows: var(--header-height) 1fr auto !important; grid-template-areas: "header" "canvas" "sidebar" !important; }
            .sidebar { border-left: none !important; border-top: 1px solid var(--border) !important; max-height: 45vh !important; }
        }
        @media (max-width: 600px) {
            :root { --sidebar-width: 100%; }
            .header { padding: 0.375rem 0.75rem; }
            .header h1 { font-size: 0.875rem; }
            .panel { padding: 0.375rem; }
            .stat-grid { grid-template-columns: repeat(2, 1fr); }
            .btn-group, .btn-group-3 { grid-template-columns: repeat(2, 1fr); }
            .learning-metrics { grid-template-columns: repeat(2, 1fr); }
            .debug-grid { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <a href="#gameCanvas" class="skip-link">–ü–µ—Ä–µ–π—Ç–∏ –∫ —Å–∏–º—É–ª—è—Ü–∏–∏</a>
    <div class="container">
        <header class="header">
            <h1>‚öΩ AI FOOTBALL <span class="version-badge">v8.0.3 PRO</span><span class="professional-badge">PROFESSIONAL</span></h1>
            <div class="fps-counter" id="fpsCounter">FPS: 0</div>
        </header>
        <canvas id="gameCanvas"></canvas>
        <aside class="sidebar">
            <section class="panel">
                <h2 class="panel-title">üìä –°–ß–Å–¢ –ú–ê–¢–ß–ê</h2>
                <div class="match-score">
                    <div>
                        <div class="stat-label">–°–ò–ù–ò–ï</div>
                        <div class="score-value score-blue" id="scoreBlue">0</div>
                    </div>
                    <div>
                        <div class="stat-label">–í–†–ï–ú–Ø</div>
                        <div class="score-value score-time" id="matchTime">00:00</div>
                    </div>
                    <div>
                        <div class="stat-label">–ö–†–ê–°–ù–´–ï</div>
                        <div class="score-value score-red" id="scoreRed">0</div>
                    </div>
                </div>
            </section>
            <section class="panel">
                <h2 class="panel-title">‚öôÔ∏è –ù–ê–°–¢–†–û–ô–ö–ò</h2>
                <div class="control-group">
                    <label class="control-label"><span>üë• –ò–≥—Ä–æ–∫–æ–≤ –Ω–∞ –∫–æ–º–∞–Ω–¥—É</span><span id="agentCountValue">3</span></label>
                    <input type="range" id="agentCount" min="1" max="5" step="1" value="3">
                </div>
                <div class="control-group">
                    <label class="control-label"><span>üëÅÔ∏è –ó—Ä–µ–Ω–∏–µ (—Ä–∞–¥–∏—É—Å)</span><span id="viewRadiusValue">300</span></label>
                    <input type="range" id="viewRadius" min="100" max="600" step="25" value="300">
                </div>
                <div class="control-group">
                    <label class="control-label"><span>‚è±Ô∏è –î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –º–∞—Ç—á–∞ (—Å–µ–∫)</span><span id="matchDurationValue">600</span></label>
                    <input type="range" id="matchDuration" min="180" max="1200" step="60" value="600">
                </div>
                <div class="control-group">
                    <label class="control-label"><span>üéØ –§–æ—Ä–º–∞—Ü–∏—è</span></label>
                    <select id="formationSelect">
                        <option value="balanced">‚öñÔ∏è –°–±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–Ω–∞—è</option>
                        <option value="offensive">‚öîÔ∏è –ê—Ç–∞–∫—É—é—â–∞—è</option>
                        <option value="defensive">üõ°Ô∏è –ó–∞—â–∏—Ç–Ω–∞—è</option>
                    </select>
                </div>
                <div class="btn-group">
                    <button class="btn-success" id="btnApplyFormation">‚úÖ –ü—Ä–∏–º–µ–Ω–∏—Ç—å</button>
                    <button class="btn-secondary" id="btnRandomTeams">üé≤ –°–ª—É—á–∞–π–Ω—ã–µ</button>
                </div>
            </section>
            <section class="panel">
                <h2 class="panel-title">üë• –í–°–ï –ò–ì–†–û–ö–ò</h2>
                <div id="agentList"></div>
            </section>
            <section class="panel">
                <h2 class="panel-title">üìä –°–¢–ê–¢–ò–°–¢–ò–ö–ê</h2>
                <div class="stat-grid">
                    <div class="stat"><span class="stat-label">–ú–∞—Ç—á</span><span class="stat-value" id="episodeStat">1</span></div>
                    <div class="stat"><span class="stat-label">–®–∞–≥</span><span class="stat-value" id="stepStat">0</span></div>
                    <div class="stat"><span class="stat-label">–ì–æ–ª—ã</span><span class="stat-value" id="totalGoalsStat">0</span></div>
                    <div class="stat"><span class="stat-label">–ü–∞—Å—ã</span><span class="stat-value" id="totalPassesStat">0</span></div>
                </div>
                <div class="progress-bar"><div class="progress-fill" id="matchProgress" style="width: 0%"></div></div>
            </section>
            <section class="panel">
                <h2 class="panel-title">üß† –û–ë–£–ß–ï–ù–ò–ï</h2>
                <div class="control-group">
                    <label class="control-label"><span>Learning Rate</span><span id="learningRateValue">0.015</span></label>
                    <input type="range" id="learningRate" min="0.001" max="0.05" step="0.001" value="0.015">
                </div>
                <div class="control-group">
                    <label class="control-label"><span>TD Lambda</span><span id="lambdaValue">0.95</span></label>
                    <input type="range" id="lambda" min="0.8" max="0.99" step="0.01" value="0.95">
                </div>
                <div class="control-group">
                    <label class="control-label"><span>Mutation</span><span id="mutationRateValue">0.15</span></label>
                    <input type="range" id="mutationRate" min="0.05" max="0.3" step="0.01" value="0.15">
                </div>
                <div class="control-group">
                    <label class="control-label"><span>–°–∫–æ—Ä–æ—Å—Ç—å</span><span id="agentSpeedValue">10</span></label>
                    <input type="range" id="agentSpeed" min="5" max="20" step="1" value="10">
                </div>
                <div class="separator"></div>
                <label class="toggle"><input type="checkbox" id="enableTraining" checked> TD(Œª) Learning</label>
                <label class="toggle"><input type="checkbox" id="enableEvolution" checked> Evolution</label>
                <label class="toggle"><input type="checkbox" id="enablePassing" checked> –ü–∞—Å—ã</label>
                <label class="toggle"><input type="checkbox" id="enableShooting" checked> –£–¥–∞—Ä—ã</label>
                <label class="toggle"><input type="checkbox" id="enableWeightInheritance" checked> –ù–∞—Å–ª–µ–¥–æ–≤–∞–Ω–∏–µ</label>
                <label class="toggle"><input type="checkbox" id="enableTactical" checked> –¢–∞–∫—Ç–∏–∫–∞</label>
                <label class="toggle"><input type="checkbox" id="enableHebbian" checked> Hebbian</label>
                <label class="toggle"><input type="checkbox" id="enableConsolidation" checked> Consolidation</label>
                <label class="toggle"><input type="checkbox" id="enableProfessional" checked> Professional Mode</label>
            </section>
            <section class="panel">
                <h2 class="panel-title">üìà METRICS</h2>
                <div class="learning-metrics">
                    <div class="metric-item"><span class="metric-label">TD-Error</span><span class="metric-value" id="metricTDError">0.0000</span></div>
                    <div class="metric-item"><span class="metric-label">Pass Acc</span><span class="metric-value" id="metricPassAcc">0.00</span></div>
                    <div class="metric-item"><span class="metric-label">Shot Acc</span><span class="metric-value" id="metricShotAcc">0.00</span></div>
                    <div class="metric-item"><span class="metric-label">Possession</span><span class="metric-value" id="metricPossession">50%</span></div>
                </div>
                <div class="learning-progress">
                    <div class="progress-row"><span class="progress-label">TD Learning</span><div class="progress-track td"><div class="progress-fill" id="progressTD" style="width: 50%"></div></div></div>
                    <div class="progress-row"><span class="progress-label">Team Play</span><div class="progress-track"><div class="progress-fill" id="progressTeam" style="width: 50%"></div></div></div>
                </div>
            </section>
            <section class="panel">
                <h2 class="panel-title">üéÆ –£–ü–†–ê–í–õ–ï–ù–ò–ï</h2>
                <div class="btn-group">
                    <button class="btn-primary" id="btnStart">‚ñ∂ –°—Ç–∞—Ä—Ç</button>
                    <button class="btn-danger" id="btnReset">üîÑ –°–±—Ä–æ—Å</button>
                    <button class="btn-success" id="btnSave">üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
                    <button class="btn-secondary" id="btnLoad">üìÇ –ó–∞–≥—Ä—É–∑–∏—Ç—å</button>
                </div>
                <div class="btn-group-3">
                    <button class="btn-toggle" id="btnDebug">üîç Debug</button>
                    <button class="btn-toggle" id="btnVision">üëÅÔ∏è Vision</button>
                    <button class="btn-secondary" id="btnExport">üì§ –≠–∫—Å–ø–æ—Ä—Ç</button>
                </div>
                <input type="file" id="fileImport" accept=".json">
            </section>
            <section class="panel">
                <h2 class="panel-title">üìù –õ–û–ì</h2>
                <div class="log" id="eventLog"></div>
            </section>
            <section class="debug-panel" id="debugPanel">
                <h3 style="margin-bottom: 0.25rem; font-weight: 600; color: var(--primary); font-size: 0.625rem;">üîç INSPECTOR</h3>
                <div class="debug-grid" id="debugGrid"></div>
            </section>
        </aside>
    </div>

<script>
'use strict';

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// PROFESSIONAL MODE: FULL FOOTBALL SIMULATION v8.0.3 ‚Äî PATCHED
// Fixes applied per user analysis: ball possession, physics, vision, rules
// Cortex-2 architecture PRESERVED EXACTLY: P32‚ÜíA64‚ÜíM144‚ÜíC256‚ÜíS32‚ÜíD16
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

const FOOTBALL_CONFIG = Object.freeze({
    FIELD_WIDTH: 820,
    FIELD_HEIGHT: 600,
    GOAL_WIDTH: 10,
    GOAL_HEIGHT: 120,
    GOAL_Y: 300,
    BALL_RADIUS: 12,
    BALL_FRICTION: 0.97,
    BALL_MAX_VELOCITY: 20,
    KICK_POWER: 15,
    PASS_POWER: 10,
    SHOT_ACCURACY_BASE: 0.7,
    PASS_ACCURACY_BASE: 0.8,
    PLAYER_RADIUS: 22,
    STAMINA_DRAIN: 0.001,
    STAMINA_REGEN: 0.0005,
    FORMATIONS: {
        balanced: ['midfielder', 'defender', 'forward'],
        offensive: ['forward', 'forward', 'midfielder'],
        defensive: ['defender', 'defender', 'midfielder']
    },
    ROLES: {
        goalkeeper: { defense: 0.95, offense: 0.05, positioning: 0.95, kickPower: 1.0, accuracy: 0.7 },
        defender: { defense: 0.8, offense: 0.2, positioning: 0.85, kickPower: 0.8, accuracy: 0.75 },
        midfielder: { defense: 0.5, offense: 0.5, positioning: 0.7, kickPower: 0.9, accuracy: 0.8 },
        forward: { defense: 0.2, offense: 0.9, positioning: 0.6, kickPower: 1.0, accuracy: 0.85 }
    }
});

const FOOTBALL_ROLES = Object.freeze({
    goalkeeper: {
        id: 0,
        zone: { x: [0, 80], y: [240, 360] },
        priority: { defense: 1.0, offense: 0.05, support: 0.1 },
        behavior: {
            maxDistanceFromGoal: 60,
            interceptShotThreshold: 0.7,
            distributionMode: 'quick_throw',
            panicModeHP: 0.3
        },
        outputMask: {
            D0: 0.3, D1: 1.0, D2: 0.9, D3: 0.2,
            D4: 0.8, D5: 1.0, D6: 1.0, D7: 0.9,
            D8: 0.5, D9: 0.7, D10: 0.9, D11: 1.0,
            D12: 0.1, D13: 0.3, D14: 0.2, D15: 0.9
        }
    },
    defender: {
        id: 1,
        zone: { x: [0, 300], y: [0, 600] },
        priority: { defense: 0.9, offense: 0.15, support: 0.4 },
        behavior: {
            markTightRadius: 45,
            interceptPassRadius: 80,
            clearBallPower: 12,
            supportAttackMaxX: 400,
            tackleAggression: 0.7
        },
        outputMask: {
            D0: 0.5, D1: 0.9, D2: 0.6, D3: 0.7,
            D4: 0.7, D5: 0.9, D6: 1.0, D7: 0.8,
            D8: 0.6, D9: 0.6, D10: 0.7, D11: 0.9,
            D12: 0.3, D13: 0.5, D14: 0.6, D15: 0.7
        }
    },
    midfielder: {
        id: 2,
        zone: { x: [200, 620], y: [0, 600] },
        priority: { defense: 0.5, offense: 0.5, support: 1.0 },
        behavior: {
            linkPlayRadius: 100,
            tempoControl: true,
            switchPlayThreshold: 0.6,
            boxEntryThreshold: 0.8,
            pressIntensity: 0.6
        },
        outputMask: {
            D0: 0.9, D1: 0.8, D2: 0.7, D3: 0.8,
            D4: 1.0, D5: 0.7, D6: 0.6, D7: 1.0,
            D8: 0.8, D9: 0.9, D10: 0.6, D11: 1.0,
            D12: 0.2, D13: 0.6, D14: 0.7, D15: 0.9
        }
    },
    forward: {
        id: 3,
        zone: { x: [400, 820], y: [0, 600] },
        priority: { defense: 0.1, offense: 1.0, support: 0.3 },
        behavior: {
            makeRunsBehind: true,
            shootFromDistance: 220,
            holdUpPlay: true,
            offsideAwareness: true,
            finishingComposure: 0.85
        },
        outputMask: {
            D0: 1.0, D1: 0.7, D2: 1.0, D3: 0.9,
            D4: 0.6, D5: 0.5, D6: 0.2, D7: 0.7,
            D8: 1.0, D9: 0.8, D10: 0.5, D11: 0.8,
            D12: 0.1, D13: 0.9, D14: 0.8, D15: 1.0
        }
    }
});

window.arenaConfig = {
    enableTraining: true, enableCritic: true, enablePolicySelector: true,
    enableEvolution: true, enableSkillEvolution: true,
    enableConsolidation: true, enablePassing: true, enableShooting: true,
    enableHebbian: true, compactInputs: false, enableWeightInheritance: true,
    enableTactical: true, enableReflexPath: true, enableProfessional: true,
    learningRate: 0.015, lambda: 0.95, gamma: 0.99, entropyCoeff: 0.01,
    mutationRate: 0.10, skillGrowthRate: 0.04, hebbianRate: 0.002,
    agentSpeed: 10, agentAcceleration: 0.3, agentFriction: 0.92,
    agentCollisionRadius: 22, agentMaxVelocity: 15,
    viewRadius: 300,
    matchDuration: 600,
    seed: 'FOOTBALL_V8_PRO_' + Date.now().toFixed(0),
    timestamp: Date.now(), version: '8.0.3-FOOTBALL-PROFESSIONAL',
    ARCH: Object.freeze({
        INPUT_DIM: 64, HIDDEN1: 48, HIDDEN2: 36, OUTPUT_DIM: 16, MEMORY_DIM: 16,
        DIM_P: 32, DIM_A: 64, DIM_M: 144, DIM_C: 256, DIM_S: 32, DIM_D: 16,
        DIM_SENSOR: 64, NUM_HEADS: 4, HEAD_DIM: 16,
        M_WORK_START: 0, M_WORK_END: 48, M_PERM_START: 48, M_PERM_END: 96, M_PRED_START: 96, M_PRED_END: 144,
        LOGICAL_WIDTH: 820, LOGICAL_HEIGHT: 600,
        CRITIC_HIDDEN: 32, POLICY_CONTEXT_DIM: 8, POLICY_SKILL_DIM: 5, POLICY_HIDDEN: 24, POLICY_MODES: 5
    }),
    PHYSICS: Object.freeze({
        AGENT_COLLISION_RADIUS: 22, AGENT_REPULSION_STRENGTH: 2.5,
        MAX_VELOCITY: 25, VELOCITY_DAMPING: 0.88,
        KNOCKBACK_MASS: 1.0, FRICTION_GROUND: 0.92,
        COLLISION_ELASTICITY: 0.5
    }),
    EVOLUTION: Object.freeze({
        WIN_BONUS: 200, COMBAT_SKILL_GROWTH: 0.05
    }),
    EMOTION: Object.freeze({
        DECAY_RATE: 0.98, MOMENTUM_WEIGHT: 0.3, COMMITMENT_MIN_FRAMES: 60,
        SATISFACTION_THRESHOLD: 0.6, GRUDGE_DECAY: 0.995, TRAUMA_DECAY: 0.99, INFLUENCE_WEIGHT: 0.35
    }),
    CORTEX: Object.freeze({
        DIM_P: 32, DIM_A: 64, DIM_M: 144, DIM_C: 256, DIM_S: 32, DIM_D: 16,
        DIM_SENSOR: 64, NUM_HEADS: 4, HEAD_DIM: 16,
        M_WORK_START: 0, M_WORK_END: 48, M_PERM_START: 48, M_PERM_END: 96, M_PRED_START: 96, M_PRED_END: 144
    })
};

const Utils = Object.freeze({
    clamp: (v, min, max) => Math.max(min, Math.min(max, v)),
    lerp: (a, b, t) => a + (b - a) * Utils.clamp(t, 0, 1),
    dist: (a, b) => Math.hypot((a?.x ?? 0) - (b?.x ?? 0), (a?.y ?? 0) - (b?.y ?? 0)),
    
    normalize: (x, y) => {
        const lenSq = x*x + y*y;
        if (lenSq === 0) return { x: 0, y: 0 };
        const invLen = 1 / Math.sqrt(lenSq);
        return { x: x * invLen, y: y * invLen };
    },
    
    tanh: (x) => { if (x > 20) return 1; if (x < -20) return -1; const e = Math.exp(2 * x); return (e - 1) / (e + 1); },
    sigmoid: (x) => { if (x > 20) return 1; if (x < -20) return 0; return 1 / (1 + Math.exp(-x)); },
    leakyRelu: (x, Œ± = 0.01) => x > 0 ? x : Œ± * x,
    argmax: (arr) => { if (!arr || arr.length === 0) return -1; let mi = 0; for (let i = 1; i < arr.length; i++) { if (arr[i] > arr[mi]) mi = i; } return mi; },
    rand: (min, max) => Math.random() * (max - min) + min,
    randInt: (min, max) => Math.floor(Math.random() * (max - min + 1)) + min,
    safeNumber: (val, fallback = 0) => (typeof val === 'number' && isFinite(val)) ? val : fallback,
    
    softmax: (arr, temp = 1) => {
        if (!arr || !Array.isArray(arr) || arr.length === 0) return [];
        const max = Math.max(...arr);
        const exps = arr.map(v => { const scaled = (v - max) / temp; return scaled > 700 ? 0 : Math.exp(Math.min(scaled, 700)); });
        const sum = exps.reduce((s, x) => s + x, 0) || 1e-10;
        return exps.map(e => e / sum);
    },
    
    logSoftmax: (arr, temp = 1) => {
        if (!arr || !Array.isArray(arr) || arr.length === 0) return [];
        const max = Math.max(...arr);
        const logSumExp = max + Math.log(arr.reduce((s, x) => { const scaled = (x - max) / temp; return s + (scaled > 700 ? 0 : Math.exp(Math.min(scaled, 700))); }, 0) + 1e-10);
        return arr.map(v => ((v - max) / temp - logSumExp));
    },
    
    computeGAE: (rewards, values, nextValue, gamma = 0.99, lambda = 0.95) => {
        const advantages = new Array(rewards.length);
        let advantage = 0;
        for (let t = rewards.length - 1; t >= 0; t--) {
            const nextVal = (t === rewards.length - 1) ? nextValue : values[t + 1];
            const delta = Utils.safeNumber(rewards[t], 0) + gamma * Utils.safeNumber(nextVal, 0) - Utils.safeNumber(values[t], 0);
            advantage = delta + gamma * lambda * advantage;
            advantages[t] = advantage;
        }
        return advantages;
    },
    
    tdError: (reward, value, nextValue, gamma = 0.99) => Utils.safeNumber(reward, 0) + gamma * Utils.safeNumber(nextValue, 0) - Utils.safeNumber(value, 0),
    
    _pointSegDist: (ax, ay, bx, by, cx, cy) => {
        const vx = bx - ax, vy = by - ay; const wx = cx - ax, wy = cy - ay; const c1 = vx * wx + vy * wy;
        if (c1 <= 0) return Math.hypot(cx - ax, cy - ay);
        const c2 = vx * vx + vy * vy;
        if (c2 <= c1) return Math.hypot(cx - bx, cy - by);
        const b = c1 / c2; const pbx = ax + b * vx, pby = ay + b * vy;
        return Math.hypot(cx - pbx, cy - pby);
    },
    
    hasLineOfSight: (a, b, walls, wallRadius = 14) => {
        if (!a || !b) return false; if (!walls?.length) return true;
        for (const w of walls) { if (!w) continue; const d = Utils._pointSegDist(a.x, a.y, b.x, b.y, w.x, w.y); if (d < wallRadius + 2) return false; }
        return true;
    },
    
    hashSeed: (seed, i, j) => {
        if (!seed) seed = 'default';
        let h = String(seed).split('').reduce((a, c, idx) => { return ((a * 31 + c.charCodeAt(0)) ^ (idx * 17 + i * 7919 + j * 104729)) % 2147483647; }, String(seed).length) || 12345;
        h = (h * 2654435761) >>> 0; return h / 4294967296;
    },
    
    // FIX: Added missing randGaussian method
    randGaussian: (mean = 0, std = 1) => {
        let u = 0, v = 0;
        while (u === 0) u = Math.random();
        while (v === 0) v = Math.random();
        const z = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
        return mean + z * std;
    },
    
    deepClone: (obj) => {
        if (obj === null || typeof obj !== 'object') return obj;
        if (obj instanceof Float32Array) return new Float32Array(obj);
        if (Array.isArray(obj)) return obj.map(Utils.deepClone);
        const clone = {}; for (const key of Object.keys(obj)) { clone[key] = Utils.deepClone(obj[key]); }
        return clone;
    },
    
    normalizeAngle: (angle) => { while (angle > Math.PI) angle -= Math.PI * 2; while (angle < -Math.PI) angle += Math.PI * 2; return angle; },
    
    matrixMultiply: (vec, mat, activation = 'linear') => {
        if (!vec?.length || !mat?.length || !mat[0]?.length) return new Float32Array(0);
        const out = new Float32Array(mat[0].length);
        for (let i = 0; i < mat[0].length; i++) {
            let sum = 0; for (let j = 0; j < vec.length; j++) { sum += Utils.safeNumber(vec[j], 0) * Utils.safeNumber(mat[j]?.[i], 0); }
            switch (activation) { case 'tanh': out[i] = Utils.tanh(sum); break; case 'relu': out[i] = Utils.leakyRelu(sum); break; case 'linear': default: out[i] = sum; break; }
        }
        return out;
    },
    
    projectToCortexSensors: (rawInputs, config) => {
        const output = new Float32Array(config.DIM_SENSOR); const src = rawInputs || []; const srcLen = Math.min(src.length, config.DIM_SENSOR);
        for (let i = 0; i < srcLen; i++) { output[i] = Utils.clamp(Utils.safeNumber(src[i], 0), -1, 1); }
        const seed = config?.seed || arenaConfig?.seed || 'CORTEX2_DEFAULT';
        for (let i = srcLen; i < config.DIM_SENSOR; i++) { const hash = Utils.hashSeed(seed, i, 0xDEADBEEF); output[i] = (hash * 2 - 1) * 0.05; }
        return output;
    },
    
    cloneTensor: (tensor) => {
        if (tensor instanceof Float32Array) return new Float32Array(tensor);
        if (Array.isArray(tensor)) {
            return tensor[0] instanceof Float32Array
                ? tensor.map(row => new Float32Array(row))
                : tensor.map(Utils.cloneTensor);
        }
        return tensor;
    },
    
    validateTensor: (tensor, name = 'tensor') => {
        if (!tensor?.length) return false;
        for (let i = 0; i < Math.min(100, tensor.length); i++) {
            const v = tensor[i];
            if (!isFinite(v)) {
                console.warn(`‚ö†Ô∏è Invalid ${name}[${i}]: ${v}`);
                return false;
            }
        }
        return true;
    }
});

class SeededRNG {
    constructor(seed) {
        this._baseSeed = String(seed || 'default').split('').reduce((a, c, i) => {
            return ((a * 31 + c.charCodeAt(0)) ^ (i * 17)) % 2147483647;
        }, String(seed || 'default').length) || 12345;
        this._state = this._baseSeed;
        this._callCount = 0;
    }
    next() {
        let x = this._state;
        x ^= x << 13;
        x ^= x >>> 17;
        x ^= x << 5;
        this._state = x >>> 0;
        this._callCount++;
        return (x * 0x2545F4914F6CDD1D) >>> 0 / 4294967296;
    }
    deriveWeights(rows, cols, scale) {
        const weights = [];
        for (let i = 0; i < rows; i++) {
            const row = new Float32Array(cols);
            for (let j = 0; j < cols; j++) {
                const hash = Utils.hashSeed(String(this._baseSeed), i * 1000 + j, 0);
                row[j] = (hash * 2 - 1) * scale;
            }
            weights.push(row);
        }
        return weights;
    }
    deriveVector(length, scale) {
        const vec = new Float32Array(length);
        for (let i = 0; i < length; i++) {
            const hash = Utils.hashSeed(String(this._baseSeed), i, 1000);
            vec[i] = (hash * 2 - 1) * scale;
        }
        return vec;
    }
}

class BallPredictor {
    constructor(config = {}) {
        this.friction = config.friction ?? FOOTBALL_CONFIG.BALL_FRICTION;
        this.maxSteps = config.maxSteps ?? 60;
        this.bounceDamping = config.bounceDamping ?? 0.7;
    }
    
    predictTrajectory(startX, startY, startVx, startVy, world) {
        const trajectory = [];
        let x = startX, y = startY, vx = startVx, vy = startVy;
        
        const goalTop = FOOTBALL_CONFIG.GOAL_Y - FOOTBALL_CONFIG.GOAL_HEIGHT / 2;
        const goalBottom = FOOTBALL_CONFIG.GOAL_Y + FOOTBALL_CONFIG.GOAL_HEIGHT / 2;
        
        for (let t = 0; t < this.maxSteps; t++) {
            trajectory.push({ x, y, vx, vy, t });
            
            vx *= this.friction;
            vy *= this.friction;
            
            if (Math.hypot(vx, vy) < 0.1) {
                for (let rest = t + 1; rest < this.maxSteps; rest++) {
                    trajectory.push({ x, y, vx: 0, vy: 0, t: rest });
                }
                break;
            }
            
            x += vx;
            y += vy;
            
            if (y < FOOTBALL_CONFIG.BALL_RADIUS + 10 || y > FOOTBALL_CONFIG.FIELD_HEIGHT - FOOTBALL_CONFIG.BALL_RADIUS - 10) {
                vy *= -this.bounceDamping;
                y = Utils.clamp(y, FOOTBALL_CONFIG.BALL_RADIUS + 10, FOOTBALL_CONFIG.FIELD_HEIGHT - FOOTBALL_CONFIG.BALL_RADIUS - 10);
            }
            
            if (x < FOOTBALL_CONFIG.BALL_RADIUS + 10) {
                if (y < goalTop || y > goalBottom) {
                    vx *= -this.bounceDamping;
                    x = FOOTBALL_CONFIG.BALL_RADIUS + 10;
                }
            }
            if (x > FOOTBALL_CONFIG.FIELD_WIDTH - FOOTBALL_CONFIG.BALL_RADIUS - 10) {
                if (y < goalTop || y > goalBottom) {
                    vx *= -this.bounceDamping;
                    x = FOOTBALL_CONFIG.FIELD_WIDTH - FOOTBALL_CONFIG.BALL_RADIUS - 10;
                }
            }
        }
        return trajectory;
    }
    
    calculateIntercept(agent, ball, world) {
        const trajectory = this.predictTrajectory(ball.x, ball.y, ball.vx, ball.vy, world);
        const agentSpeed = arenaConfig.agentSpeed * (agent._sprintActive ? 1.5 : 1);
        
        let bestIntercept = null;
        let minTotalTime = Infinity;
        
        for (const point of trajectory) {
            const distToAgent = Utils.dist(agent, point);
            const timeToReach = distToAgent / agentSpeed;
            const totalTime = point.t + timeToReach;
            
            if (timeToReach <= point.t + 5 && distToAgent < 300) {
                if (totalTime < minTotalTime) {
                    minTotalTime = totalTime;
                    bestIntercept = {
                        x: point.x, y: point.y, t: point.t, feasible: true,
                        distance: distToAgent, ballSpeedAtPoint: Math.hypot(point.vx, point.vy)
                    };
                }
            }
        }
        
        return bestIntercept || {
            x: ball.x, y: ball.y, t: 0, feasible: false,
            distance: Utils.dist(agent, ball), ballSpeedAtPoint: Math.hypot(ball.vx, ball.vy)
        };
    }
    
    calculatePassLead(passer, receiver, world) {
        const passSpeed = FOOTBALL_CONFIG.PASS_POWER;
        
        const dx = receiver.x - passer.x;
        const dy = receiver.y - passer.y;
        const dist = Math.hypot(dx, dy);
        
        if (Math.hypot(receiver.vx, receiver.vy) < 0.5) {
            return { x: receiver.x, y: receiver.y, power: passSpeed * 0.8, confidence: 0.9 };
        }
        
        let bestLead = null;
        let minError = Infinity;
        
        for (let t = 10; t <= 60; t += 5) {
            const predictedReceiverX = receiver.x + receiver.vx * t;
            const predictedReceiverY = receiver.y + receiver.vy * t;
            
            const leadDx = predictedReceiverX - passer.x;
            const leadDy = predictedReceiverY - passer.y;
            const leadDist = Math.hypot(leadDx, leadDy);
            const flightTime = leadDist / passSpeed;
            
            const error = Math.abs(flightTime - t);
            
            if (error < minError && leadDist < 400) {
                minError = error;
                bestLead = {
                    x: predictedReceiverX, y: predictedReceiverY,
                    power: Utils.clamp(passSpeed * (0.7 + leadDist / 400 * 0.3), passSpeed * 0.7, passSpeed),
                    flightTime: flightTime, confidence: 1 - error / 20
                };
            }
        }
        
        return bestLead || { x: receiver.x, y: receiver.y, power: passSpeed * 0.8, confidence: 0.5 };
    }
}

class TeamEmotionSystem {
    constructor(teamId) {
        this.teamId = teamId;
        this.morale = 0.5;
        this.coherence = 0.7;
        this.pressure = 0.3;
        this._history = [];
        this._maxHistory = 30;
    }
    
    update(events, world) {
        for (const event of events) {
            switch(event.type) {
                case 'goal_scored':
                    if (event.team === this.teamId) {
                        this.morale = Utils.clamp(this.morale + 0.15, 0, 1);
                        this.coherence = Utils.clamp(this.coherence + 0.1, 0, 1);
                        this.pressure = Utils.clamp(this.pressure - 0.1, 0, 1);
                    } else {
                        this.morale = Utils.clamp(this.morale - 0.1, 0, 1);
                        this.pressure = Utils.clamp(this.pressure + 0.15, 0, 1);
                    }
                    break;
                case 'successful_pass':
                    if (event.team === this.teamId) {
                        this.coherence = Utils.clamp(this.coherence + 0.03, 0, 1);
                    }
                    break;
                case 'possession_lost':
                    if (event.team === this.teamId) {
                        this.pressure = Utils.clamp(this.pressure + 0.05, 0, 1);
                    }
                    break;
                case 'tackle_won':
                    if (event.team === this.teamId) {
                        this.morale = Utils.clamp(this.morale + 0.05, 0, 1);
                    }
                    break;
            }
        }
        
        this.morale = Utils.lerp(this.morale, 0.5, 0.002);
        this.coherence = Utils.lerp(this.coherence, 0.7, 0.001);
        this.pressure = Utils.lerp(this.pressure, 0.3, 0.003);
        
        this._history.push({ morale: this.morale, coherence: this.coherence, pressure: this.pressure, step: world.step });
        if (this._history.length > this._maxHistory) this._history.shift();
    }
    
    getBehaviorModifiers(agent, localEmotions) {
        const blended = {
            confidence: Utils.lerp(localEmotions.confidence, this.morale, arenaConfig.EMOTION.INFLUENCE_WEIGHT),
            aggression: Utils.lerp(localEmotions.aggression, 1 - this.pressure, 0.3),
            caution: Utils.lerp(localEmotions.caution, this.pressure, 0.4),
            coordination: this.coherence
        };
        
        const role = FOOTBALL_ROLES[agent.role];
        
        return {
            outputMultipliers: {
                D0: Utils.lerp(1, 1.2, blended.confidence * (role?.outputMask?.D0 ?? 1)),
                D2: Utils.lerp(1, 1.3, blended.aggression * (role?.outputMask?.D2 ?? 1)),
                D4: Utils.lerp(1, 1.15, blended.coordination * (role?.outputMask?.D4 ?? 1)),
                D6: Utils.lerp(1, 1.4, blended.caution * (role?.outputMask?.D6 ?? 1)),
                D8: blended.confidence,
                D11: Utils.lerp(1, 1.3, 1 - blended.confidence)
            },
            positioningAggression: Utils.lerp(0.5, 1, blended.confidence),
            riskTolerance: blended.confidence * 0.7 + (1 - blended.caution) * 0.3,
            teamSupportRadius: Utils.lerp(150, 80, blended.coordination),
            pressingIntensity: Utils.clamp(blended.aggression * this.pressure * 1.5, 0, 1)
        };
    }
    
    propagateEmotions(agents) {
        const teamAgents = agents.filter(a => a.team === this.teamId && a.alive);
        if (teamAgents.length < 2) return;
        
        const avgEmotions = {
            confidence: teamAgents.reduce((s, a) => s + (a.net?.emotions?.confidence || 0), 0) / teamAgents.length,
            aggression: teamAgents.reduce((s, a) => s + (a.net?.emotions?.aggression || 0), 0) / teamAgents.length,
            frustration: teamAgents.reduce((s, a) => s + (a.net?.emotions?.frustration || 0), 0) / teamAgents.length
        };
        
        for (const agent of teamAgents) {
            if (agent.net?.emotions) {
                agent.net.emotions.confidence = Utils.lerp(
                    agent.net.emotions.confidence, 
                    avgEmotions.confidence, 
                    0.02 * this.coherence
                );
                agent.net.emotions.aggression = Utils.lerp(
                    agent.net.emotions.aggression,
                    avgEmotions.aggression,
                    0.03 * this.pressure
                );
            }
        }
    }
}

class SharedMentalMap {
    constructor(teamId, fieldWidth, fieldHeight) {
        this.teamId = teamId;
        this.fieldW = fieldWidth;
        this.fieldH = fieldHeight;
        this.gridSize = 40;
        this.gridW = Math.ceil(fieldWidth / this.gridSize);
        this.gridH = Math.ceil(fieldHeight / this.gridSize);
        
        this.dangerMap = this._zeroGrid();
        this.opportunityMap = this._zeroGrid();
        this.pressureMap = this._zeroGrid();
        this.passingLanes = this._zeroGrid();
        
        this.lastUpdate = 0;
        this.updateInterval = 10;
    }
    
    _zeroGrid() {
        return Array.from({ length: this.gridW }, () => new Float32Array(this.gridH).fill(0));
    }
    
    update(world) {
        if (world.step - this.lastUpdate < this.updateInterval) return;
        this.lastUpdate = world.step;
        
        this.dangerMap = this._zeroGrid();
        this.opportunityMap = this._zeroGrid();
        this.pressureMap = this._zeroGrid();
        this.passingLanes = this._zeroGrid();
        
        const teammates = world.agents.filter(a => a.team === this.teamId && a.alive);
        const opponents = world.agents.filter(a => a.team !== this.teamId && a.alive);
        const ball = world.ball;
        
        for (const opp of opponents) {
            this._addToGrid(this.dangerMap, opp.x, opp.y, 1.0, 2);
        }
        
        const enemyGoalX = this.teamId === 'blue' ? this.fieldW : 0;
        for (let gx = 0; gx < this.gridW; gx++) {
            for (let gy = 0; gy < this.gridH; gy++) {
                const worldX = gx * this.gridSize + this.gridSize / 2;
                const worldY = gy * this.gridSize + this.gridSize / 2;
                
                const danger = this._sampleGrid(this.dangerMap, gx, gy);
                const isFree = danger < 0.3;
                
                const distToGoal = Math.abs(worldX - enemyGoalX);
                const goalProximity = 1 - Utils.clamp(distToGoal / 400, 0, 1);
                
                this.opportunityMap[gx][gy] = isFree ? goalProximity * 0.7 + (1 - danger) * 0.3 : 0;
            }
        }
        
        for (const tm of teammates) {
            let nearestOpp = null, minDist = Infinity;
            for (const opp of opponents) {
                const d = Utils.dist(tm, opp);
                if (d < minDist) { minDist = d; nearestOpp = opp; }
            }
            if (nearestOpp && minDist < 80) {
                const midX = (tm.x + nearestOpp.x) / 2;
                const midY = (tm.y + nearestOpp.y) / 2;
                this._addToGrid(this.pressureMap, midX, midY, 1 - minDist / 80, 1);
            }
        }
        
        if (ball?.owner) {
            const owner = world.agents.find(a => a.id === ball.owner);
            if (owner) {
                for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 8) {
                    this._tracePassingLane(owner.x, owner.y, angle, opponents);
                }
            }
        }
        
        this._blurGrid(this.opportunityMap, 1);
        this._blurGrid(this.pressureMap, 1);
    }
    
    _addToGrid(grid, worldX, worldY, value, radiusCells) {
        const gx = Math.floor(worldX / this.gridSize);
        const gy = Math.floor(worldY / this.gridSize);
        
        for (let dx = -radiusCells; dx <= radiusCells; dx++) {
            for (let dy = -radiusCells; dy <= radiusCells; dy++) {
                const nx = gx + dx, ny = gy + dy;
                if (nx >= 0 && nx < this.gridW && ny >= 0 && ny < this.gridH) {
                    const dist = Math.hypot(dx, dy);
                    const falloff = Math.max(0, 1 - dist / (radiusCells + 1));
                    grid[nx][ny] = Math.max(grid[nx][ny], value * falloff);
                }
            }
        }
    }
    
    _sampleGrid(grid, gx, gy) {
        if (gx < 0 || gx >= this.gridW || gy < 0 || gy >= this.gridH) return 0;
        return grid[gx][gy];
    }
    
    _blurGrid(grid, passes) {
        for (let p = 0; p < passes; p++) {
            const newGrid = this._zeroGrid();
            for (let x = 0; x < this.gridW; x++) {
                for (let y = 0; y < this.gridH; y++) {
                    let sum = 0, count = 0;
                    for (let dx = -1; dx <= 1; dx++) {
                        for (let dy = -1; dy <= 1; dy++) {
                            const nx = x + dx, ny = y + dy;
                            if (nx >= 0 && nx < this.gridW && ny >= 0 && ny < this.gridH) {
                                sum += grid[nx][ny];
                                count++;
                            }
                        }
                    }
                    newGrid[x][y] = sum / count;
                }
            }
            for (let x = 0; x < this.gridW; x++) {
                for (let y = 0; y < this.gridH; y++) {
                    grid[x][y] = newGrid[x][y];
                }
            }
        }
    }
    
    _tracePassingLane(startX, startY, angle, opponents) {
        const step = 10;
        const maxDist = 400;
        let x = startX, y = startY;
        
        for (let d = 0; d < maxDist; d += step) {
            x += Math.cos(angle) * step;
            y += Math.sin(angle) * step;
            
            if (x < 0 || x > this.fieldW || y < 0 || y > this.fieldH) break;
            
            const gx = Math.floor(x / this.gridSize);
            const gy = Math.floor(y / this.gridSize);
            
            let blocked = false;
            for (const opp of opponents) {
                const distToLine = Utils._pointSegDist(startX, startY, x, y, opp.x, opp.y);
                if (distToLine < 30) {
                    blocked = true;
                    break;
                }
            }
            
            if (!blocked) {
                this.passingLanes[gx][gy] = Math.max(this.passingLanes[gx][gy], 1 - d / maxDist);
            } else {
                break;
            }
        }
    }
    
    evaluatePosition(worldX, worldY, agentRole) {
        const gx = Math.floor(worldX / this.gridSize);
        const gy = Math.floor(worldY / this.gridSize);
        
        if (gx < 0 || gx >= this.gridW || gy < 0 || gy >= this.gridH) return -1;
        
        const role = FOOTBALL_ROLES[agentRole];
        
        let score = 0;
        
        const danger = this._sampleGrid(this.dangerMap, gx, gy);
        score -= danger * (role?.priority?.defense || 0.5) * 0.5;
        
        const opportunity = this._sampleGrid(this.opportunityMap, gx, gy);
        score += opportunity * (role?.priority?.offense || 0.5) * 0.7;
        
        const pressure = this._sampleGrid(this.pressureMap, gx, gy);
        score += pressure * (role?.priority?.support || 0.5) * 0.4;
        
        const lane = this._sampleGrid(this.passingLanes, gx, gy);
        score += lane * (role?.outputMask?.D4 || 0.5) * 0.3;
        
        if (role?.zone && (worldX < role.zone.x[0] || worldX > role.zone.x[1])) {
            score -= 0.3;
        }
        
        return Utils.clamp(score, -1, 1);
    }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// CORTEX-2 BRAIN ‚Äî PRESERVED EXACTLY, NO MODIFICATIONS
// Architecture: P32‚ÜíA64‚ÜíM144‚ÜíC256‚ÜíS32‚ÜíD16
// All weights, seeding, and learning logic unchanged
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class Cortex2Brain {
    constructor(config = {}) {
        this.DIM = arenaConfig.CORTEX;
        this.seed = config.seed ?? arenaConfig.seed;
        this._rng = new SeededRNG(this.seed);
        this.lr = config.lr ?? arenaConfig.learningRate;
        this.gamma = config.gamma ?? arenaConfig.gamma;
        this.lambda = config.lambda ?? arenaConfig.lambda;
        this.hebbianRate = config.hebbianRate ?? arenaConfig.hebbianRate;

        this.W_P = this._initMatrix(400, this.DIM.DIM_P, 0.3);
        this.b_P = this._initVector(this.DIM.DIM_P, 0.1);

        this.W_A = [];
        this.b_A = [];
        for (let h = 0; h < this.DIM.NUM_HEADS; h++) {
            this.W_A.push(this._initMatrix(160, this.DIM.HEAD_DIM, 0.3));
            this.b_A.push(this._initVector(this.DIM.HEAD_DIM, 0.1));
        }

        this.W_gate = this._initVector(this.DIM.NUM_HEADS, 0.25);
        this.W_reflex = this._initVector(4, 0.5);

        this.W_M_work = this._initMatrix(160, 48, 0.3);
        this.b_M_work = this._initVector(48, 0.1);
        this.W_M_perm = this._initMatrix(304, 48, 0.3);
        this.b_M_perm = this._initVector(48, 0.1);
        this.W_M_pred = this._initMatrix(192, 48, 0.3);
        this.b_M_pred = this._initVector(48, 0.1);

        this.W_C = this._initMatrix(289, this.DIM.DIM_C, 0.25);
        this.W_C = this._normalizeRecurrentWeights(this.W_C, 0.95);
        this.b_C = this._initVector(this.DIM.DIM_C, 0.1);

        this.W_S = this._initMatrix(128, this.DIM.DIM_S, 0.3);
        this.b_S = this._initVector(this.DIM.DIM_S, 0.1);
        this.W_D = this._initMatrix(336, this.DIM.DIM_D, 0.2);
        this.b_D = this._initVector(this.DIM.DIM_D, 0.1);

        this.W_pred = this._initMatrix(48, this.DIM.DIM_SENSOR, 0.15);
        this.b_pred = this._initVector(this.DIM.DIM_SENSOR, 0.05);

        this.W_V = this._initVector(this.DIM.DIM_C, 0.1);
        this.b_V = 0;

        this.P = new Float32Array(this.DIM.DIM_P);
        this.A = new Float32Array(this.DIM.DIM_A);
        this.M = new Float32Array(this.DIM.DIM_M);
        this.C = new Float32Array(this.DIM.DIM_C);
        this.S = new Float32Array(this.DIM.DIM_S);
        this.D = new Float32Array(this.DIM.DIM_D);

        this.P_prev = new Float32Array(this.DIM.DIM_P);
        this.A_prev = new Float32Array(this.DIM.DIM_A);
        this.M_prev = new Float32Array(this.DIM.DIM_M);
        this.C_prev = new Float32Array(this.DIM.DIM_C);
        this.S_prev = new Float32Array(this.DIM.DIM_S);
        this.D_prev = this._rng.deriveVector(this.DIM.DIM_D, 0.05);

        this._initEligibilityTraces();
        this.predictionErrors = new Float32Array(48);
        this.consolidationBuffer = [];
        this.maxBuffer = 32;

        this._stats = {
            tdErrorHistory: [],
            predictionErrorHistory: [],
            totalSteps: 0,
            avgReward: 0,
            reflexTriggers: 0,
            consolidationEvents: 0,
            gradientClips: 0
        };

        this._lastInputs = null;
        this._lastOutputs = null;
        this._activeNeurons = [];
        this._attentionHeadNorms = null;

        this.emotions = {
            threat: 0, frustration: 0, confidence: 0, aggression: 0,
            fear: 0, surprise: 0, caution: 0, desperation: 0, vengeance: 0
        };

        this.emotionHistory = [];
        this.maxHistory = 30;

        this.emotionalState = {
            current: null,
            history: [],
            satisfaction: 0,
            momentum: {
                fear: 0, aggression: 0, frustration: 0,
                desperation: 0, confidence: 0, vengeance: 0
            }
        };

        this.emotionMemory = {
            trauma: 0, grudge: new Map(), lastEmotion: null,
            unresolved: 0, killer: null
        };

        this.emotionConfig = {
            fear: { baseDuration: 180, intensityMultiplier: 2.0, satisfactionDecay: 0.02 },
            aggression: { baseDuration: 120, intensityMultiplier: 1.5, satisfactionDecay: 0.03 },
            frustration: { baseDuration: 240, intensityMultiplier: 2.5, satisfactionDecay: 0.01 },
            desperation: { baseDuration: 300, intensityMultiplier: 3.0, satisfactionDecay: 0.005 },
            confidence: { baseDuration: 150, intensityMultiplier: 1.2, satisfactionDecay: 0.04 },
            vengeance: { baseDuration: 360, intensityMultiplier: 3.5, satisfactionDecay: 0.003 }
        };

        this.emotionDecay = arenaConfig.EMOTION.DECAY_RATE;
        this.emotionInfluence = arenaConfig.EMOTION.INFLUENCE_WEIGHT;
        this.step = 0;
        this.cumulativeReward = 0;
        this.health = 100;
        this.stats = { maxHealth: 100 };
        this._lastKiller = null;
        
        this.predictedPos60 = { x: 0, y: 0 };
        this.predictionError60 = 0;
        this.predictedTrajectory = { angle: 0, confidence: 0 };
        
        this._lastReward = 0;
        this._prevFacingAngle = 0;
    }

    _initMatrix(rows, cols, scale) {
        const mat = [];
        for (let i = 0; i < rows; i++) {
            const row = new Float32Array(cols);
            for (let j = 0; j < cols; j++) {
                const hash = Utils.hashSeed(this.seed, i * 10000 + j, 0);
                row[j] = (hash * 2 - 1) * scale;
            }
            mat.push(row);
        }
        return mat;
    }

    _initVector(length, scale) {
        const vec = new Float32Array(length);
        for (let i = 0; i < length; i++) {
            const hash = Utils.hashSeed(this.seed, i, 1000);
            vec[i] = (hash * 2 - 1) * scale;
        }
        return vec;
    }

    _normalizeRecurrentWeights(W, target_rho = 0.95) {
        let v = new Float32Array(W[0].length).fill(1);
        for (let iter = 0; iter < 5; iter++) {
            let v_new = new Float32Array(W.length).fill(0);
            for (let i = 0; i < W.length; i++) {
                for (let j = 0; j < W[0].length; j++) {
                    v_new[i] += W[i][j] * v[j];
                }
            }
            const norm = Math.hypot(...v_new);
            if (norm < 1e-10) break;
            v = v_new.map(x => x / norm);
        }
        const Wv = new Float32Array(W.length);
        for (let i = 0; i < W.length; i++) {
            for (let j = 0; j < W[0].length; j++) {
                Wv[i] += W[i][j] * v[j];
            }
        }
        const estimated_rho = Math.hypot(...Wv);
        const factor = target_rho / (estimated_rho + 1e-8);
        for (let i = 0; i < W.length; i++) {
            for (let j = 0; j < W[0].length; j++) {
                W[i][j] *= factor;
            }
        }
        return W;
    }

    _initEligibilityTraces() {
        this.trace_P = new Float32Array(400 * this.DIM.DIM_P);
        this.trace_C = new Float32Array(289 * this.DIM.DIM_C);
        this.trace_D = new Float32Array(336 * this.DIM.DIM_D);
        this.trace_pred = new Float32Array(48 * this.DIM.DIM_SENSOR);
    }

    _estimateValue() {
        let sum = this.b_V;
        for (let i = 0; i < this.DIM.DIM_C; i++) {
            sum += this.C[i] * this.W_V[i];
        }
        return Utils.tanh(sum);
    }

    _updateValueHead(tdErr) {
        if (!arenaConfig.enableTraining) return;
        const alpha = this.lr * 0.5;
        for (let i = 0; i < this.DIM.DIM_C; i++) {
            this.W_V[i] += alpha * tdErr * this.C[i];
            this.W_V[i] = Utils.clamp(this.W_V[i], -2, 2);
        }
        this.b_V += alpha * tdErr;
    }

    _buildPInput(x_t, C_prev, S_prev, M_perm_prev) {
        const input = new Float32Array(400);
        let idx = 0;
        for (let i = 0; i < this.DIM.DIM_SENSOR; i++) input[idx++] = x_t[i];
        for (let i = 0; i < this.DIM.DIM_C; i++) input[idx++] = C_prev[i];
        for (let i = 0; i < this.DIM.DIM_S; i++) input[idx++] = S_prev[i];
        for (let i = 0; i < 48; i++) input[idx++] = M_perm_prev[i];
        return input;
    }

    _buildAInput(P_t, M_work, C_prev, D_prev, headIdx) {
        const input = new Float32Array(160);
        let idx = 0;
        for (let i = 0; i < this.DIM.DIM_P; i++) input[idx++] = P_t[i];
        for (let i = 0; i < 48; i++) input[idx++] = M_work[i];
        const cStart = headIdx * 64;
        for (let i = 0; i < 64; i++) {
            const cIdx = cStart + i;
            input[idx++] = (cIdx < this.DIM.DIM_C) ? C_prev[cIdx] : 0;
        }
        for (let i = 0; i < this.DIM.DIM_D; i++) input[idx++] = D_prev[i];
        return input;
    }

    _buildMWorkInput(P_t, A_t, C_prev) {
        const input = new Float32Array(160);
        let idx = 0;
        for (let i = 0; i < this.DIM.DIM_P; i++) input[idx++] = P_t[i];
        for (let i = 0; i < this.DIM.DIM_A; i++) input[idx++] = A_t[i];
        for (let i = 0; i < 64; i++) {
            input[idx++] = (i < this.DIM.DIM_C) ? C_prev[i] : 0;
        }
        return input;
    }

    _buildMPermInput(C_prev, M_perm_prev) {
        const input = new Float32Array(304);
        let idx = 0;
        for (let i = 0; i < this.DIM.DIM_C; i++) input[idx++] = C_prev[i];
        for (let i = 0; i < 48; i++) input[idx++] = M_perm_prev[i];
        return input;
    }

    _buildMPredInput(A_t, C_prev, M_work, D_prev) {
        const input = new Float32Array(192);
        let idx = 0;
        for (let i = 0; i < this.DIM.DIM_A; i++) input[idx++] = A_t[i];
        const C_OFFSET = this.DIM.DIM_C - 64;
        for (let i = 0; i < 64; i++) {
            const cIdx = C_OFFSET + i;
            input[idx++] = (cIdx < this.DIM.DIM_C) ? C_prev[cIdx] : 0;
        }
        for (let i = 0; i < 48; i++) input[idx++] = M_work[i];
        for (let i = 0; i < this.DIM.DIM_D; i++) input[idx++] = D_prev[i];
        return input;
    }

    _buildCInput(P_t, A_t, M_t, S_prev, D_prev, r_t) {
        const input = new Float32Array(289);
        let idx = 0;
        for (let i = 0; i < this.DIM.DIM_P; i++) input[idx++] = P_t[i];
        for (let i = 0; i < this.DIM.DIM_A; i++) input[idx++] = A_t[i];
        for (let i = 0; i < this.DIM.DIM_M; i++) input[idx++] = M_t[i];
        for (let i = 0; i < this.DIM.DIM_S; i++) input[idx++] = S_prev[i];
        for (let i = 0; i < this.DIM.DIM_D; i++) input[idx++] = D_prev[i];
        input[idx] = Utils.clamp(r_t / 50.0, -2, 2);
        return input;
    }

    _buildSInput(P_t, M_perm, C_prev, D_prev) {
        const input = new Float32Array(128);
        let idx = 0;
        for (let i = 0; i < this.DIM.DIM_P; i++) input[idx++] = P_t[i];
        for (let i = 0; i < 48; i++) input[idx++] = M_perm[i];
        for (let i = 0; i < 32; i++) {
            const cIdx = 224 + i;
            input[idx++] = (cIdx < this.DIM.DIM_C) ? C_prev[cIdx] : 0;
        }
        for (let i = 0; i < this.DIM.DIM_D; i++) input[idx++] = D_prev[i];
        return input;
    }

    _buildDInput(C_t, S_t, M_pred) {
        const input = new Float32Array(336);
        let idx = 0;
        for (let i = 0; i < this.DIM.DIM_C; i++) input[idx++] = C_t[i];
        for (let i = 0; i < this.DIM.DIM_S; i++) input[idx++] = S_t[i];
        for (let i = 0; i < 48; i++) input[idx++] = M_pred[i];
        return input;
    }

    _getMWork(M) { return M.slice(this.DIM.M_WORK_START, this.DIM.M_WORK_END); }
    _getMPerm(M) { return M.slice(this.DIM.M_PERM_START, this.DIM.M_PERM_END); }
    _getMPred(M) { return M.slice(this.DIM.M_PRED_START, this.DIM.M_PRED_END); }

    _updatePrediction(M_pred, x_t) {
        const x_pred = Utils.matrixMultiply(M_pred, this.W_pred, 'linear');
        for (let i = 0; i < this.DIM.DIM_SENSOR; i++) {
            x_pred[i] += this.b_pred[i];
        }
        
        for (let i = 0; i < 48; i++) {
            const error = Math.abs(x_pred[i] - x_t[i]);
            this.predictionErrors[i] = Utils.lerp(this.predictionErrors[i], error, 0.1);
        }
        
        if (arenaConfig.enableTraining) {
            const lr = this.lr * 0.1;
            for (let i = 0; i < 48; i++) {
                for (let j = 0; j < this.DIM.DIM_SENSOR; j++) {
                    this.W_pred[i][j] += lr * (x_t[j] - x_pred[j]) * M_pred[i];
                    this.W_pred[i][j] = Utils.clamp(this.W_pred[i][j], -2, 2);
                }
            }
        }
    }

    _computeAvgPredError() {
        let sum = 0;
        for (let i = 0; i < 48; i++) sum += this.predictionErrors[i];
        return sum / 48;
    }

    _checkReflexPath(x_t, S_new, D_new) {
        const emotionModulator = this.emotionInfluence;
        if (S_new[8] > 0.6) {
            this._stats.reflexTriggers++;
            D_new[6] = Utils.lerp(D_new[6], Math.min(1, D_new[6] + 0.4), emotionModulator);
            D_new[4] = Utils.lerp(D_new[4], Math.min(1, D_new[4] + 0.3), emotionModulator);
        }
        if (S_new[7] > 0.6) {
            this._stats.reflexTriggers++;
            D_new[6] = Utils.lerp(D_new[6], Math.min(1, D_new[6] + 0.35), emotionModulator);
            D_new[4] = Utils.lerp(D_new[4], Math.min(1, D_new[4] + 0.3), emotionModulator);
        }
    }

    _resolveCommandConflicts(D_new, emotions, mentalContext = {}) {
        const influence = this.emotionInfluence;
        if (emotions.vengeance > 0.5 || emotions.desperation > 0.5) {
            D_new[4] = Utils.lerp(D_new[4], Math.min(1, D_new[4] + 0.3), influence);
        }
        if (emotions.confidence > 0.6 && (mentalContext.alliesNearby || 0) > 1) {
            D_new[5] = Utils.lerp(D_new[5], Math.min(1, D_new[5] + 0.4), influence);
        }
        if (emotions.fear > 0.7 && (mentalContext.selfHP || 1) < 0.3) {
            D_new[6] = Utils.lerp(D_new[6], Math.min(1, D_new[6] + 0.5), influence);
            D_new[4] = Math.max(0, D_new[4] - 0.2);
        }
        if ((mentalContext.teamAdvantage || 0) > 0.7) {
            D_new[7] = Utils.lerp(D_new[7], 0.8, influence * 0.5);
        }
        if (D_new[6] > 0.7) D_new[4] = Math.min(D_new[4], 0.3);
    }

    _getDominantEmotion() {
        const emotions = [
            { name: 'vengeance', value: this.emotions.vengeance },
            { name: 'desperation', value: this.emotions.desperation },
            { name: 'fear', value: this.emotions.fear },
            { name: 'aggression', value: this.emotions.aggression },
            { name: 'frustration', value: this.emotions.frustration },
            { name: 'confidence', value: this.emotions.confidence }
        ];
        emotions.sort((a, b) => b.value - a.value);
        return { name: emotions[0].name, intensity: emotions[0].value };
    }

    _enterEmotion(name, intensity) {
        const config = this.emotionConfig[name];
        if (!config) return;
        if (this.emotionalState.current) {
            this.emotionalState.history.push({
                ...this.emotionalState.current,
                endStep: this.step,
                reason: 'transition'
            });
            if (this.emotionalState.history.length > 5) {
                this.emotionalState.history.shift();
            }
        }
        this.emotionalState.current = {
            name, intensity, initialIntensity: intensity,
            baseDuration: config.baseDuration,
            remainingFrames: Math.floor(config.baseDuration * intensity * config.intensityMultiplier),
            satisfaction: this.emotionalState.satisfaction,
            startStep: this.step
        };
    }

    _exitEmotion(state, reason = 'completed') {
        this.emotionalState.history.push({
            ...state, endStep: this.step, reason
        });
        if (this.emotionalState.history.length > 5) {
            this.emotionalState.history.shift();
        }
        this.emotionMemory.lastEmotion = {
            name: state.name, intensity: state.intensity,
            satisfaction: state.satisfaction,
            completed: reason === 'completed' || reason === 'satisfied'
        };
        if (reason === 'transition' || reason === 'interrupted') {
            this.emotionMemory.unresolved = Utils.clamp(this.emotionMemory.unresolved + state.intensity * 0.5, 0, 1);
        }
        this.emotionalState.current = null;
    }

    _canExitEmotion(state) {
        if (state.remainingFrames < state.baseDuration * 0.3) return false;
        if (state.satisfaction > 0.6) return true;
        if (state.intensity < 0.3) return true;
        return false;
    }

    _shouldExtendEmotion(state) {
        if (state.intensity > state.initialIntensity + 0.2) return true;
        if (state.satisfaction < -0.3) return true;
        return false;
    }

    _checkEmotionTransition(state) {
        const current = state.name;
        if (current === 'fear' && this.emotions.desperation > 0.7) {
            return { name: 'desperation', intensity: this.emotions.desperation };
        }
        if (current === 'frustration' && this.emotions.aggression > 0.6) {
            return { name: 'aggression', intensity: this.emotions.aggression };
        }
        if (current === 'aggression' && state.satisfaction < -0.5) {
            return { name: 'frustration', intensity: this.emotions.frustration };
        }
        if (current === 'desperation' && state.intensity < 0.4) {
            return { name: 'fear', intensity: this.emotions.fear };
        }
        if (current === 'vengeance' && state.satisfaction > 0.5) {
            return { name: 'confidence', intensity: this.emotions.confidence };
        }
        return null;
    }

    _processCombatEvents(events) {
        if (!events) return;
        for (const event of events) {
            switch(event.type) {
                case 'hit_dealt':
                    this.emotionalState.satisfaction = Utils.clamp(this.emotionalState.satisfaction + 0.15, -1, 1);
                    break;
                case 'damage_received':
                    this.emotions.fear = Math.min(1, this.emotions.fear + (event.damage || 1) * 0.02);
                    this.emotionalState.satisfaction = Utils.clamp(this.emotionalState.satisfaction - 0.2, -1, 1);
                    break;
                case 'goal_scored':
                    this.emotions.confidence = Math.min(1, this.emotions.confidence + 0.5);
                    this.emotionalState.satisfaction = Utils.clamp(this.emotionalState.satisfaction + 0.8, -1, 1);
                    break;
                case 'goal_conceded':
                    this.emotions.frustration = Math.min(1, this.emotions.frustration + 0.3);
                    this.emotionalState.satisfaction = Utils.clamp(this.emotionalState.satisfaction - 0.5, -1, 1);
                    break;
            }
        }
    }

    _updateEmotions(r_t, x_t, combatEvents = null) {
        this.step++;
        this.emotionHistory.push({ ...this.emotions, step: this.step });
        if (this.emotionHistory.length > this.maxHistory) {
            this.emotionHistory.shift();
        }
        if (combatEvents) {
            this._processCombatEvents(combatEvents);
        }
        if (this.emotionalState.current) {
            const state = this.emotionalState.current;
            const config = this.emotionConfig[state.name];
            state.remainingFrames--;
            state.satisfaction = Utils.lerp(state.satisfaction, this.emotionalState.satisfaction, 0.1);
            if (this._canExitEmotion(state)) {
                this._exitEmotion(state);
            }
            if (this._shouldExtendEmotion(state)) {
                state.remainingFrames = Math.min(state.remainingFrames + 30, config.baseDuration * 3);
            }
            const transition = this._checkEmotionTransition(state);
            if (transition) {
                this._enterEmotion(transition.name, transition.intensity);
            }
        } else {
            const dominant = this._getDominantEmotion();
            if (dominant.intensity > 0.7) {
                this._enterEmotion(dominant.name, dominant.intensity);
            }
        }
        if (r_t < 0.1) {
            this.emotions.frustration = Math.min(1, this.emotions.frustration + 0.03);
        } else {
            this.emotions.frustration *= 0.92;
        }
        const normalizedReward = Utils.clamp((this.cumulativeReward + 100) / 200, 0, 1);
        if (normalizedReward < 0.3) {
            this.emotions.desperation = Math.min(1, this.emotions.desperation + 0.05);
        } else {
            this.emotions.desperation *= 0.85;
        }
        if (r_t > 1) {
            this.emotions.confidence = Math.min(1, this.emotions.confidence + 0.05);
        } else {
            this.emotions.confidence *= 0.95;
        }
        const avgPredError = this._computeAvgPredError();
        this.emotions.surprise = avgPredError;
        const healthInput = x_t[12] ?? 0.5;
        this.emotions.caution = 1 - healthInput;
        const distanceInput = x_t[2] ?? 0.5;
        this.emotions.threat = 1 - distanceInput;
        const recentFrames = Math.min(10, this.emotionHistory.length);
        if (recentFrames > 0) {
            const recent = this.emotionHistory.slice(-recentFrames);
            this.emotionalState.momentum.fear = recent.reduce((s, e) => s + e.fear, 0) / recentFrames;
            this.emotionalState.momentum.aggression = recent.reduce((s, e) => s + e.aggression, 0) / recentFrames;
            this.emotionalState.momentum.frustration = recent.reduce((s, e) => s + e.frustration, 0) / recentFrames;
            this.emotionalState.momentum.desperation = recent.reduce((s, e) => s + e.desperation, 0) / recentFrames;
            this.emotionalState.momentum.confidence = recent.reduce((s, e) => s + e.confidence, 0) / recentFrames;
            this.emotionalState.momentum.vengeance = recent.reduce((s, e) => s + e.vengeance, 0) / recentFrames;
        }
        const fearBlock = (1 - this.emotions.desperation) * this.emotionalState.momentum.fear;
        this.emotions.aggression =
            this.emotionalState.momentum.frustration * 0.6 +
            this.emotionalState.momentum.desperation * 0.8 +
            this.emotionalState.momentum.vengeance * 0.9 -
            fearBlock * 0.4;
        this.S[0] = this.emotions.threat;
        this.S[1] = this.emotions.frustration;
        this.S[2] = this.emotions.confidence;
        this.S[3] = this.emotions.aggression;
        this.S[4] = this.emotions.fear;
        this.S[5] = this.emotions.surprise;
        this.S[6] = this.emotions.caution;
        this.S[7] = this.emotions.desperation;
        this.S[8] = this.emotions.vengeance;
        for (const key of Object.keys(this.emotions)) {
            this.emotions[key] *= this.emotionDecay;
        }
        this._lastReward = r_t;
    }

    _applyMotorConstraints(D_raw) {
        const D = new Float32Array(16);
        
        D[0] = Utils.sigmoid(D_raw[0]);
        D[1] = Utils.tanh(D_raw[1]);
        D[2] = Utils.sigmoid(D_raw[2]);
        D[3] = Utils.sigmoid(D_raw[3]);
        
        const aggression = Utils.sigmoid(D_raw[4]);
        const defense = Utils.sigmoid(D_raw[6]);
        const confidence = Utils.sigmoid(D_raw[8]);
        
        D[2] = D[2] * (0.5 + 0.5 * aggression) * (0.7 + 0.3 * confidence);
        D[0] = D[0] * (1 - 0.3 * defense);
        
        for (let i = 4; i < 16; i++) {
            D[i] = Utils.sigmoid(D_raw[i]);
        }
        
        return D;
    }

    _calculateIntrinsicReward(x_t, x_pred) {
        const novelty = Math.hypot(...Array.from(x_t).map((v, i) => v - x_pred[i])) / x_t.length;
        const curiosity_reward = novelty * Math.exp(-novelty);
        return curiosity_reward * 0.1;
    }

    _fallbackOutput() {
        return {
            output: new Array(16).fill(0),
            cortex: new Array(256).fill(0),
            predictionError: 0,
            predictionError60: 0,
            predictedPos60: { x: 0, y: 0 },
            predictedTrajectory: { angle: 0, confidence: 0 },
            reflexTriggered: false,
            emotions: { ...this.emotions },
            emotionalState: this.emotionalState.current ? { ...this.emotionalState.current } : null,
            intrinsicReward: 0
        };
    }

    forward(rawInputs, reward = 0, combatEvents = null) {
        if (!rawInputs || !Array.isArray(rawInputs) || rawInputs.length !== 64) {
            console.warn('‚ö†Ô∏è Invalid inputs to Cortex2Brain.forward');
            rawInputs = new Array(64).fill(0);
        }
        
        const safeInputs = rawInputs;
        const x_t = Utils.projectToCortexSensors(safeInputs, { DIM_SENSOR: this.DIM.DIM_SENSOR, seed: this.seed });
        const r_t = Utils.safeNumber(reward, 0);
        this._lastInputs = { x_t: Array.from(x_t), r_t };
        this.cumulativeReward = Utils.lerp(this.cumulativeReward, r_t, 0.1);
        
        const P_input = this._buildPInput(x_t, this.C_prev, this.S_prev, this._getMPerm(this.M_prev));
        const A_inputs = [];
        for (let h = 0; h < this.DIM.NUM_HEADS; h++) {
            A_inputs.push(this._buildAInput(this.P_prev, this._getMWork(this.M_prev), this.C_prev, this.D_prev, h));
        }
        const M_work_input = this._buildMWorkInput(this.P_prev, this.A_prev, this.C_prev);
        const M_perm_input = this._buildMPermInput(this.C_prev, this._getMPerm(this.M_prev));
        const M_pred_input = this._buildMPredInput(this.P_prev, this.C_prev, this._getMWork(this.M_prev), this.D_prev);
        const C_input = this._buildCInput(this.P_prev, this.A_prev, this.M_prev, this.S_prev, this.D_prev, r_t);
        const S_input = this._buildSInput(this.P_prev, this._getMPerm(this.M_prev), this.C_prev, this.D_prev);
        const D_input = this._buildDInput(this.C_prev, this.S_prev, this._getMPred(this.M_prev));
        
        const P_new = Utils.matrixMultiply(P_input, this.W_P, 'relu');
        for (let i = 0; i < this.DIM.DIM_P; i++) P_new[i] = Utils.leakyRelu(P_new[i] + this.b_P[i]);
        
        const A_new = new Float32Array(this.DIM.DIM_A);
        const gateProbs = Utils.softmax(this.W_gate, 1.0);
        for (let h = 0; h < this.DIM.NUM_HEADS; h++) {
            const headOut = Utils.matrixMultiply(A_inputs[h], this.W_A[h], 'relu');
            const gateWeight = gateProbs[h];
            for (let i = 0; i < this.DIM.HEAD_DIM; i++) {
                A_new[h * this.DIM.HEAD_DIM + i] = Utils.leakyRelu(headOut[i] + this.b_A[h][i]) * gateWeight;
            }
        }
        
        const M_work_new = Utils.matrixMultiply(M_work_input, this.W_M_work, 'relu');
        for (let i = 0; i < 48; i++) M_work_new[i] = Utils.leakyRelu(M_work_new[i] + this.b_M_work[i]);
        const M_perm_new = Utils.matrixMultiply(M_perm_input, this.W_M_perm, 'relu');
        for (let i = 0; i < 48; i++) M_perm_new[i] = Utils.leakyRelu(M_perm_new[i] + this.b_M_perm[i]);
        const M_pred_new = Utils.matrixMultiply(M_pred_input, this.W_M_pred, 'relu');
        for (let i = 0; i < 48; i++) M_pred_new[i] = Utils.leakyRelu(M_pred_new[i] + this.b_M_pred[i]);
        
        const M_new = new Float32Array(this.DIM.DIM_M);
        for (let i = 0; i < 48; i++) M_new[i] = M_work_new[i];
        for (let i = 0; i < 48; i++) M_new[48 + i] = M_perm_new[i];
        for (let i = 0; i < 48; i++) M_new[96 + i] = M_pred_new[i];
        
        const C_new = Utils.matrixMultiply(C_input, this.W_C, 'relu');
        for (let i = 0; i < this.DIM.DIM_C; i++) C_new[i] = Utils.leakyRelu(C_new[i] + this.b_C[i]);
        const S_new = Utils.matrixMultiply(S_input, this.W_S, 'relu');
        for (let i = 0; i < this.DIM.DIM_S; i++) S_new[i] = Utils.leakyRelu(S_new[i] + this.b_S[i]);
        const D_new = Utils.matrixMultiply(D_input, this.W_D, 'tanh');
        for (let i = 0; i < this.DIM.DIM_D; i++) D_new[i] = Utils.tanh(D_new[i] + this.b_D[i]);
        
        this.P_prev.set(this.P); this.A_prev.set(this.A); this.M_prev.set(this.M);
        this.C_prev.set(this.C); this.S_prev.set(this.S); this.D_prev.set(this.D);
        this.P.set(P_new); this.A.set(A_new); this.M.set(M_new);
        this.C.set(C_new); this.S.set(S_new); this.D.set(D_new);
        
        this._updatePrediction(M_pred_new, x_t);
        
        const x_pred = Utils.matrixMultiply(M_pred_new, this.W_pred, 'linear');
        for (let i = 0; i < this.DIM.DIM_SENSOR; i++) {
            x_pred[i] += this.b_pred[i];
        }
        
        const predError = this._computeAvgPredError();
        const predConfidence = 1 - Utils.clamp(predError / 0.5, 0, 1);
        D_new[8] = Utils.lerp(D_new[8], predConfidence, 0.15);
        
        this._updateEmotions(r_t, x_t, combatEvents);
        if (arenaConfig.enableReflexPath) {
            this._checkReflexPath(x_t, S_new, D_new);
            this._resolveCommandConflicts(D_new, this.emotions);
        }
        
        const D_constrained = this._applyMotorConstraints(D_new);
        
        for (let i = 0; i < D_constrained.length; i++) {
            if (!isFinite(D_constrained[i])) {
                console.warn(`‚ö†Ô∏è Invalid output[${i}]: ${D_constrained[i]}`);
                D_constrained[i] = 0;
            }
        }
        
        return {
            output: Array.from(D_constrained),
            cortex: Array.from(this.C),
            predictionError: this._computeAvgPredError(),
            predictionError60: this.predictionError60,
            predictedPos60: { ...this.predictedPos60 },
            predictedTrajectory: { ...this.predictedTrajectory },
            reflexTriggered: this.S.some(v => v > 0.9),
            emotions: { ...this.emotions },
            emotionalState: this.emotionalState.current ? { ...this.emotionalState.current } : null,
            intrinsicReward: this._calculateIntrinsicReward(x_t, x_pred)
        };
    }

    tdLearn(inputs, outputs, reward, value, nextValue, actionLogProbs = null) {
        const currentValue = value !== undefined && value !== null ? Utils.safeNumber(value, 0) : this._estimateValue();
        const nextVal = nextValue !== undefined && nextValue !== null ? Utils.safeNumber(nextValue, 0) : this._estimateValue();
        let tdErr = Utils.tdError(reward, currentValue, nextVal, this.gamma);
        
        const avgPredError = this._computeAvgPredError();
        if (avgPredError > 0.5) {
            tdErr *= 1.5;
        } else if (avgPredError < 0.2) {
            tdErr *= 0.8;
        }
        
        this._stats.tdErrorHistory.push(Math.abs(tdErr));
        if (this._stats.tdErrorHistory.length > 100) this._stats.tdErrorHistory.shift();
        this._updateValueHead(tdErr);
        this._updateEligibilityTraces(inputs, outputs, tdErr);
        this._applyTDError(tdErr, 'td');
        
        if (arenaConfig.enableTraining && actionLogProbs?.length) {
            const avgAdvantage = -actionLogProbs.reduce((a,b) => a+b, 0) / actionLogProbs.length;
            for (let h = 0; h < this.DIM.NUM_HEADS; h++) {
                this.W_gate[h] += this.lr * 0.3 * avgAdvantage * (this._attentionHeadNorms?.[h] || 0.25);
                this.W_gate[h] = Utils.clamp(this.W_gate[h], -2, 2);
            }
        }
        
        if (arenaConfig.enableConsolidation && reward > 3) this._consolidateMemories(reward);
        if (arenaConfig.enableHebbian && reward > 1) {
            const rewardMagnitude = Utils.clamp(Math.abs(reward) / 5.0, 0, 1);
            const correlation = Math.sign(reward) * (0.5 + 0.5 * rewardMagnitude);
            this._hebbianUpdate(this.P_prev, this.A_prev, correlation, 'P‚ÜíA', 'hebbian');
            this._hebbianUpdate(this.A_prev, this.C_prev, correlation, 'A‚ÜíC', 'hebbian');
            this._hebbianUpdate(this.C_prev, this.D_prev, correlation, 'C‚ÜíD', 'hebbian');
        }
        
        this._stats.totalSteps++;
        this._stats.avgReward = Utils.lerp(this._stats.avgReward, reward, 0.01);
        return {
            tdError: tdErr,
            avgTDError: this._stats.tdErrorHistory.reduce((a,b)=>a+b,0)/Math.max(1,this._stats.tdErrorHistory?.length || 1),
            avgPredictionError: this._computeAvgPredError(),
            predictionError60: this.predictionError60
        };
    }

    _updateEligibilityTraces(inputs, outputs, tdErr) {
        const decay = this.gamma * this.lambda;
        for (let i = 0; i < 400; i++) {
            for (let j = 0; j < this.DIM.DIM_P; j++) {
                const idx = i * this.DIM.DIM_P + j;
                this.trace_P[idx] = decay * this.trace_P[idx] + inputs[i] * this.P[j];
                this.trace_P[idx] = Utils.clamp(this.trace_P[idx], -10, 10);
            }
        }
        for (let i = 0; i < 289; i++) {
            for (let j = 0; j < this.DIM.DIM_C; j++) {
                const idx = i * this.DIM.DIM_C + j;
                this.trace_C[idx] = decay * this.trace_C[idx] + inputs[i] * this.C[j];
                this.trace_C[idx] = Utils.clamp(this.trace_C[idx], -10, 10);
            }
        }
        for (let i = 0; i < 336; i++) {
            for (let j = 0; j < this.DIM.DIM_D; j++) {
                const idx = i * this.DIM.DIM_D + j;
                this.trace_D[idx] = decay * this.trace_D[idx] + inputs[i] * this.D[j];
                this.trace_D[idx] = Utils.clamp(this.trace_D[idx], -10, 10);
            }
        }
    }

    _applyTDError(tdErr, errorType = 'td') {
        const alpha = this.lr * Math.sign(tdErr) * 0.1;
        const MAX_GRAD = 0.3;
        const affectedSubsystems = this._getAffectedSubsystems(errorType);
        for (const sub of affectedSubsystems) {
            const subAlpha = alpha * sub.lr;
            for (let i = sub.start; i < sub.end; i++) {
                for (let j = 0; j < 289; j++) {
                    if (this.W_C[j] && this.W_C[j][i] !== undefined) {
                        const delta = Utils.clamp(subAlpha * this.trace_C[j * this.DIM.DIM_C + i], -MAX_GRAD, MAX_GRAD);
                        this.W_C[j][i] += delta;
                        this.W_C[j][i] = Utils.clamp(this.W_C[j][i], -2, 2);
                    }
                }
            }
        }
    }

    _getAffectedSubsystems(errorType) {
        const map = {
            'td': [{ start: 64, end: 128, lr: 0.01 }, { start: 128, end: 192, lr: 0.03 }],
            'prediction': [{ start: 0, end: 64, lr: 0.10 }],
            'emotion': [{ start: 192, end: 256, lr: 0.001 }],
            'hebbian': [{ start: 0, end: 64, lr: 0.10 }, { start: 64, end: 128, lr: 0.01 }]
        };
        return map[errorType] || [{ start: 64, end: 128, lr: 0.01 }];
    }

    _hebbianUpdate(pre, post, correlation, label, errorType = 'hebbian') {
        if (!arenaConfig.enableHebbian || !pre?.length || !post?.length) return;
        const eta = this.hebbianRate * correlation * 0.5;
        const step = Math.max(1, Math.floor(pre.length / 50));
        for (let i = 0; i < post.length; i += step) {
            for (let j = 0; j < pre.length; j += step) {
                const delta = eta * pre[j] * post[i];
                if (label === 'P‚ÜíA') {
                    const headIdx = Math.floor(i / this.DIM.HEAD_DIM);
                    const localI = i % this.DIM.HEAD_DIM;
                    if (headIdx < this.DIM.NUM_HEADS && j < 160 && localI < this.DIM.HEAD_DIM) {
                        this.W_A[headIdx][j][localI] += delta;
                        this.W_A[headIdx][j][localI] = Utils.clamp(this.W_A[headIdx][j][localI], -2, 2);
                    }
                } else if (label === 'A‚ÜíC' && i < this.DIM.DIM_C) {
                    const weightRow = 32 + j;
                    if (weightRow < 289 && this.W_C[weightRow] && this.W_C[weightRow][i] !== undefined) {
                        this.W_C[weightRow][i] += delta;
                        this.W_C[weightRow][i] = Utils.clamp(this.W_C[weightRow][i], -2, 2);
                    }
                } else if (label === 'C‚ÜíD' && i < this.DIM.DIM_D) {
                    if (j < 336 && this.W_D[j] && this.W_D[j][i] !== undefined) {
                        this.W_D[j][i] += delta;
                        this.W_D[j][i] = Utils.clamp(this.W_D[j][i], -2, 2);
                    }
                }
            }
        }
    }

    _consolidateMemories(reward) {
        for (let i = 0; i < 48; i++) {
            if (this.predictionErrors[i] > 0.25) {
                this.consolidationBuffer.push({
                    idx: i, value: this.M[96 + i], priority: this.predictionErrors[i] * reward
                });
            }
        }
        if (this.consolidationBuffer.length > 0 && this._rng.next() < 0.1) {
            const total = this.consolidationBuffer.reduce((s, x) => s + x.priority, 0);
            if (total <= 0) return;
            let rand = this._rng.next() * total;
            let selected = this.consolidationBuffer[0];
            for (const item of this.consolidationBuffer) {
                rand -= item.priority;
                if (rand <= 0) { selected = item; break; }
            }
            this.M[48 + selected.idx] = Utils.lerp(this.M[48 + selected.idx], selected.value, 0.2);
            this._stats.consolidationEvents++;
            const idx = this.consolidationBuffer.indexOf(selected);
            if (idx >= 0) this.consolidationBuffer.splice(idx, 1);
        }
        if (this.consolidationBuffer.length > this.maxBuffer) {
            this.consolidationBuffer.sort((a, b) => b.priority - a.priority);
            this.consolidationBuffer.length = this.maxBuffer;
        }
    }

    mutate(rate = 0.1, strength = 0.1) {
        if (!arenaConfig.enableEvolution) return 0;
        let mutations = 0;
        const mutateMat = (mat) => {
            if (!mat?.length) return;
            for (let i = 0; i < mat.length; i++) {
                if (!mat[i]?.length) continue;
                for (let j = 0; j < mat[i].length; j++) {
                    if (this._rng.next() < rate) {
                        mat[i][j] += (this._rng.next() * 2 - 1) * strength;
                        mat[i][j] = Utils.clamp(mat[i][j], -2, 2);
                        mutations++;
                    }
                }
            }
        };
        mutateMat(this.W_P); mutateMat(this.W_C); mutateMat(this.W_D);
        for (const W of this.W_A) mutateMat(W);
        mutateMat(this.W_M_work); mutateMat(this.W_M_perm); mutateMat(this.W_M_pred);
        mutateMat(this.W_S); mutateMat(this.W_pred);
        for (let i = 0; i < this.W_gate.length; i++) {
            if (this._rng.next() < rate) {
                this.W_gate[i] += (this._rng.next() * 2 - 1) * strength;
                this.W_gate[i] = Utils.clamp(this.W_gate[i], -2, 2);
                mutations++;
            }
        }
        for (let i = 0; i < this.W_reflex.length; i++) {
            if (this._rng.next() < rate) {
                this.W_reflex[i] += (this._rng.next() * 2 - 1) * strength;
                this.W_reflex[i] = Utils.clamp(this.W_reflex[i], -2, 2);
                mutations++;
            }
        }
        return mutations;
    }

    clone() {
        const clone = new Cortex2Brain({
            seed: this.seed + '_clone_' + Date.now(),
            lr: this.lr, gamma: this.gamma, lambda: this.lambda
        });
        clone.W_P = Utils.cloneTensor(this.W_P); clone.b_P = new Float32Array(this.b_P);
        clone.W_A = this.W_A.map(m => Utils.cloneTensor(m)); clone.b_A = this.b_A.map(b => new Float32Array(b));
        clone.W_gate = new Float32Array(this.W_gate); clone.W_reflex = new Float32Array(this.W_reflex);
        clone.W_M_work = Utils.cloneTensor(this.W_M_work); clone.b_M_work = new Float32Array(this.b_M_work);
        clone.W_M_perm = Utils.cloneTensor(this.W_M_perm); clone.b_M_perm = new Float32Array(this.b_M_perm);
        clone.W_M_pred = Utils.cloneTensor(this.W_M_pred); clone.b_M_pred = new Float32Array(this.b_M_pred);
        clone.W_C = Utils.cloneTensor(this.W_C); clone.b_C = new Float32Array(this.b_C);
        clone.W_S = Utils.cloneTensor(this.W_S); clone.b_S = new Float32Array(this.b_S);
        clone.W_D = Utils.cloneTensor(this.W_D); clone.b_D = new Float32Array(this.b_D);
        clone.W_pred = Utils.cloneTensor(this.W_pred); clone.b_pred = new Float32Array(this.b_pred);
        clone.W_V = new Float32Array(this.W_V); clone.b_V = this.b_V;
        clone.P.set(this.P); clone.A.set(this.A); clone.M.set(this.M);
        clone.C.set(this.C); clone.S.set(this.S); clone.D.set(this.D);
        clone.P_prev.set(this.P_prev); clone.A_prev.set(this.A_prev); clone.M_prev.set(this.M_prev);
        clone.C_prev.set(this.C_prev); clone.S_prev.set(this.S_prev); clone.D_prev.set(this.D_prev);
        clone.predictionErrors.set(this.predictionErrors);
        clone.trace_P.set(this.trace_P); clone.trace_C.set(this.trace_C);
        clone.trace_D.set(this.trace_D); clone.trace_pred.set(this.trace_pred);
        clone._stats = { ...this._stats, tdErrorHistory: [...this._stats.tdErrorHistory] };
        clone.consolidationBuffer = [...this.consolidationBuffer.map(x => ({...x}))];
        clone.emotions = { ...this.emotions };
        clone.emotionHistory = [...this.emotionHistory];
        clone.emotionalState = Utils.deepClone(this.emotionalState);
        clone.emotionMemory = {
            trauma: this.emotionMemory.trauma,
            grudge: new Map(this.emotionMemory.grudge),
            lastEmotion: this.emotionMemory.lastEmotion ? { ...this.emotionMemory.lastEmotion } : null,
            unresolved: this.emotionMemory.unresolved, killer: this.emotionMemory.killer
        };
        clone.emotionConfig = Utils.deepClone(this.emotionConfig);
        clone.emotionDecay = this.emotionDecay;
        clone.emotionInfluence = this.emotionInfluence;
        clone.step = this.step;
        clone.cumulativeReward = this.cumulativeReward;
        clone.health = this.health;
        clone.stats = { ...this.stats };
        clone._lastKiller = this._lastKiller;
        clone.predictedPos60 = { ...this.predictedPos60 };
        clone.predictionError60 = this.predictionError60;
        clone.predictedTrajectory = { ...this.predictedTrajectory };
        clone._prevFacingAngle = this._prevFacingAngle;
        return clone;
    }

    toJSON() {
        return {
            type: 'Cortex2Brain', version: '2.0',
            config: {
                seed: this.seed, lr: this.lr, gamma: this.gamma, lambda: this.lambda,
                dims: { P: this.DIM.DIM_P, A: this.DIM.DIM_A, M: this.DIM.DIM_M, C: this.DIM.DIM_C, S: this.DIM.DIM_S, D: this.DIM.DIM_D }
            },
            weights: {
                W_P: this.W_P.map(r => Array.from(r)), b_P: Array.from(this.b_P),
                W_A: this.W_A.map(m => m.map(r => Array.from(r))), b_A: this.b_A.map(b => Array.from(b)),
                W_gate: Array.from(this.W_gate), W_reflex: Array.from(this.W_reflex),
                W_M_work: this.W_M_work.map(r => Array.from(r)), b_M_work: Array.from(this.b_M_work),
                W_M_perm: this.W_M_perm.map(r => Array.from(r)), b_M_perm: Array.from(this.b_M_perm),
                W_M_pred: this.W_M_pred.map(r => Array.from(r)), b_M_pred: Array.from(this.b_M_pred),
                W_C: this.W_C.map(r => Array.from(r)), b_C: Array.from(this.b_C),
                W_S: this.W_S.map(r => Array.from(r)), b_S: Array.from(this.b_S),
                W_D: this.W_D.map(r => Array.from(r)), b_D: Array.from(this.b_D),
                W_pred: this.W_pred.map(r => Array.from(r)), b_pred: Array.from(this.b_pred),
                W_V: Array.from(this.W_V), b_V: this.b_V
            },
            state: {
                P: Array.from(this.P), A: Array.from(this.A), M: Array.from(this.M),
                C: Array.from(this.C), S: Array.from(this.S), D: Array.from(this.D),
                P_prev: Array.from(this.P_prev), A_prev: Array.from(this.A_prev), M_prev: Array.from(this.M_prev),
                C_prev: Array.from(this.C_prev), S_prev: Array.from(this.S_prev), D_prev: Array.from(this.D_prev),
                predictionErrors: Array.from(this.predictionErrors)
            },
            stats: this._stats, emotions: { ...this.emotions },
            emotionalState: Utils.deepClone(this.emotionalState),
            emotionMemory: {
                trauma: this.emotionMemory.trauma,
                grudge: Array.from(this.emotionMemory.grudge.entries()),
                lastEmotion: this.emotionMemory.lastEmotion,
                unresolved: this.emotionMemory.unresolved, killer: this.emotionMemory.killer
            },
            emotionConfig: Utils.deepClone(this.emotionConfig),
            emotionDecay: this.emotionDecay, emotionInfluence: this.emotionInfluence,
            step: this.step, cumulativeReward: this.cumulativeReward,
            health: this.health, stats_copy: { ...this.stats }, _lastKiller: this._lastKiller,
            predictedPos60: this.predictedPos60,
            predictionError60: this.predictionError60,
            predictedTrajectory: this.predictedTrajectory,
            _prevFacingAngle: this._prevFacingAngle
        };
    }

    static fromJSON(data) {
        if (!data || data.type !== 'Cortex2Brain' || !data.config) return new Cortex2Brain({});
        const brain = new Cortex2Brain(data.config);
        try {
            const w = data.weights;
            brain.W_P = w.W_P.map(r => new Float32Array(r)); brain.b_P = new Float32Array(w.b_P);
            brain.W_A = w.W_A.map(m => m.map(r => new Float32Array(r))); brain.b_A = w.b_A.map(b => new Float32Array(b));
            if (w.W_gate) brain.W_gate = new Float32Array(w.W_gate);
            if (w.W_reflex) brain.W_reflex = new Float32Array(w.W_reflex);
            brain.W_M_work = w.W_M_work.map(r => new Float32Array(r)); brain.b_M_work = new Float32Array(w.b_M_work);
            brain.W_M_perm = w.W_M_perm.map(r => new Float32Array(r)); brain.b_M_perm = new Float32Array(w.b_M_perm);
            brain.W_M_pred = w.W_M_pred.map(r => new Float32Array(r)); brain.b_M_pred = new Float32Array(w.b_M_pred);
            brain.W_C = w.W_C.map(r => new Float32Array(r)); brain.b_C = new Float32Array(w.b_C);
            brain.W_S = w.W_S.map(r => new Float32Array(r)); brain.b_S = new Float32Array(w.b_S);
            brain.W_D = w.W_D.map(r => new Float32Array(r)); brain.b_D = new Float32Array(w.b_D);
            brain.W_pred = w.W_pred.map(r => new Float32Array(r)); brain.b_pred = new Float32Array(w.b_pred);
            if (w.W_V) { brain.W_V = new Float32Array(w.W_V); brain.b_V = w.b_V ?? 0; }
            const s = data.state;
            brain.P.set(s.P); brain.A.set(s.A); brain.M.set(s.M);
            brain.C.set(s.C); brain.S.set(s.S); brain.D.set(s.D);
            brain.P_prev.set(s.P_prev); brain.A_prev.set(s.A_prev); brain.M_prev.set(s.M_prev);
            brain.C_prev.set(s.C_prev); brain.S_prev.set(s.S_prev); brain.D_prev.set(s.D_prev);
            brain.predictionErrors.set(s.predictionErrors);
            if (data.stats) brain._stats = { ...data.stats };
            if (data.emotions) brain.emotions = { ...data.emotions };
            if (data.emotionalState) brain.emotionalState = Utils.deepClone(data.emotionalState);
            if (data.emotionMemory) {
                brain.emotionMemory.trauma = data.emotionMemory.trauma || 0;
                brain.emotionMemory.grudge = new Map(data.emotionMemory.grudge || []);
                brain.emotionMemory.lastEmotion = data.emotionMemory.lastEmotion;
                brain.emotionMemory.unresolved = data.emotionMemory.unresolved || 0;
                brain.emotionMemory.killer = data.emotionMemory.killer;
            }
            if (data.emotionConfig) brain.emotionConfig = Utils.deepClone(data.emotionConfig);
            if (data.emotionDecay) brain.emotionDecay = data.emotionDecay;
            if (data.emotionInfluence !== undefined) brain.emotionInfluence = data.emotionInfluence;
            if (data.step) brain.step = data.step;
            if (data.cumulativeReward !== undefined) brain.cumulativeReward = data.cumulativeReward;
            if (data.health) brain.health = data.health;
            if (data.stats_copy) brain.stats = { ...data.stats_copy };
            if (data._lastKiller) brain._lastKiller = data._lastKiller;
            if (data.predictedPos60) brain.predictedPos60 = data.predictedPos60;
            if (data.predictionError60 !== undefined) brain.predictionError60 = data.predictionError60;
            if (data.predictedTrajectory) brain.predictedTrajectory = data.predictedTrajectory;
            if (data._prevFacingAngle !== undefined) brain._prevFacingAngle = data._prevFacingAngle;
        } catch(e) { console.warn('Cortex2Brain.fromJSON error:', e); }
        return brain;
    }

    getStats() { return { ...this._stats }; }
    getEmotions() { return { ...this.emotions }; }

    updateDiagnostics(metrics) {
        if (!metrics) return;
        if (metrics.reward !== undefined) this._stats.avgReward = Utils.lerp(this._stats.avgReward, Utils.safeNumber(metrics.reward, 0), 0.01);
    }
    
    // FIX: Added missing restoreEmotionalMemory method
    restoreEmotionalMemory() {
        this.emotions = {
            threat: 0, frustration: 0, confidence: 0, aggression: 0,
            fear: 0, surprise: 0, caution: 0, desperation: 0, vengeance: 0
        };
        this.emotionalState = {
            current: null,
            history: [],
            satisfaction: 0,
            momentum: {
                fear: 0, aggression: 0, frustration: 0,
                desperation: 0, confidence: 0, vengeance: 0
            }
        };
        this.emotionMemory = {
            trauma: 0, grudge: new Map(), lastEmotion: null,
            unresolved: 0, killer: null
        };
    }
}

class CriticNetwork {
    constructor(config = {}) {
        this.inputDim = config.inputDim ?? arenaConfig.ARCH.INPUT_DIM;
        this.hidden = config.hidden ?? arenaConfig.ARCH.CRITIC_HIDDEN;
        this.seed = config.seed ?? (arenaConfig.seed + '_CRITIC');
        this._rng = new SeededRNG(this.seed);
        this._W1 = this._rng.deriveWeights(this.inputDim, this.hidden, 0.3);
        this._W2 = this._rng.deriveWeights(this.hidden, 1, 0.1);
        this._b1 = this._rng.deriveVector(this.hidden, 0.1);
        this._b2 = 0;
        this.lr = config.lr ?? arenaConfig.learningRate;
        this.gamma = config.gamma ?? arenaConfig.gamma;
    }
    forward(inputs) {
        if (!Array.isArray(inputs) || inputs.length !== this.inputDim) {
            inputs = new Array(this.inputDim).fill(0);
        }
        const hidden = [];
        for (let o = 0; o < this.hidden; o++) {
            let sum = Utils.safeNumber(this._b1[o], 0);
            for (let i = 0; i < inputs.length; i++) {
                sum += Utils.safeNumber(inputs[i], 0) * Utils.safeNumber(this._W1[i]?.[o], 0);
            }
            hidden.push(Utils.leakyRelu(sum));
        }
        let value = this._b2;
        for (let i = 0; i < this.hidden; i++) {
            value += Utils.safeNumber(hidden[i], 0) * Utils.safeNumber(this._W2[i]?.[0], 0);
        }
        return Utils.clamp(value, -10, 10);
    }
    update(inputs, reward, nextValue, alpha = null) {
        const currentValue = this.forward(inputs);
        const tdErr = Utils.tdError(reward, currentValue, nextValue, this.gamma);
        const lr = alpha ?? this.lr;
        this._b2 += lr * tdErr;
        return { tdError: tdErr, value: currentValue };
    }
    clone() {
        const clone = new CriticNetwork({
            inputDim: this.inputDim, hidden: this.hidden,
            seed: this.seed + '_clone', lr: this.lr, gamma: this.gamma
        });
        clone._W1 = this._W1.map(r => r.slice());
        clone._W2 = this._W2.map(r => r.slice());
        clone._b1 = this._b1.slice();
        clone._b2 = this._b2;
        return clone;
    }
    toJSON() {
        return {
            config: { inputDim: this.inputDim, hidden: this.hidden, seed: this.seed, lr: this.lr, gamma: this.gamma },
            W1: this._W1.map(r => r.slice()), W2: this._W2.map(r => r.slice()),
            b1: this._b1.slice(), b2: this._b2
        };
    }
    static fromJSON(data) {
        if (!data?.config) return new CriticNetwork({});
        const c = new CriticNetwork(data.config);
        c._W1 = (data.W1 || []).map(r => (r || []).slice());
        c._W2 = (data.W2 || []).map(r => (r || []).slice());
        c._b1 = (data.b1 || []).slice();
        c._b2 = data.b2 ?? 0;
        return c;
    }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// FOOTBALL BALL ‚Äî PATCHED: Fixed ghost possession, added physics
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class FootballBall {
    constructor(x, y) {
        this.x = x || 410;
        this.y = y || 300;
        this.vx = 0;
        this.vy = 0;
        this.owner = null;
        this.radius = FOOTBALL_CONFIG.BALL_RADIUS;
        this.trail = [];
        this.lastKick = 0;
        this.inAir = false;
        this.z = 0;
        // FIX #1: Track actual kicker position for proximity check
        this.lastKickerPos = null;
        this.kickTimestamp = -1;
    }

    update(dt, world) {
        this.x += this.vx * dt;
        this.y += this.vy * dt;
        
        this.vx *= FOOTBALL_CONFIG.BALL_FRICTION;
        this.vy *= FOOTBALL_CONFIG.BALL_FRICTION;
        
        if (Math.abs(this.vx) < 0.05) this.vx = 0;
        if (Math.abs(this.vy) < 0.05) this.vy = 0;
        
        const speed = Math.hypot(this.vx, this.vy);
        if (speed > FOOTBALL_CONFIG.BALL_MAX_VELOCITY) {
            const scale = FOOTBALL_CONFIG.BALL_MAX_VELOCITY / speed;
            this.vx *= scale;
            this.vy *= scale;
        }
        
        const goalTop = FOOTBALL_CONFIG.GOAL_Y - FOOTBALL_CONFIG.GOAL_HEIGHT / 2;
        const goalBottom = FOOTBALL_CONFIG.GOAL_Y + FOOTBALL_CONFIG.GOAL_HEIGHT / 2;
        
        if (this.y < this.radius + 10) {
            this.vy *= -0.7;
            this.y = this.radius + 10;
        }
        if (this.y > FOOTBALL_CONFIG.FIELD_HEIGHT - this.radius - 10) {
            this.vy *= -0.7;
            this.y = FOOTBALL_CONFIG.FIELD_HEIGHT - this.radius - 10;
        }
        
        if (this.x < this.radius + 10) {
            if (this.y < goalTop || this.y > goalBottom) {
                this.vx *= -0.7;
                this.x = this.radius + 10;
            }
        }
        if (this.x > FOOTBALL_CONFIG.FIELD_WIDTH - this.radius - 10) {
            if (this.y < goalTop || this.y > goalBottom) {
                this.vx *= -0.7;
                this.x = FOOTBALL_CONFIG.FIELD_WIDTH - this.radius - 10;
            }
        }
        
        if (this.trail.length === 0 || this.trail[this.trail.length - 1].age > 2) {
            this.trail.push({ x: this.x, y: this.y, age: 0 });
            if (this.trail.length > 15) this.trail.shift();
        }
        this.trail.forEach(t => t.age++);
        
        // FIX #1: Clear ownership immediately after kick cooldown expires
        // No more "ghost possession" ‚Äî owner can only control if within KICK_RANGE
        if (this.owner && this.lastKick > 0) {
            this.lastKick--;
            if (this.lastKick <= 0) {
                this.owner = null;
                this.lastKickerPos = null;
            }
        }
    }

    // FIX #1: Kick now requires proximity check for subsequent control
    kick(angle, power, ownerId, kickerPos = null) {
        this.vx = Math.cos(angle) * power;
        this.vy = Math.sin(angle) * power;
        // Store owner for visual/logic purposes ONLY ‚Äî actual control requires proximity
        this.owner = ownerId;
        this.lastKick = 20;  // Visual indicator duration only
        this.inAir = power > 12;
        // FIX #1: Record kicker position for proximity validation
        this.lastKickerPos = kickerPos ? { ...kickerPos } : null;
        this.kickTimestamp = window.arenaGame?.world?.step || 0;
    }

    // FIX #4: NEW ‚Äî Physical collision with players (no "ownership" required)
    collideWithPlayer(player) {
        const dx = this.x - player.x;
        const dy = this.y - player.y;
        const dist = Math.hypot(dx, dy);
        const minDist = FOOTBALL_CONFIG.PLAYER_RADIUS + this.radius;
        
        if (dist < minDist && dist > 0.001) {
            // Calculate collision normal
            const nx = dx / dist;
            const ny = dy / dist;
            
            // Relative velocity
            const relVx = this.vx - player.vx;
            const relVy = this.vy - player.vy;
            const relVelNormal = relVx * nx + relVy * ny;
            
            // Only resolve if approaching
            if (relVelNormal < 0) {
                // Impulse based on mass ratio (ball is much lighter)
                const massRatio = 0.006; // ball mass / player mass approx
                const impulse = relVelNormal * (1 + 0.35) * massRatio; // 0.35 = elasticity
                
                // Apply to ball
                this.vx -= impulse * nx;
                this.vy -= impulse * ny;
                
                // Small reaction on player
                player.vx += impulse * nx * massRatio * 0.1;
                player.vy += impulse * ny * massRatio * 0.1;
                
                // Separate to prevent sticking
                const penetration = minDist - dist;
                this.x += nx * penetration * 0.5;
                this.y += ny * penetration * 0.5;
                player.x -= nx * penetration * 0.5 * massRatio;
                player.y -= ny * penetration * 0.5 * massRatio;
                
                return true; // Collision occurred
            }
        }
        return false;
    }

    // FIX #1: Check if player can actually control ball (proximity + recent kick)
    canBeControlledBy(agent, worldStep) {
        if (!this.owner || this.owner !== agent.id) return false;
        // Must be within kick range AND recent kick OR currently touching
        const dist = Utils.dist(this, agent);
        const inRange = dist <= (agent.stats?.kickRange || 35);
        const recentKick = this.lastKickerPos && worldStep - this.kickTimestamp < 10;
        return inRange || (recentKick && dist < 40);
    }

    reset(x, y) {
        this.x = x || FOOTBALL_CONFIG.FIELD_WIDTH / 2;
        this.y = y || FOOTBALL_CONFIG.GOAL_Y;
        this.vx = 0;
        this.vy = 0;
        this.owner = null;
        this.trail = [];
        this.lastKick = 0;
        this.inAir = false;
        this.z = 0;
        this.lastKickerPos = null;
        this.kickTimestamp = -1;
    }

    draw(ctx) {
        if (this.trail.length > 1) {
            ctx.beginPath();
            ctx.moveTo(this.trail[0].x, this.trail[0].y);
            for (let i = 1; i < this.trail.length; i++) {
                const t = this.trail[i];
                const alpha = 1 - t.age / 15;
                ctx.strokeStyle = `rgba(255, 255, 255, ${alpha * 0.4})`;
                ctx.lineWidth = this.radius * alpha;
                ctx.lineTo(t.x, t.y);
            }
            ctx.stroke();
        }
        
        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.beginPath();
        ctx.ellipse(this.x + 3, this.y + 4, this.radius * 0.9, this.radius * 0.5, 0, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = '#000000';
        ctx.beginPath();
        ctx.arc(this.x - 4, this.y - 3, 4, 0, Math.PI * 2);
        ctx.arc(this.x + 5, this.y + 2, 3, 0, Math.PI * 2);
        ctx.arc(this.x, this.y + 6, 3, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.strokeStyle = '#333333';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.stroke();
        
        // FIX #9: Only show possession indicator if ball is ACTUALLY near owner
        if (this.owner) {
            const kicker = window.arenaGame?.world?.agents?.find(a => a.id === this.owner);
            if (kicker && Utils.dist(kicker, this) < (kicker.stats?.kickRange || 35) + 5) {
                ctx.strokeStyle = 'rgba(255, 255, 0, 0.9)';
                ctx.lineWidth = 2;
                ctx.setLineDash([4, 3]);
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius + 8, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
            }
        }
    }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// FOOTBALL AGENT ‚Äî PATCHED: Fixed vision, movement, ball control
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class FootballAgent {
    static get VISUAL_RADIUS() { return 22; }
    static get COLLISION_RADIUS() { return 22; }

    constructor(id, x, y, color, seed, role = 'midfielder', team = 'blue') {
        this.id = id;
        this.x = x;
        this.y = y;
        this.color = color;
        this.seed = seed;
        this.team = team === 'red' ? 'red' : 'blue';
        this.vx = 0;
        this.vy = 0;
        this.velocity = { x: 0, y: 0 };
        this.facingAngle = 0;
        this.role = role;
        this.roleStats = FOOTBALL_CONFIG.ROLES[role] || FOOTBALL_CONFIG.ROLES.midfielder;
        
        this.stats = { 
            maxHealth: 100, 
            kickPower: 10, 
            speed: 10, 
            accuracy: 0.7,
            stamina: 100,
            kickRange: 35
        };
        this.health = this.stats.maxHealth;
        this.stamina = this.stats.stamina;
        this.weaponType = 'football';
        this.bodyVertices = [
            { x: 20, y: -14 }, { x: 20, y: 14 },
            { x: -18, y: 14 }, { x: -18, y: -14 }
        ];
        this.net = new Cortex2Brain({
            seed: seed + '_CORTEX2_' + id,
            lr: arenaConfig.learningRate,
            gamma: arenaConfig.gamma,
            lambda: arenaConfig.lambda,
            hebbianRate: arenaConfig.hebbianRate
        });
        this.critic = new CriticNetwork({
            inputDim: arenaConfig.ARCH.INPUT_DIM,
            hidden: arenaConfig.ARCH.CRITIC_HIDDEN,
            seed: seed + '_CRITIC_' + id,
            lr: arenaConfig.learningRate,
            gamma: arenaConfig.gamma
        });
        this.mode = 'football';
        this.target = { x, y };
        this.speed = 1;
        this.stuckCounter = 0;
        this.lastPos = { x, y };
        this.cumulativeReward = 0;
        this.alive = true;
        this.skillEmbedding = [0.3, 0.4, 0.2, 0.5, 0.6];
        this.permanent = {
            skills: {
                passing: 0.3,
                shooting: 0.4,
                defending: 0.2,
                positioning: 0.5,
                stamina: 0.6
            },
            strategies: {
                playStyle: 'balanced',
                preferredSide: 'center',
                defensiveLine: 0.5
            },
            preferences: {
                passDistance: 'medium',
                shotSelection: 'balanced',
                positioning: 'dynamic'
            },
            muscleMemory: new Float32Array(16).fill(0),
            memory: {
                lastBallPos: null,
                lastBallStep: 0,
                visited: new Set(),
                unvisited: []
            }
        };
        this.predictive = {
            shortTerm: { positions: [], actions: [], results: [], ballHistory: [] },
            predictions: { ballPos: { x: 0, y: 0 }, interceptPos: { x: 0, y: 0 }, success: 0.5 },
            confidence: 0.5,
            predictionError: 0
        };
        this.wins = 0;
        this.totalKicks = 0;
        this.successfulPasses = 0;
        this.shotsOnTarget = 0;
        this.goals = 0;
        this.deaths = 0;
        this.mutations = 0;
        this.generation = 1;
        this.trail = [];
        this.lastDecision = null;
        this._lastWorld = null;
        this.learningBuffer = {
            states: [],
            actions: [],
            rewards: [],
            nextStates: [],
            dones: [],
            values: [],
            maxBuffer: 32
        };
        this.evolutionPoints = 0;
        this._lastKickDealt = 0;
        this._lastTouchTime = 0;
        this._kickCooldown = 0;
        this._passTarget = null;
        this._shotTarget = null;
        this._defensivePosition = null;
        this._formationOffset = { x: 0, y: 0 };
        this._ballPossessionTime = 0;
        this._distanceCovered = 0;
        this._sprintActive = false;
        this._inputBuffer = new Float32Array(64);
        this._teammateCache = [];
        this._opponentCache = [];
        this._combatEvents = [];
        this.mentalMap = {
            ball: { x: 0, y: 0, vx: 0, vy: 0, owner: null, confidence: 0, lastSeen: 0, predictedX: 0, predictedY: 0, velocityHistory: [] },
            teammates: new Map(),
            opponents: new Map(),
            goal: { x: 0, y: 0, myGoalX: 0, myGoalY: 0, angle: 0, distance: 0, shootingAngle: 0 },
            teamStats: { averagePosition: { x: 0, y: 0 }, formationIntact: true, possession: false, attackingPhase: false, defensiveLine: 0, pressureLevel: 0 },
            spatialAnalysis: { freeZones: [], dangerZones: [], passingLanes: [], coverage: 0 },
            lastUpdate: 0,
            currentIntent: 'none',
            incomingPass: null
        };
        this.assignedPosition = { x: 0, y: 0 };
        this.assignedRole = role;
        this.predictedIntercept = null;
        this.passStats = {
            total: 0,
            successful: 0,
            intercepted: 0,
            toGoal: 0,
            backward: 0,
            accuracy: 0.0,
            averageDistance: 0,
            keyPasses: 0
        };
        
        this._ballPredictor = null;
        this._teamEmotionSystem = null;
        this._sharedMap = null;
        this._lastPassSuccessful = false;
        this._idleFrames = 0;
        this.lastDistToBall = 999;
        this._prevFacingAngle = 0;
        // FIX #8: Add momentum/velocity history for inertia
        this._velocityHistory = [];
        this._maxVelocityHistory = 5;
    }

    _initProfessionalSystems(world, teamEmotionSystem, sharedMentalMap) {
        this._ballPredictor = new BallPredictor();
        this._teamEmotionSystem = teamEmotionSystem;
        this._sharedMap = sharedMentalMap;
        this._lastPassSuccessful = false;
        this._idleFrames = 0;
    }

    getInputs(world) {
        this._teammateCache.length = 0;
        this._opponentCache.length = 0;
        
        const viewRadius = arenaConfig.viewRadius || 300;
        const now = world?.step || 0;
        
        // FIX #5: BALL always visible but with noise beyond viewRadius
        let ballX = 0, ballY = 0, ballVx = 0, ballVy = 0, ballOwner = null;
        let ballKnown = false;
        
        if (world?.ball) {
            ballX = world.ball.x;
            ballY = world.ball.y;
            ballVx = world.ball.vx;
            ballVy = world.ball.vy;
            ballOwner = world.ball.owner;
            ballKnown = true;
        }
        
        if (!ballKnown && this._sharedMap && arenaConfig.enableProfessional) {
            if (this.mentalMap.ball.lastSeen > 0 && (world.step - this.mentalMap.ball.lastSeen) < 60) {
                ballX = this.mentalMap.ball.predictedX;
                ballY = this.mentalMap.ball.predictedY;
                ballVx = this.mentalMap.ball.vx;
                ballVy = this.mentalMap.ball.vy;
                ballKnown = true;
            }
        }
        
        if (ballKnown) {
            const dx = ballX - this.x;
            const dy = ballY - this.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            
            // FIX #5: Add noise proportional to distance beyond viewRadius
            let noiseScale = 0;
            if (dist > viewRadius) {
                noiseScale = Math.min(0.4, (dist - viewRadius) / viewRadius * 0.4);
            }
            
            this._inputBuffer[0] = Utils.clamp(dx / viewRadius + Utils.randGaussian(0, noiseScale), -1, 1);
            this._inputBuffer[1] = Utils.clamp(dy / viewRadius + Utils.randGaussian(0, noiseScale), -1, 1);
            this._inputBuffer[2] = Math.min(dist / viewRadius, 1);
            this._inputBuffer[3] = ballOwner === this.id ? 1 : 0;
            this._inputBuffer[4] = Utils.clamp(ballVx / 20 + Utils.randGaussian(0, noiseScale * 0.5), -1, 1);
            this._inputBuffer[5] = Utils.clamp(ballVy / 20 + Utils.randGaussian(0, noiseScale * 0.5), -1, 1);
        } else {
            this._inputBuffer[0] = 0;
            this._inputBuffer[1] = 0;
            this._inputBuffer[2] = 1;
            this._inputBuffer[3] = 0;
            this._inputBuffer[4] = 0;
            this._inputBuffer[5] = 0;
        }
        
        // GOAL (4 inputs: 6-9)
        const enemyGoal = this.team === 'blue' ?
            { x: FOOTBALL_CONFIG.FIELD_WIDTH, y: FOOTBALL_CONFIG.GOAL_Y } :
            { x: 0, y: FOOTBALL_CONFIG.GOAL_Y };
        
        const goalDx = enemyGoal.x - this.x;
        const goalDy = enemyGoal.y - this.y;
        const goalDist = Math.sqrt(goalDx*goalDx + goalDy*goalDy);
        const goalAngle = Math.atan2(goalDy, goalDx);
        
        this._inputBuffer[6] = goalDx / viewRadius;
        this._inputBuffer[7] = goalDy / viewRadius;
        this._inputBuffer[8] = Math.min(goalDist / viewRadius, 1);
        this._inputBuffer[9] = this.team === 'blue' ? 1 : 0;
        
        this.mentalMap.goal = {
            x: enemyGoal.x, y: enemyGoal.y,
            angle: goalAngle, distance: goalDist,
            shootingAngle: Math.abs(goalAngle - this.facingAngle)
        };
        
        // TEAMMATES (5 players √ó 5 inputs = 25: 10-34)
        const allAllies = (world?.agents || [])
            .filter(a => a?.alive && a.team === this.team && a.id !== this.id);
        
        const allies = allAllies.map(a => ({
            id: a.id,
            dx: (a.x - this.x) / viewRadius,
            dy: (a.y - this.y) / viewRadius,
            dist: Utils.dist(this, a) / viewRadius,
            stamina: a.stamina / 100,
            hasBall: a.id === world?.ball?.owner ? 1 : 0,
            role: a.role,
            velocityX: a.vx / 15,
            velocityY: a.vy / 15,
            intent: a.mentalMap?.currentIntent || 'none',
            predictedX: a.x + (a.vx || 0) * 10,
            predictedY: a.y + (a.vy || 0) * 10
        }))
        .sort((a, b) => a.dist - b.dist)
        .slice(0, 5);
        
        for (let i = 0; i < 5; i++) {
            const offset = 10 + i * 5;
            if (i < allies.length) {
                this._inputBuffer[offset] = allies[i].dx;
                this._inputBuffer[offset+1] = allies[i].dy;
                this._inputBuffer[offset+2] = allies[i].dist;
                this._inputBuffer[offset+3] = allies[i].stamina;
                this._inputBuffer[offset+4] = allies[i].hasBall;
                
                this.mentalMap.teammates.set(allies[i].id, {
                    x: allies[i].dx * viewRadius + this.x,
                    y: allies[i].dy * viewRadius + this.y,
                    role: allies[i].role, stamina: allies[i].stamina,
                    hasBall: allies[i].hasBall === 1, confidence: 1.0, lastSeen: now,
                    velocityX: allies[i].velocityX, velocityY: allies[i].velocityY,
                    intent: allies[i].intent,
                    predictedX: allies[i].predictedX, predictedY: allies[i].predictedY
                });
            } else {
                this._inputBuffer[offset] = 0;
                this._inputBuffer[offset+1] = 0;
                this._inputBuffer[offset+2] = 1;
                this._inputBuffer[offset+3] = 0;
                this._inputBuffer[offset+4] = 0;
            }
        }
        
        // OPPONENTS (5 players √ó 4 inputs = 20: 35-54)
        const opponents = (world?.agents || [])
            .filter(e => e?.alive && e.team !== this.team)
            .map(e => ({
                id: e.id,
                dx: (e.x - this.x) / viewRadius,
                dy: (e.y - this.y) / viewRadius,
                dist: Utils.dist(this, e) / viewRadius,
                hasBall: e.id === world?.ball?.owner ? 1 : 0,
                velocityX: e.vx / 15,
                velocityY: e.vy / 15,
                predictedX: e.x + (e.vx || 0) * 10,
                predictedY: e.y + (e.vy || 0) * 10
            }))
            .sort((a, b) => a.dist - b.dist)
            .slice(0, 5);
        
        for (let i = 0; i < 5; i++) {
            const offset = 35 + i * 4;
            if (i < opponents.length) {
                this._inputBuffer[offset] = opponents[i].dx;
                this._inputBuffer[offset+1] = opponents[i].dy;
                this._inputBuffer[offset+2] = opponents[i].dist;
                this._inputBuffer[offset+3] = opponents[i].hasBall;
                
                this.mentalMap.opponents.set(opponents[i].id, {
                    x: opponents[i].dx * viewRadius + this.x,
                    y: opponents[i].dy * viewRadius + this.y,
                    hasBall: opponents[i].hasBall === 1,
                    confidence: 1.0, lastSeen: now,
                    velocityX: opponents[i].velocityX, velocityY: opponents[i].velocityY,
                    predictedX: opponents[i].predictedX, predictedY: opponents[i].predictedY
                });
            } else {
                this._inputBuffer[offset] = 0;
                this._inputBuffer[offset+1] = 0;
                this._inputBuffer[offset+2] = 1;
                this._inputBuffer[offset+3] = 0;
            }
        }
        
        // AGENT STATE (6 inputs: 55-60)
        this._inputBuffer[55] = this.facingAngle / Math.PI;
        this._inputBuffer[56] = Utils.clamp(this.cumulativeReward / 50, -1, 1);
        this._inputBuffer[57] = this.health / this.stats.maxHealth;
        this._inputBuffer[58] = this.stamina / 100;
        this._inputBuffer[59] = this._kickCooldown / 30;
        this._inputBuffer[60] = this._ballPossessionTime / 120;
        
        // SCORE (2 inputs: 61-62)
        this._inputBuffer[61] = (world?.score?.blue || 0) / 10;
        this._inputBuffer[62] = (world?.score?.red || 0) / 10;
        
        // FORMATION + ROLE (1 input: 63)
        const roleCode = FOOTBALL_ROLES[this.role]?.id || 2;
        this._inputBuffer[63] = (roleCode / 3) + (this._formationOffset.x / 200) * 0.1;
        
        for (let i = 0; i < 64; i++) {
            if (!isFinite(this._inputBuffer[i])) {
                this._inputBuffer[i] = 0;
            }
        }
        
        return Array.from(this._inputBuffer);
    }

    decide(world) {
        this.world = world;
        
        this._updateMentalMap(world);
        
        if (this._sharedMap && arenaConfig.enableProfessional) {
            this._sharedMap.update(world);
        }
        
        const inputs = this.getInputs(world);
        const combatEvents = this._combatEvents.length > 0 ? [...this._combatEvents] : null;
        const cortexRes = this.net.forward(inputs, this.cumulativeReward * 0.01, combatEvents);
        this._combatEvents = [];
        let D = cortexRes.output;
        
        if (arenaConfig.enableProfessional) {
            const role = FOOTBALL_ROLES[this.role];
            const roleMask = role?.outputMask || FOOTBALL_ROLES.midfielder.outputMask;
            
            for (let i = 0; i < 16; i++) {
                const key = `D${i}`;
                const mask = roleMask[key];
                if (mask !== undefined) {
                    D[i] = D[i] * mask + (1 - mask) * this._getDefaultOutput(i, role);
                }
            }
            
            if (this._teamEmotionSystem) {
                const localEmotions = this.net.getEmotions();
                const modifiers = this._teamEmotionSystem.getBehaviorModifiers(this, localEmotions);
                
                for (let i = 0; i < 16; i++) {
                    const key = `D${i}`;
                    if (modifiers.outputMultipliers[key]) {
                        D[i] = Utils.clamp(D[i] * modifiers.outputMultipliers[key], -1, 1);
                    }
                }
            }
        }
        
        const behaviors = this._interpretOutputs(D);
        
        const gamePhase = this._determineGamePhase(world);
        const ballState = this._getBallState(world);
        
        let decision;
        switch(gamePhase) {
            case 'attack': decision = this._decideAttack(world, behaviors, ballState); break;
            case 'defend': decision = this._decideDefend(world, behaviors, ballState); break;
            case 'transition': decision = this._decideTransition(world, behaviors, ballState); break;
            default: decision = this._decideNeutral(world, behaviors);
        }
        
        this.mentalMap.currentIntent = decision.intent || 'none';
        
        const hasBall = world?.ball?.owner === this.id;
        const ballDist = world?.ball ? Utils.dist(this, world.ball) : 999;
        const nearBall = ballDist < 40;
        
        const turnForce = behaviors.turn * 0.15;
        this.facingAngle += turnForce;
        this.facingAngle = Utils.normalizeAngle(this.facingAngle);
        
        if (behaviors.sprint > 0.7) {
            this.stamina = Math.max(0, this.stamina - FOOTBALL_CONFIG.STAMINA_DRAIN * 2);
            this._sprintActive = true;
        } else {
            this.stamina = Math.min(100, this.stamina + FOOTBALL_CONFIG.STAMINA_REGEN);
            this._sprintActive = false;
        }
        
        if (this._kickCooldown > 0) this._kickCooldown--;
        
        this.lastDecision = {
            mode: hasBall ? 'attack' : (nearBall ? 'contest' : 'position'),
            behaviors, inputs, output: D,
            hasBall, ballDist,
            prediction: cortexRes.predictedTrajectory,
            intrinsicReward: cortexRes.intrinsicReward,
            gamePhase, ballState,
            intent: decision.intent,
            target: decision.target,
            interceptPoint: decision.interceptPoint,
            angle: decision.angle,
            power: decision.power,
            protectBall: decision.protectBall,
            signalIntent: decision.signalIntent,
            pressIntensity: decision.pressIntensity,
            facingAngle: this.facingAngle,
            // FIX: Add missing value property for learning
            value: this.critic.forward(inputs)
        };
        
        return { target: this.target, speed: this.speed, mode: this.lastDecision.mode, behaviors, inputs, output: D };
    }

    _interpretOutputs(D) {
        const role = FOOTBALL_ROLES[this.role];
        return {
            moveForward: Utils.clamp(D[0], 0, 1) * (role?.outputMask?.D0 ?? 1),
            turn: Utils.clamp(D[1], -1, 1),
            kickPower: Utils.clamp(D[2], 0, 1) * (role?.outputMask?.D2 ?? 1),
            sprint: D[3] > 0.7 ? 1 : 0,
            passIntent: D[4] > 0.6 ? 1 : 0,
            passTargetWeight: D[4],
            defensivePosture: Utils.clamp(D[6], 0, 1) * (role?.outputMask?.D6 ?? 1),
            coordinationSignal: D[7],
            confidence: Utils.sigmoid(D[8]),
            trajectoryBias: Utils.clamp(D[9], -1, 1),
            conserveStamina: D[10] > 0.7,
            scanRadius: Utils.lerp(200, 400, D[11])
        };
    }

    _determineGamePhase(world) {
        if (!world?.ball) return 'neutral';
        
        const hasBall = world.ball.owner && world.agents.find(a => a.id === world.ball.owner)?.team === this.team;
        const ballInOurHalf = (this.team === 'blue') ? 
            (world.ball.x < FOOTBALL_CONFIG.FIELD_WIDTH / 2) : 
            (world.ball.x > FOOTBALL_CONFIG.FIELD_WIDTH / 2);
        
        if (hasBall) return 'attack';
        if (ballInOurHalf && !hasBall) return 'defend';
        return 'transition';
    }

    _getBallState(world) {
        if (!world?.ball) return 'none';
        if (world.ball.owner === this.id) return 'owned';
        if (world.ball.owner) return 'enemy_owned';
        
        if (!this._ballPredictor || !arenaConfig.enableProfessional) {
            const ballDist = Utils.dist(this, world.ball);
            return ballDist < 40 ? 'free_clear' : 'free';
        }
        
        const intercept = this._ballPredictor.calculateIntercept(this, world.ball, world);
        if (!intercept) return 'free';
        
        const opponents = (world.agents || []).filter(a => a.team !== this.team && a.alive);
        let earlierIntercepts = 0;
        
        for (const opp of opponents) {
            const oppIntercept = this._ballPredictor.calculateIntercept(opp, world.ball, world);
            if (oppIntercept?.feasible && oppIntercept.t < intercept.t) {
                earlierIntercepts++;
            }
        }
        
        if (intercept.feasible && earlierIntercepts === 0) return 'free_clear';
        if (intercept.feasible) return 'free_contested';
        return 'free_unreachable';
    }

    _decideAttack(world, behaviors, ballState) {
        const hasBall = world?.ball?.owner === this.id;
        
        if (hasBall) {
            const enemyGoal = this.team === 'blue' ?
                { x: FOOTBALL_CONFIG.FIELD_WIDTH, y: FOOTBALL_CONFIG.GOAL_Y } :
                { x: 0, y: FOOTBALL_CONFIG.GOAL_Y };
            const distToGoal = Utils.dist(this, enemyGoal);
            
            let shootOpportunity = false;
            const role = FOOTBALL_ROLES[this.role];
            const shootDistance = role?.behavior?.shootFromDistance || 220;
            
            if (distToGoal < shootDistance && behaviors.kickPower > 0.6) {
                const opponents = (world.agents || []).filter(a => a.team !== this.team && a.alive);
                let blocked = false;
                for (const opp of opponents) {
                    const distToLine = Utils._pointSegDist(this.x, this.y, enemyGoal.x, enemyGoal.y, opp.x, opp.y);
                    if (distToLine < 25 && Utils.dist(this, opp) < Utils.dist(enemyGoal, opp)) {
                        blocked = true;
                        break;
                    }
                }
                shootOpportunity = !blocked;
            }
            
            let passOpportunity = null;
            if (behaviors.passIntent && arenaConfig.enablePassing) {
                passOpportunity = this._findSmartPassTarget(world, behaviors);
            }
            
            if (shootOpportunity && behaviors.confidence > 0.5) {
                return {
                    intent: 'shoot', target: enemyGoal,
                    power: behaviors.kickPower * FOOTBALL_CONFIG.KICK_POWER,
                    angle: Math.atan2(enemyGoal.y - this.y, enemyGoal.x - this.x) + behaviors.trajectoryBias * 0.2
                };
            }
            
            if (passOpportunity?.confidence > 0.6) {
                return {
                    intent: 'pass', target: passOpportunity.target,
                    interceptPoint: passOpportunity.leadPoint,
                    power: passOpportunity.power,
                    angle: Math.atan2(passOpportunity.leadPoint.y - this.y, passOpportunity.leadPoint.x - this.x)
                };
            }
            
            return {
                intent: 'dribble',
                target: { x: enemyGoal.x + behaviors.trajectoryBias * 50, y: enemyGoal.y },
                protectBall: behaviors.defensivePosture > 0.5,
                angle: Math.atan2(enemyGoal.y - this.y, enemyGoal.x - this.x) + behaviors.trajectoryBias * 0.3
            };
        } else {
            const idealSupport = this._calculateSupportPosition(world, 'attack');
            return {
                intent: 'support_attack', target: idealSupport,
                angle: Math.atan2(idealSupport.y - this.y, idealSupport.x - this.x),
                signalIntent: behaviors.coordinationSignal > 0.7 ? 'open_for_pass' : 'hold_position'
            };
        }
    }

    _findSmartPassTarget(world, behaviors) {
        if (!this._ballPredictor) this._ballPredictor = new BallPredictor();
        
        const teammates = (world?.agents || []).filter(a =>
            a?.alive && a.team === this.team && a.id !== this.id
        );
        
        let bestTarget = null;
        let bestScore = -Infinity;
        
        for (const teammate of teammates) {
            const lead = this._ballPredictor.calculatePassLead(this, teammate, world);
            if (!lead || lead.confidence < 0.4) continue;
            
            const opponents = (world.agents || []).filter(e => e.team !== this.team && e.alive);
            let interceptionRisk = 0;
            
            for (const opp of opponents) {
                const oppIntercept = this._ballPredictor.calculateIntercept(opp, {
                    x: this.x, y: this.y,
                    vx: Math.cos(Math.atan2(lead.y - this.y, lead.x - this.x)) * lead.power,
                    vy: Math.sin(Math.atan2(lead.y - this.y, lead.x - this.x)) * lead.power
                }, world);
                
                if (oppIntercept?.feasible && oppIntercept.t < lead.flightTime + 10) {
                    interceptionRisk = Math.max(interceptionRisk, 1 - oppIntercept.t / lead.flightTime);
                }
            }
            
            if (interceptionRisk > 0.7) continue;
            
            let score = 0;
            score += lead.confidence * 0.4;
            score += (1 - interceptionRisk) * 0.3;
            score += teammate.stamina / 100 * 0.15;
            score += behaviors.coordinationSignal * 0.15;
            
            if (teammate.role === 'forward' && lead.x > FOOTBALL_CONFIG.FIELD_WIDTH * 0.7) {
                score += 0.2;
            }
            
            if (score > bestScore) {
                bestScore = score;
                bestTarget = {
                    target: teammate,
                    leadPoint: { x: lead.x, y: lead.y },
                    power: lead.power,
                    confidence: lead.confidence * (1 - interceptionRisk * 0.5),
                    flightTime: lead.flightTime
                };
            }
        }
        
        return bestTarget;
    }

    _calculateSupportPosition(world, phase) {
        if (!this._sharedMap || !arenaConfig.enableProfessional) {
            return this._getRolePosition(world);
        }
        
        const ball = world?.ball;
        if (!ball) return this._getRolePosition(world);
        
        let bestPos = this._getRolePosition(world);
        let bestScore = this._sharedMap.evaluatePosition(bestPos.x, bestPos.y, this.role);
        
        const directions = [
            { dx: 1, dy: 0 }, { dx: -1, dy: 0 }, { dx: 0, dy: 1 }, { dx: 0, dy: -1 },
            { dx: 1, dy: 1 }, { dx: -1, dy: 1 }, { dx: 1, dy: -1 }, { dx: -1, dy: -1 }
        ];
        
        const scanRadius = phase === 'attack' ? 100 : 60;
        
        for (const dir of directions) {
            const testX = this.x + dir.dx * scanRadius;
            const testY = this.y + dir.dy * scanRadius;
            
            if (testX < 30 || testX > FOOTBALL_CONFIG.FIELD_WIDTH - 30 ||
                testY < 30 || testY > FOOTBALL_CONFIG.FIELD_HEIGHT - 30) continue;
            
            const score = this._sharedMap.evaluatePosition(testX, testY, this.role);
            
            if (score > bestScore) {
                bestScore = score;
                bestPos = { x: testX, y: testY };
            }
        }
        
        return bestPos;
    }

    _decideDefend(world, behaviors, ballState) {
        const idealPosition = this._calculateSupportPosition(world, 'defend');
        return {
            intent: 'defend', target: idealPosition,
            angle: Math.atan2(idealPosition.y - this.y, idealPosition.x - this.x),
            pressIntensity: behaviors.defensivePosture
        };
    }

    _decideTransition(world, behaviors, ballState) {
        const ball = world?.ball;
        if (!ball) return this._decideNeutral(world, behaviors);
        
        const intercept = this._ballPredictor?.calculateIntercept(this, ball, world);
        if (intercept?.feasible) {
            return {
                intent: 'intercept',
                target: { x: intercept.x, y: intercept.y },
                angle: Math.atan2(intercept.y - this.y, intercept.x - this.x)
            };
        }
        
        return this._decideNeutral(world, behaviors);
    }

    _decideNeutral(world, behaviors) {
        const idealPosition = this._getRolePosition(world);
        return {
            intent: 'position', target: idealPosition,
            angle: Math.atan2(idealPosition.y - this.y, idealPosition.x - this.x)
        };
    }

    _getDefaultOutput(outputIdx, role) {
        const defaults = [0.3, 0, 0.1, 0.2, 0.3, 0.5, 0.4, 0.5, 0.5, 0, 0.5, 0.5, 0.1, 0.1, 0.1, 0.1];
        return defaults[outputIdx] ?? 0.5;
    }

    _getRolePosition(world) {
        const fieldWidth = FOOTBALL_CONFIG.FIELD_WIDTH;
        const fieldHeight = FOOTBALL_CONFIG.FIELD_HEIGHT;
        const isBlue = this.team === 'blue';
        
        const positions = {
            goalkeeper: isBlue ? { x: 30, y: fieldHeight / 2 } : { x: fieldWidth - 30, y: fieldHeight / 2 },
            defender: isBlue ? { x: fieldWidth * 0.25, y: fieldHeight / 2 } : { x: fieldWidth * 0.75, y: fieldHeight / 2 },
            midfielder: isBlue ? { x: fieldWidth * 0.45, y: fieldHeight / 2 } : { x: fieldWidth * 0.55, y: fieldHeight / 2 },
            forward: isBlue ? { x: fieldWidth * 0.65, y: fieldHeight / 2 } : { x: fieldWidth * 0.35, y: fieldHeight / 2 }
        };
        
        const base = positions[this.role] || positions.midfielder;
        const playerNum = parseInt(this.id.split('_')[1]) || 0;
        const formationSpread = fieldHeight / 6;
        const teamSize = world?.agents?.filter(a => a.team === this.team).length || 1;
        const yOffset = (playerNum - teamSize/2) * formationSpread;
        
        return {
            x: base.x + this._formationOffset.x,
            y: Utils.clamp(base.y + yOffset + this._formationOffset.y, 50, fieldHeight - 50)
        };
    }

    // FIX #8: Movement with inertia and momentum
    move(decision, walls, dt, otherAgents) {
        if (!isFinite(this.x) || !isFinite(this.y)) { this.x = 410; this.y = 300; }
        if (!isFinite(this.vx) || !isFinite(this.vy)) { this.vx = 0; this.vy = 0; }
        if (!isFinite(this.facingAngle)) { this.facingAngle = 0; }
        
        const b = decision.behaviors;
        const speedMultiplier = b.sprint > 0.7 ? 1.5 : 1.0;
        const baseMoveForce = arenaConfig.agentAcceleration * arenaConfig.agentSpeed * speedMultiplier;
        
        // PROFESSIONAL MOVEMENT: Use intent to determine target
        let targetPos = null;
        let movePriority = 'none';
        let moveForce = baseMoveForce;
        
        const lastDec = this.lastDecision;
        
        // 1. If we have ball or near ball - execute intent
        if ((lastDec?.hasBall || lastDec?.ballDist < 40) && lastDec?.intent) {
            if (lastDec.intent === 'shoot' && lastDec.target) {
                targetPos = { 
                    x: lastDec.target.x - Math.cos(lastDec.angle) * 30,
                    y: lastDec.target.y - Math.sin(lastDec.angle) * 30
                };
                movePriority = 'shoot_position';
            }
            else if (lastDec.intent === 'pass' && lastDec.interceptPoint) {
                targetPos = lastDec.interceptPoint;
                movePriority = 'pass_position';
            }
            else if (lastDec.intent === 'dribble' && lastDec.target) {
                targetPos = lastDec.target;
                movePriority = 'dribble';
            }
        }
        
        // 2. If ball is free - chase it
        else if (lastDec?.ballState === 'free_clear' || lastDec?.ballState === 'free_contested') {
            if (this.world?.ball) {
                if (this._ballPredictor && arenaConfig.enableProfessional) {
                    const intercept = this._ballPredictor.calculateIntercept(this, this.world.ball, this.world);
                    if (intercept.feasible) {
                        targetPos = { x: intercept.x, y: intercept.y };
                        movePriority = 'intercept';
                    }
                }
                
                if (!targetPos) {
                    targetPos = { x: this.world.ball.x, y: this.world.ball.y };
                    movePriority = 'chase_ball';
                }
            }
        }
        
        // 3. If enemy has ball
        else if (lastDec?.ballState === 'enemy_owned') {
            if (this.role === 'defender' || this.role === 'goalkeeper') {
                targetPos = this._getRolePosition(this.world);
                movePriority = 'defensive_position';
            }
            else if (this.role === 'forward' || this.role === 'midfielder') {
                const ballOwner = this.world.agents.find(a => a.id === this.world.ball.owner);
                if (ballOwner) {
                    const dx = this.x - ballOwner.x;
                    const dy = this.y - ballOwner.y;
                    const dist = Math.hypot(dx, dy);
                    if (dist > 50) {
                        targetPos = { 
                            x: ballOwner.x + (dx/dist) * 50,
                            y: ballOwner.y + (dy/dist) * 50
                        };
                        movePriority = 'pressing';
                    }
                }
            }
        }
        
        // 4. Support positions
        if (!targetPos && lastDec?.intent === 'support_attack' && lastDec?.target) {
            targetPos = lastDec.target;
            movePriority = 'support';
        }
        
        // 5. Default to role position
        if (!targetPos) {
            if (this._sharedMap && arenaConfig.enableProfessional) {
                const phase = lastDec?.gamePhase || 'neutral';
                targetPos = this._calculateSupportPosition(this.world, phase);
                movePriority = 'smart_position';
            } else {
                targetPos = this._getRolePosition(this.world);
                movePriority = 'role_position';
            }
        }
        
        // FIX #8: Execute movement with inertia
        if (targetPos) {
            const dx = targetPos.x - this.x;
            const dy = targetPos.y - this.y;
            const distToTarget = Math.hypot(dx, dy);
            
            const targetAngle = Math.atan2(dy, dx);
            const angleDiff = Utils.normalizeAngle(targetAngle - this.facingAngle);
            
            const turnSpeed = 0.2;
            this.facingAngle += Utils.clamp(angleDiff, -turnSpeed, turnSpeed);
            this.facingAngle = Utils.normalizeAngle(this.facingAngle);
            
            if (distToTarget > 5) {
                moveForce = baseMoveForce * Math.max(0, b.moveForward);
            } else {
                moveForce = 0;
            }
        } else {
            const turnForce = b.turn * 0.15;
            this.facingAngle += turnForce;
            this.facingAngle = Utils.normalizeAngle(this.facingAngle);
            moveForce = baseMoveForce * Math.max(0, b.moveForward);
        }
        
        // FIX #8: Apply force with inertia (not instant velocity change)
        const desiredVx = Math.cos(this.facingAngle) * moveForce;
        const desiredVy = Math.sin(this.facingAngle) * moveForce;
        
        // Smooth acceleration toward desired velocity
        this.vx = Utils.lerp(this.vx, desiredVx, 0.15);
        this.vy = Utils.lerp(this.vy, desiredVy, 0.15);
        
        // Apply friction/damping
        this.vx *= arenaConfig.agentFriction;
        this.vy *= arenaConfig.agentFriction;
        
        // Clamp to max velocity
        const velSq = this.vx*this.vx + this.vy*this.vy;
        const maxVelSq = arenaConfig.agentMaxVelocity * arenaConfig.agentMaxVelocity;
        if (velSq > maxVelSq) {
            const scale = arenaConfig.agentMaxVelocity / Math.sqrt(velSq);
            this.vx *= scale;
            this.vy *= scale;
        }
        
        // Update position
        this.x += this.vx * dt;
        this.y += this.vy * dt;
        
        // Boundary constraints
        const r = arenaConfig.agentCollisionRadius;
        this.x = Utils.clamp(this.x, r, FOOTBALL_CONFIG.FIELD_WIDTH - r);
        this.y = Utils.clamp(this.y, r, FOOTBALL_CONFIG.FIELD_HEIGHT - r);
        
        // Agent-agent collisions
        if (otherAgents?.length) {
            for (const other of otherAgents) {
                if (other.id === this.id || !other.alive) continue;
                const dx = other.x - this.x;
                const dy = other.y - this.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                const minDist = arenaConfig.agentCollisionRadius * 2;
                if (dist < minDist && dist > 0.001) {
                    const nx = dx / dist, ny = dy / dist;
                    const penetration = minDist - dist;
                    const separation = penetration * 0.5;
                    this.x -= nx * separation;
                    this.y -= ny * separation;
                    other.x += nx * separation;
                    other.y += ny * separation;
                    const relVelX = this.vx - other.vx;
                    const relVelY = this.vy - other.vy;
                    const relVelNormal = relVelX * nx + relVelY * ny;
                    if (relVelNormal < 0) {
                        const impulse = relVelNormal * arenaConfig.PHYSICS.COLLISION_ELASTICITY;
                        this.vx -= impulse * nx;
                        this.vy -= impulse * ny;
                        other.vx += impulse * nx;
                        other.vy += impulse * ny;
                    }
                }
            }
        }
        
        if (!isFinite(this.x) || !isFinite(this.y)) { this.x = 410; this.y = 300; }
        
        this.velocity.x = this.vx;
        this.velocity.y = this.vy;
        
        const moved = Math.hypot(this.x - this.lastPos.x, this.y - this.lastPos.y);
        this._distanceCovered += moved;
        
        // FIX #8: Track velocity history for momentum calculations
        this._velocityHistory.push({ vx: this.vx, vy: this.vy });
        if (this._velocityHistory.length > this._maxVelocityHistory) {
            this._velocityHistory.shift();
        }
    }

    calculateReward(world, decision) {
        if (!world || !world.ball) return 0;
        if (!decision) return 0;
        
        let reward = 0;
        const role = FOOTBALL_ROLES[this.role];
        const ballState = this._getBallState(world);
        const gamePhase = this._determineGamePhase(world);
        
        // Reward for proximity to ball
        const distToBall = Utils.dist(this, world.ball);
        const maxViewDist = arenaConfig.viewRadius;
        const proximityReward = (1 - distToBall / maxViewDist) * 0.05; 
        reward += proximityReward;

        // Penalty for spinning in place
        const moved = Math.hypot(this.x - this.lastPos.x, this.y - this.lastPos.y);
        const rotated = Math.abs(Utils.normalizeAngle(this.facingAngle - this._prevFacingAngle));
        
        if (moved < 0.5 && rotated > 0.5) {
            reward -= 0.05;
        }

        if (ballState === 'owned') {
            const enemyGoal = this.team === 'blue' ?
                { x: FOOTBALL_CONFIG.FIELD_WIDTH, y: FOOTBALL_CONFIG.GOAL_Y } :
                { x: 0, y: FOOTBALL_CONFIG.GOAL_Y };
            const dist = Utils.dist(this, enemyGoal);
            const progress = isFinite(dist) ? 1 - dist / 600 : 0.5;
            reward += progress * 0.08 * (role?.priority?.offense || 0.5);
            
            if (decision.intent === 'pass' && this._lastPassSuccessful) {
                reward += 0.25;
                this._lastPassSuccessful = false;
            }
        } else if (ballState === 'free_clear') {
            reward += 0.15;
            if (distToBall < this.lastDistToBall) {
                reward += 0.02;
            }
        }
        
        this.lastDistToBall = distToBall;
        this._prevFacingAngle = this.facingAngle;
        this.lastPos = { x: this.x, y: this.y };
        
        return isFinite(reward) ? Utils.clamp(reward, -0.5, 0.5) : 0;
    }

    learn(reward, decision, nextInputs = null) {
        if (!arenaConfig.enableTraining) return;
        if (!decision || !decision.inputs) return;
        
        const safeReward = isFinite(reward) ? reward : 0;
        
        if (nextInputs && !nextInputs.every(v => isFinite(v))) {
            nextInputs = null;
        }
        
        const currentValue = decision.value;
        const nextValue = nextInputs ? this.critic.forward(nextInputs) : 0;
        const criticResult = this.critic.update(decision.inputs, safeReward, nextValue);
        const tdResult = this.net.tdLearn(decision.inputs, decision.output, safeReward, currentValue, nextValue, decision.modeProbs ? Utils.logSoftmax(decision.modeProbs, 1) : null);
        this.net.updateDiagnostics({ win: null, collected: false, survival: this.health / this.stats.maxHealth, reward: safeReward });
        if (safeReward > 3 && arenaConfig.enableSkillEvolution) this.updatePermanentSkills(safeReward, decision.mode, arenaConfig.skillGrowthRate);
        if (safeReward > 4) this.updateMuscleMemory(decision.output, safeReward);
        this.learningBuffer.states.push(decision.inputs);
        this.learningBuffer.actions.push(decision.output);
        this.learningBuffer.rewards.push(safeReward);
        this.learningBuffer.values.push(currentValue);
        if (this.learningBuffer.states.length >= this.learningBuffer.maxBuffer) this._batchLearn();
    }

    _batchLearn() {
        if (!arenaConfig.enableTraining) { this._clearLearningBuffer(); return; }
        const advantages = Utils.computeGAE(this.learningBuffer.rewards, this.learningBuffer.values, 0, this.net.gamma, this.net.lambda);
        for (let t = 0; t < advantages.length; t++) {
            if (this.lastDecision?.modeProbs && arenaConfig.enablePolicySelector) {
                const modeIdx = 0;
                const enemies = (this._lastWorld?.agents || []).filter(e => e && e.id !== this.id && e.alive && e.team !== this.team);
                const context = [
                    enemies.length > 0 ? Utils.clamp(Utils.dist(this, enemies[0]?.agent || enemies[0]) / 200, 0, 1) : 1,
                    (this._lastWorld?.walls || []).length ? Utils.clamp(Math.min(...this._lastWorld.walls.map(w => Utils.dist(this, w))) / 60, 0, 1) : 0,
                    this.health / this.stats.maxHealth,
                    Utils.clamp(Utils.safeNumber(this.lastDecision.output?.[5], 0.5), 0, 1),
                    Utils.clamp(Utils.safeNumber(this.lastDecision.output?.[6], 0.5), 0, 1),
                    Utils.clamp(Utils.safeNumber(this.lastDecision.output?.[7], 0.5), 0, 1),
                    this.permanent.skills.passing,
                    this.permanent.skills.shooting
                ];
            }
        }
        this._clearLearningBuffer();
    }

    _clearLearningBuffer() {
        this.learningBuffer = { states: [], actions: [], rewards: [], nextStates: [], dones: [], values: [], maxBuffer: 32 };
        this._lastWorld = null;
    }

    updatePermanentSkills(reward, mode, skillGrowthRate) {
        if (reward <= 3 || !arenaConfig.enableSkillEvolution) return;
        const skillKey = 'passing';
        if (skillKey && this.permanent.skills[skillKey] !== undefined) {
            const growth = skillGrowthRate * reward * arenaConfig.EVOLUTION.COMBAT_SKILL_GROWTH;
            this.permanent.skills[skillKey] = Utils.clamp(this.permanent.skills[skillKey] + growth, 0, 1);
            this.skillEmbedding = [
                this.permanent.skills.passing,
                this.permanent.skills.shooting,
                this.permanent.skills.defending,
                this.permanent.skills.positioning,
                this.permanent.skills.stamina
            ];
        }
    }

    updateMuscleMemory(outputs, reward) {
        if (reward < 4) return;
        for (let i = 0; i < Math.min(16, outputs.length); i++) {
            const diff = Math.abs(outputs[i] - this.permanent.muscleMemory[i]);
            if (diff > 0.12 && Math.abs(outputs[i]) > 0.4) {
                this.permanent.muscleMemory[i] = Utils.lerp(this.permanent.muscleMemory[i], outputs[i], 0.08);
            }
        }
    }

    evolve(mutationRate = 0.1) {
        if (!arenaConfig.enableEvolution) return 0;
        const mutations = this.net.mutate(mutationRate, 0.15);
        if (this.critic?._W1) {
            this.critic._W1.forEach(row => {
                if (!row) return;
                row.forEach((v, i) => {
                    if (this.net._rng.next() < mutationRate) {
                        row[i] += (this.net._rng.next() * 2 - 1) * 0.15;
                        row[i] = Utils.clamp(row[i], -2, 2);
                    }
                });
            });
        }
        this.mutations += mutations;
        return mutations;
    }

    reset(x, y) {
        this.net.restoreEmotionalMemory();
        this.x = x; this.y = y;
        this.vx = 0; this.vy = 0;
        this.velocity = { x: 0, y: 0 };
        this.health = this.stats.maxHealth;
        this.stamina = 100;
        this.stuckCounter = 0;
        this.lastPos = { x, y };
        this.cumulativeReward = 0;
        this.mode = 'football';
        this.target = { x, y };
        this.trail = [];
        this.predictive.confidence = 0.5;
        this.predictive.predictionError = 0;
        this._kickCooldown = 0;
        this._clearLearningBuffer();
        this.predictive.shortTerm = { positions: [], actions: [], results: [], ballHistory: [] };
        this._lastKickDealt = 0;
        this._ballPossessionTime = 0;
        this._distanceCovered = 0;
        this.facingAngle = 0;
        this._passTarget = null;
        this._shotTarget = null;
        this._combatEvents = [];
        this.mentalMap = {
            ball: { x: 0, y: 0, vx: 0, vy: 0, owner: null, confidence: 0, lastSeen: 0, predictedX: 0, predictedY: 0, velocityHistory: [] },
            teammates: new Map(),
            opponents: new Map(),
            goal: { x: 0, y: 0, myGoalX: 0, myGoalY: 0, angle: 0, distance: 0, shootingAngle: 0 },
            teamStats: { averagePosition: { x: 0, y: 0 }, formationIntact: true, possession: false, attackingPhase: false, defensiveLine: 0, pressureLevel: 0 },
            spatialAnalysis: { freeZones: [], dangerZones: [], passingLanes: [], coverage: 0 },
            lastUpdate: 0,
            currentIntent: 'none',
            incomingPass: null
        };
        this._idleFrames = 0;
        this._lastPassSuccessful = false;
        this.lastDistToBall = 999;
        this._prevFacingAngle = 0;
        this._velocityHistory = [];
    }

    getLearningMetrics() {
        return {
            avgTDError: this.net._stats?.tdErrorHistory?.reduce((a,b)=>a+b,0)/Math.max(1,this.net._stats?.tdErrorHistory?.length || 1) || 0,
            avgPredictionError: this.net._computeAvgPredError?.() || 0,
            winRate: this.wins / Math.max(1, this.wins + this.deaths),
            passAccuracy: this.passStats.successful / Math.max(1, this.passStats.total),
            shotAccuracy: this.shotsOnTarget / Math.max(1, this.totalKicks),
            goalRate: this.goals / Math.max(1, this.totalKicks)
        };
    }

    draw(ctx, showVision = false, showTrail = true) {
        if (!isFinite(this.x) || !isFinite(this.y)) return;
        if (!isFinite(this.facingAngle)) return;
        
        if (showTrail && this.trail.length > 1) {
            ctx.beginPath();
            ctx.moveTo(this.trail[0].x, this.trail[0].y);
            for (let i = 1; i < this.trail.length; i++) {
                const t = this.trail[i];
                if (!isFinite(t.x) || !isFinite(t.y)) continue;
                const alpha = 1 - t.age / 80;
                ctx.strokeStyle = this.color + Math.floor(alpha * 40).toString(16).padStart(2, '0');
                ctx.lineTo(t.x, t.y);
            }
            ctx.stroke();
        }
        
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.facingAngle);
        
        let drawColor = this.color;
        if (this._sprintActive) drawColor = '#ffff00';
        
        ctx.fillStyle = drawColor;
        ctx.beginPath();
        ctx.moveTo(this.bodyVertices[0].x, this.bodyVertices[0].y);
        for (let i = 1; i < this.bodyVertices.length; i++) {
            ctx.lineTo(this.bodyVertices[i].x, this.bodyVertices[i].y);
        }
        ctx.closePath();
        ctx.fill();
        
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        ctx.fillStyle = '#fff';
        ctx.font = '10px monospace';
        ctx.textAlign = 'center';
        ctx.fillText(this.role.substring(0, 3).toUpperCase(), 0, -30);
        
        ctx.restore();
        
        ctx.fillStyle = '#222';
        ctx.fillRect(this.x - 22, this.y - 38, 44, 4);
        ctx.fillStyle = this.stamina > 50 ? '#00ff9d' : '#ff5577';
        ctx.fillRect(this.x - 22, this.y - 38, 44 * (this.stamina / 100), 4);
        
        // FIX #9: Only show possession indicator if ball is ACTUALLY close
        if (this.world?.ball && this.world.ball.owner === this.id) {
            const ballDist = Utils.dist(this, this.world.ball);
            if (ballDist < (this.stats?.kickRange || 35) + 5) {
                ctx.strokeStyle = '#ffff00';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(this.x, this.y, FootballAgent.VISUAL_RADIUS + 5, 0, Math.PI * 2);
                ctx.stroke();
            }
        }
        
        if (showVision) {
            const viewRadius = arenaConfig.viewRadius || 300;
            
            ctx.strokeStyle = 'rgba(0, 255, 157, 0.3)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(this.x, this.y, viewRadius, 0, Math.PI * 2);
            ctx.stroke();
            
            if (this.world?.ball) {
                ctx.strokeStyle = 'rgba(255, 255, 0, 0.5)';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(this.world.ball.x, this.world.ball.y);
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            if (this._passTarget) {
                ctx.strokeStyle = 'rgba(0, 212, 255, 0.6)';
                ctx.lineWidth = 2;
                ctx.setLineDash([3, 3]);
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(this._passTarget.x, this._passTarget.y);
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            if (this._defensivePosition) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.beginPath();
                ctx.arc(this._defensivePosition.x, this._defensivePosition.y, 10, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        if (this.trail.length === 0 || this.trail[this.trail.length - 1].age > 4) {
            if (isFinite(this.x) && isFinite(this.y)) {
                this.trail.push({ x: this.x, y: this.y, age: 0 });
                if (this.trail.length > 35) this.trail.shift();
            }
        }
        this.trail.forEach(t => t.age++);
        
        if (window.arenaGame?.debug) {
            ctx.strokeStyle = 'rgba(255,255,0,0.4)';
            ctx.setLineDash([3, 2]);
            ctx.beginPath();
            ctx.arc(this.x, this.y, arenaConfig.agentCollisionRadius, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);
        }
    }

    getDebugInfo() {
        const metrics = this.getLearningMetrics();
        const D = this.lastDecision?.output || [];
        return {
            role: this.role,
            mode: this.lastDecision?.mode || '‚Äî',
            intent: this.lastDecision?.intent || '‚Äî',
            stamina: `${Math.round(this.stamina)}%`,
            ballDist: this.lastDecision?.ballDist?.toFixed(1) || '‚Äî',
            hasBall: this.lastDecision?.hasBall ? 'YES' : 'NO',
            D0_forward: D[0]?.toFixed(2) || '‚Äî',
            D1_turn: D[1]?.toFixed(2) || '‚Äî',
            D2_kick: D[2]?.toFixed(2) || '‚Äî',
            D3_sprint: D[3]?.toFixed(2) || '‚Äî',
            D4_pass: D[4]?.toFixed(2) || '‚Äî',
            D5_position: D[5]?.toFixed(2) || '‚Äî',
            D6_defend: D[6]?.toFixed(2) || '‚Äî',
            D7_coord: D[7]?.toFixed(2) || '‚Äî',
            passes: this.passStats.successful + '/' + this.passStats.total,
            shots: this.shotsOnTarget,
            goals: this.goals,
            tdError: metrics.avgTDError.toFixed(4),
            passAcc: metrics.passAccuracy.toFixed(2)
        };
    }

    clone() {
        const agent = new FootballAgent(
            this.id, this.x, this.y, this.color,
            this.seed + '_clone_' + Date.now(),
            this.role, this.team
        );
        agent.net = this.net.clone();
        agent.critic = this.critic.clone();
        agent.health = this.health;
        agent.stats = { ...this.stats };
        agent.cumulativeReward = this.cumulativeReward;
        agent.wins = this.wins;
        agent.totalKicks = this.totalKicks;
        agent.successfulPasses = this.successfulPasses;
        agent.shotsOnTarget = this.shotsOnTarget;
        agent.goals = this.goals;
        agent.deaths = this.deaths;
        agent.mutations = this.mutations;
        agent.generation = this.generation + 1;
        agent.permanent = {
            skills: { ...this.permanent.skills },
            strategies: { ...this.permanent.strategies },
            preferences: { ...this.permanent.preferences },
            muscleMemory: new Float32Array(this.permanent.muscleMemory),
            memory: {
                lastBallPos: this.permanent.memory.lastBallPos ? { ...this.permanent.memory.lastBallPos } : null,
                lastBallStep: this.permanent.memory.lastBallStep || 0,
                visited: new Set(this.permanent.memory.visited),
                unvisited: this.permanent.memory.unvisited.map(p => ({ ...p }))
            }
        };
        agent.predictive = {
            shortTerm: { positions: [], actions: [], results: [], ballHistory: [] },
            predictions: { ballPos: { x: 0, y: 0 }, interceptPos: { x: 0, y: 0 }, success: 0.5 },
            confidence: this.predictive.confidence,
            predictionError: this.predictive.predictionError
        };
        agent.skillEmbedding = this.skillEmbedding.slice();
        agent.evolutionPoints = this.evolutionPoints;
        agent._lastKickDealt = this._lastKickDealt;
        agent._kickCooldown = this._kickCooldown;
        agent._ballPossessionTime = this._ballPossessionTime;
        agent._distanceCovered = this._distanceCovered;
        agent.facingAngle = this.facingAngle;
        agent.velocity = { ...this.velocity };
        agent.mentalMap = {
            ball: { ...this.mentalMap.ball },
            teammates: new Map(this.mentalMap.teammates),
            opponents: new Map(this.mentalMap.opponents),
            goal: { ...this.mentalMap.goal },
            teamStats: { ...this.mentalMap.teamStats },
            spatialAnalysis: { ...this.mentalMap.spatialAnalysis },
            lastUpdate: this.mentalMap.lastUpdate,
            currentIntent: this.mentalMap.currentIntent,
            incomingPass: this.mentalMap.incomingPass
        };
        agent.assignedPosition = { ...this.assignedPosition };
        agent._formationOffset = { ...this._formationOffset };
        agent.passStats = { ...this.passStats };
        agent.lastDistToBall = this.lastDistToBall;
        agent._prevFacingAngle = this._prevFacingAngle;
        agent._velocityHistory = [...this._velocityHistory];
        return agent;
    }

    toJSON() {
        return {
            id: this.id, seed: this.seed, x: this.x, y: this.y, team: this.team, role: this.role,
            health: this.health, stamina: this.stamina, stats: this.stats,
            cumulativeReward: this.cumulativeReward, wins: this.wins, totalKicks: this.totalKicks,
            successfulPasses: this.successfulPasses, shotsOnTarget: this.shotsOnTarget,
            goals: this.goals, deaths: this.deaths, mutations: this.mutations, generation: this.generation,
            net: this.net.toJSON(), critic: this.critic.toJSON(),
            permanent: {
                skills: this.permanent.skills, strategies: this.permanent.strategies,
                preferences: this.permanent.preferences,
                muscleMemory: Array.from(this.permanent.muscleMemory),
                memory: {
                    lastBallPos: this.permanent.memory.lastBallPos,
                    lastBallStep: this.permanent.memory.lastBallStep,
                    visited: Array.from(this.permanent.memory.visited).slice(0, 100),
                    unvisited: this.permanent.memory.unvisited.slice(0, 30)
                }
            },
            skillEmbedding: this.skillEmbedding.slice(),
            evolutionPoints: this.evolutionPoints,
            _lastKickDealt: this._lastKickDealt, _kickCooldown: this._kickCooldown,
            _ballPossessionTime: this._ballPossessionTime, _distanceCovered: this._distanceCovered,
            facingAngle: this.facingAngle, velocity: this.velocity,
            mentalMap: {
                ball: this.mentalMap.ball,
                teammates: Array.from(this.mentalMap.teammates.entries()).map(([k,v]) => [k, {...v}]),
                opponents: Array.from(this.mentalMap.opponents.entries()).map(([k,v]) => [k, {...v}]),
                goal: this.mentalMap.goal, teamStats: this.mentalMap.teamStats,
                spatialAnalysis: this.mentalMap.spatialAnalysis, lastUpdate: this.mentalMap.lastUpdate,
                currentIntent: this.mentalMap.currentIntent, incomingPass: this.mentalMap.incomingPass
            },
            assignedPosition: this.assignedPosition, _formationOffset: this._formationOffset,
            passStats: this.passStats,
            lastDistToBall: this.lastDistToBall,
            _prevFacingAngle: this._prevFacingAngle
        };
    }

    static fromJSON(data, color) {
        const team = data.team || (data.id?.startsWith('red') ? 'red' : 'blue');
        const agent = new FootballAgent(data.id, data.x, data.y, color, data.seed, data.role || 'midfielder', team);
        agent.net = Cortex2Brain.fromJSON(data.net);
        if (data.critic) agent.critic = CriticNetwork.fromJSON(data.critic);
        agent.health = data.health ?? 100;
        agent.stamina = data.stamina ?? 100;
        agent.stats = data.stats || { maxHealth: 100, kickPower: 10, speed: 10, accuracy: 0.7, stamina: 100, kickRange: 35 };
        agent.cumulativeReward = data.cumulativeReward ?? 0;
        agent.wins = data.wins ?? 0;
        agent.totalKicks = data.totalKicks ?? 0;
        agent.successfulPasses = data.successfulPasses ?? 0;
        agent.shotsOnTarget = data.shotsOnTarget ?? 0;
        agent.goals = data.goals ?? 0;
        agent.deaths = data.deaths ?? 0;
        agent.mutations = data.mutations ?? 0;
        agent.generation = data.generation ?? 1;
        if (data.permanent) {
            agent.permanent.skills = { ...(data.permanent.skills || agent.permanent.skills) };
            agent.permanent.strategies = { ...(data.permanent.strategies || agent.permanent.strategies) };
            agent.permanent.preferences = { ...(data.permanent.preferences || agent.permanent.preferences) };
            if (data.permanent.muscleMemory) agent.permanent.muscleMemory = new Float32Array(data.permanent.muscleMemory);
            if (data.permanent.memory) {
                agent.permanent.memory.lastBallPos = data.permanent.memory.lastBallPos;
                agent.permanent.memory.lastBallStep = data.permanent.memory.lastBallStep || 0;
                agent.permanent.memory.visited = new Set(data.permanent.memory.visited || []);
                agent.permanent.memory.unvisited = data.permanent.memory.unvisited || [];
            }
        }
        if (data.skillEmbedding) agent.skillEmbedding = data.skillEmbedding.slice();
        if (data.evolutionPoints !== undefined) agent.evolutionPoints = data.evolutionPoints;
        if (data._lastKickDealt !== undefined) agent._lastKickDealt = data._lastKickDealt;
        if (data._kickCooldown !== undefined) agent._kickCooldown = data._kickCooldown;
        if (data._ballPossessionTime !== undefined) agent._ballPossessionTime = data._ballPossessionTime;
        if (data._distanceCovered !== undefined) agent._distanceCovered = data._distanceCovered;
        if (data.facingAngle !== undefined) agent.facingAngle = data.facingAngle;
        if (data.velocity) agent.velocity = { ...data.velocity };
        if (data.mentalMap) {
            agent.mentalMap.ball = data.mentalMap.ball || { x: 0, y: 0, vx: 0, vy: 0, owner: null, confidence: 0, lastSeen: 0, predictedX: 0, predictedY: 0, velocityHistory: [] };
            agent.mentalMap.teammates = new Map(data.mentalMap.teammates?.map(([k,v]) => [k, {...v}]) || []);
            agent.mentalMap.opponents = new Map(data.mentalMap.opponents?.map(([k,v]) => [k, {...v}]) || []);
            agent.mentalMap.goal = data.mentalMap.goal || { x: 0, y: 0, myGoalX: 0, myGoalY: 0, angle: 0, distance: 0, shootingAngle: 0 };
            agent.mentalMap.teamStats = data.mentalMap.teamStats || { averagePosition: { x: 0, y: 0 }, formationIntact: true, possession: false, attackingPhase: false, defensiveLine: 0, pressureLevel: 0 };
            agent.mentalMap.spatialAnalysis = data.mentalMap.spatialAnalysis || { freeZones: [], dangerZones: [], passingLanes: [], coverage: 0 };
            agent.mentalMap.lastUpdate = data.mentalMap.lastUpdate || 0;
            agent.mentalMap.currentIntent = data.mentalMap.currentIntent || 'none';
            agent.mentalMap.incomingPass = data.mentalMap.incomingPass || null;
        }
        if (data.assignedPosition) agent.assignedPosition = {...data.assignedPosition};
        if (data._formationOffset) agent._formationOffset = {...data._formationOffset};
        if (data.passStats) agent.passStats = {...data.passStats};
        if (data.lastDistToBall !== undefined) agent.lastDistToBall = data.lastDistToBall;
        if (data._prevFacingAngle !== undefined) agent._prevFacingAngle = data._prevFacingAngle;
        return agent;
    }

    _updateMentalMap(world) {
        const now = world?.step || 0;
        
        if (world?.ball) {
            this.mentalMap.ball = {
                x: world.ball.x, y: world.ball.y,
                vx: world.ball.vx, vy: world.ball.vy,
                owner: world.ball.owner,
                confidence: 1.0, lastSeen: now,
                predictedX: world.ball.x + world.ball.vx * 10,
                predictedY: world.ball.y + world.ball.vy * 10,
                velocityHistory: [...this.mentalMap.ball.velocityHistory, { vx: world.ball.vx, vy: world.ball.vy }].slice(-10)
            };
        }
        
        (world?.agents || []).filter(a => a.team === this.team && a.id !== this.id).forEach(a => {
            this.mentalMap.teammates.set(a.id, {
                x: a.x, y: a.y, stamina: a.stamina, role: a.role,
                confidence: 1.0, lastSeen: now
            });
        });
        
        (world?.agents || []).filter(a => a.team !== this.team).forEach(a => {
            this.mentalMap.opponents.set(a.id, {
                x: a.x, y: a.y, confidence: 1.0, lastSeen: now
            });
        });
        
        this.mentalMap.lastUpdate = now;
    }

    // FIX #2: Check distance BEFORE allowing ball control
    _executeBallControl(world) {
        const decision = this.lastDecision;
        if (!decision) return;
        
        // FIX #2: Verify proximity before any ball interaction
        if (world?.ball && !world.ball.canBeControlledBy(this, world.step)) {
            // Cannot control ball ‚Äî treat as free ball chase
            return;
        }
        
        switch(decision.intent) {
            case 'shoot': this._executeShot(world, decision); break;
            case 'pass': this._executePass(world, decision); break;
            case 'dribble': this._executeDribble(world, decision); break;
            default: this._holdBall(world);
        }
    }

    _executeShot(world, decision) {
        const angle = decision.angle || Math.atan2(decision.target.y - this.y, decision.target.x - this.x);
        const power = decision.power || FOOTBALL_CONFIG.KICK_POWER;
        
        const accuracy = this.stats.accuracy * (0.5 + 0.5 * decision.behaviors?.confidence);
        const angleError = (Math.random() - 0.5) * (1 - accuracy) * 0.4;
        
        // FIX #1: Pass kicker position for proximity validation
        world.ball.kick(angle + angleError, power, this.id, { x: this.x, y: this.y });
        this.totalKicks++;
        this.shotsOnTarget++;
        this._combatEvents.push({ type: 'shot_taken', power, target: decision.target });
        
        this.net.emotions.confidence = Utils.clamp(this.net.emotions.confidence + 0.05, 0, 1);
    }

    _executePass(world, decision) {
        if (!decision.target) return;
        
        const angle = decision.angle;
        const power = decision.power;
        
        // FIX #1: Pass kicker position for proximity validation
        world.ball.kick(angle, power, this.id, { x: this.x, y: this.y });
        this.totalKicks++;
        this.passStats.total++;
        
        this._lastPassTarget = decision.target;
        
        this._combatEvents.push({ 
            type: 'pass_attempt', 
            target: decision.target.id, 
            interceptPoint: decision.interceptPoint,
            confidence: decision.behaviors?.confidence 
        });
        
        if (decision.behaviors?.coordinationSignal > 0.7) {
            this.net.emotions.confidence = Utils.clamp(this.net.emotions.confidence + 0.03, 0, 1);
        }
    }

    _executeDribble(world, decision) {
        const desiredBallOffset = {
            x: Math.cos(this.facingAngle) * 25,
            y: Math.sin(this.facingAngle) * 25
        };
        
        const ballDx = world.ball.x - (this.x + desiredBallOffset.x);
        const ballDy = world.ball.y - (this.y + desiredBallOffset.y);
        const ballDist = Math.hypot(ballDx, ballDy);
        
        if (ballDist > 5) {
            const correctionAngle = Math.atan2(ballDy, ballDx);
            const correctionPower = Utils.clamp(ballDist * 0.3, 1, 4);
            // FIX #1: Pass kicker position for proximity validation
            world.ball.kick(correctionAngle, correctionPower, this.id, { x: this.x, y: this.y });
        }
        
        if (decision.protectBall) {
            const nearestOpp = (world.agents || [])
                .filter(a => a.team !== this.team && a.alive)
                .reduce((nearest, curr) => {
                    const d = Utils.dist(this, curr);
                    return !nearest || d < Utils.dist(this, nearest) ? curr : nearest;
                }, null);
            
            if (nearestOpp) {
                const shieldAngle = Math.atan2(this.y - nearestOpp.y, this.x - nearestOpp.x);
                this.facingAngle = Utils.lerp(this.facingAngle, shieldAngle, 0.1);
            }
        }
    }

    _holdBall(world) {
        const ballDx = world.ball.x - this.x;
        const ballDy = world.ball.y - this.y;
        const ballDist = Math.hypot(ballDx, ballDy);
        
        if (ballDist > 20) {
            const angle = Math.atan2(ballDy, ballDx);
            // FIX #1: Pass kicker position for proximity validation
            world.ball.kick(angle, 2, this.id, { x: this.x, y: this.y });
        }
    }
    
    // FIX: Added missing _isInGoalZone method
    _isInGoalZone() {
        if (this.role !== 'goalkeeper') return false;
        const goalY = FOOTBALL_CONFIG.GOAL_Y;
        const goalHeight = FOOTBALL_CONFIG.GOAL_HEIGHT;
        const goalTop = goalY - goalHeight / 2;
        const goalBottom = goalY + goalHeight / 2;
        
        if (this.team === 'blue') {
            return this.x < 60 && this.y > goalTop && this.y < goalBottom;
        } else {
            return this.x > FOOTBALL_CONFIG.FIELD_WIDTH - 60 && this.y > goalTop && this.y < goalBottom;
        }
    }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// FOOTBALL WORLD ‚Äî PATCHED: Unified ball handling, basic rules
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class FootballWorld {
    constructor(width, height) {
        this.logicalWidth = width;
        this.logicalHeight = height;
        this.step = 0;
        this.episode = 1;
        this.totalGoals = 0;
        this.totalPasses = 0;
        this.agents = [];
        this.ball = new FootballBall(width / 2, height / 2);
        this.score = { blue: 0, red: 0 };
        this.matchTime = 0;
        this.matchDuration = arenaConfig.matchDuration || 600;
        this.isMatchOver = false;
        this.walls = [];
        
        this.teamEmotions = null;
        this.sharedMaps = null;
    }

    reset() {
        this.step = 0;
        this.episode = 1;
        this.totalGoals = 0;
        this.totalPasses = 0;
        this.score = { blue: 0, red: 0 };
        this.matchTime = 0;
        this.isMatchOver = false;
        this.ball.reset(this.logicalWidth / 2, this.logicalHeight / 2);
        this.walls = [];
    }

    spawnAgents(countPerTeam = 3, formation = 'balanced') {
        this.agents = [];
        const colors = { blue: '#00d4ff', red: '#ff5577' };
        const roles = FOOTBALL_CONFIG.FORMATIONS[formation] || FOOTBALL_CONFIG.FORMATIONS.balanced;
        
        const spawnPoints = {
            blue: [
                { x: 100, y: 300 }, { x: 250, y: 200 }, { x: 250, y: 400 },
                { x: 350, y: 250 }, { x: 350, y: 350 }
            ],
            red: [
                { x: 720, y: 300 }, { x: 570, y: 200 }, { x: 570, y: 400 },
                { x: 470, y: 250 }, { x: 470, y: 350 }
            ]
        };
        
        let agentId = 0;
        for (const team of ['blue', 'red']) {
            for (let i = 0; i < countPerTeam; i++) {
                const uniqueSeed = `${arenaConfig.seed}_${team.toUpperCase()}_P${i}_${agentId}`;
                const pos = spawnPoints[team][i % spawnPoints[team].length];
                const role = roles[i % roles.length];
                
                const agent = new FootballAgent(
                    `${team}_${i}`,
                    pos.x + Utils.rand(-20, 20),
                    pos.y + Utils.rand(-20, 20),
                    colors[team],
                    uniqueSeed,
                    role,
                    team
                );
                
                agent._formationOffset = {
                    x: (i % 2 === 0 ? 30 : -30),
                    y: (i - countPerTeam/2) * 50
                };
                
                this.agents.push(agent);
                agentId++;
            }
        }
        
        Logger.log(`‚öΩ Spawned ${this.agents.length} players (${countPerTeam} per team, ${formation})`, 'success');
    }

    initProfessional(teamConfig) {
        const config = teamConfig || {
            enableEmotions: arenaConfig.enableProfessional,
            enablePrediction: arenaConfig.enableProfessional,
            enableSharedMap: arenaConfig.enableProfessional
        };
        
        this.teamEmotions = {
            blue: new TeamEmotionSystem('blue'),
            red: new TeamEmotionSystem('red')
        };
        
        this.sharedMaps = {
            blue: new SharedMentalMap('blue', this.logicalWidth, this.logicalHeight),
            red: new SharedMentalMap('red', this.logicalWidth, this.logicalHeight)
        };
        
        for (const agent of this.agents) {
            if (agent?.alive) {
                agent._initProfessionalSystems(
                    this,
                    this.teamEmotions[agent.team],
                    this.sharedMaps[agent.team]
                );
            }
        }
        
        Logger.log(`‚öôÔ∏è Professional systems initialized: roles, emotions, prediction`, 'success');
    }

    update(dt) {
        if (!isFinite(dt) || dt <= 0) dt = 1;
        dt = Math.min(dt, 2);
        
        if (this.isMatchOver) return;
        
        this.step++;
        this.matchTime = Math.floor(this.step / 60);
        
        if (this.matchTime >= this.matchDuration) {
            this._endMatch();
            return;
        }
        
        const events = this._collectMatchEvents();
        if (this.teamEmotions && arenaConfig.enableProfessional) {
            this.teamEmotions.blue.update(events, this);
            this.teamEmotions.red.update(events, this);
            this.teamEmotions.blue.propagateEmotions(this.agents);
            this.teamEmotions.red.propagateEmotions(this.agents);
        }
        
        if (this.sharedMaps && arenaConfig.enableProfessional) {
            this.sharedMaps.blue.update(this);
            this.sharedMaps.red.update(this);
        }
        
        this.ball.update(dt, this);
        this._checkGoal();
        
        const aliveAgents = (this.agents || []).filter(a => a?.alive);
        
        // FIX #4: Handle ball-player physical collisions FIRST
        for (const agent of aliveAgents) {
            if (agent.alive) {
                this.ball.collideWithPlayer(agent);
            }
        }
        
        for (const agent of aliveAgents) {
            agent.world = this;
            const decision = agent.decide(this);
            agent.move(decision, this.walls, dt, aliveAgents);
            
            const reward = agent.calculateReward(this, decision);
            const nextInputs = agent.getInputs(this);
            const safeReward = isFinite(reward) ? reward : 0;
            
            if (nextInputs && nextInputs.length > 0 && arenaConfig.enableTraining) {
                const validInputs = nextInputs.every(v => isFinite(v));
                if (validInputs) {
                    agent.learn(safeReward, decision, nextInputs);
                }
            }
        }
        
        // FIX #3: Unified professional ball handling only
        this._handleBallInteractionsProfessional();
        
        for (const agent of aliveAgents) {
            agent._combatEvents = [];
        }
    }

    _checkGoal() {
        const goalTop = FOOTBALL_CONFIG.GOAL_Y - FOOTBALL_CONFIG.GOAL_HEIGHT / 2;
        const goalBottom = FOOTBALL_CONFIG.GOAL_Y + FOOTBALL_CONFIG.GOAL_HEIGHT / 2;
        
        if (this.ball.x > FOOTBALL_CONFIG.FIELD_WIDTH - 15 &&
            this.ball.y > goalTop && this.ball.y < goalBottom &&
            this.ball.vx > 0) {
            
            this.score.blue++;
            this.totalGoals++;
            Logger.log(`‚öΩ GOAL! BLUE scores! ${this.score.blue}-${this.score.red}`, 'success');
            this._resetAfterGoal('blue');
            return true;
        }
        
        if (this.ball.x < 15 &&
            this.ball.y > goalTop && this.ball.y < goalBottom &&
            this.ball.vx < 0) {
            
            this.score.red++;
            this.totalGoals++;
            Logger.log(`‚öΩ GOAL! RED scores! ${this.score.blue}-${this.score.red}`, 'success');
            this._resetAfterGoal('red');
            return true;
        }
        
        return false;
    }

    // FIX #3: REMOVED legacy _handleBallInteractions() ‚Äî unified professional system only

    _handleBallInteractionsProfessional() {
        // FIX #1: Ball ownership requires proximity ‚Äî check before allowing control
        if (this.ball.owner) {
            const owner = this.agents.find(a => a.id === this.ball.owner);
            // FIX #1: Verify owner can actually control ball (proximity check)
            if (owner?.alive && owner._kickCooldown <= 0 && this.ball.canBeControlledBy(owner, this.step)) {
                owner._executeBallControl(this);
                owner._kickCooldown = 25;
            } else if (!owner?.alive || !this.ball.canBeControlledBy(owner, this.step)) {
                // FIX #1: Clear ownership if owner dead or too far
                this.ball.owner = null;
            }
            return;
        }
        
        // Ball is free ‚Äî find closest eligible player
        const candidates = this.agents.filter(a => 
            a.alive && 
            Utils.dist(a, this.ball) < (a.stats.kickRange || 35) && 
            a._kickCooldown <= 0
        );
        
        if (candidates.length === 0) return;
        
        candidates.sort((a, b) => {
            const aRolePriority = (a.role === 'goalkeeper' && a._isInGoalZone?.()) ? 10 : 0;
            const bRolePriority = (b.role === 'goalkeeper' && b._isInGoalZone?.()) ? 10 : 0;
            if (aRolePriority !== bRolePriority) return bRolePriority - aRolePriority;
            
            const distA = Utils.dist(a, this.ball);
            const distB = Utils.dist(b, this.ball);
            if (Math.abs(distA - distB) > 5) return distA - distB;
            
            return b.cumulativeReward - a.cumulativeReward;
        });
        
        const controller = candidates[0];
        
        // FIX #1: Set ownership ONLY for proximity-based control logic
        this.ball.owner = controller.id;
        controller._lastTouchTime = this.step;
        
        candidates.forEach(a => {
            if (a !== controller) {
                a._kickCooldown = 15;
            }
        });
        
        if (controller._kickCooldown <= 0) {
            controller._executeBallControl(this);
            controller._kickCooldown = 25;
        }
    }

    _resetAfterGoal(scoringTeam) {
        this.ball.reset(FOOTBALL_CONFIG.FIELD_WIDTH / 2, FOOTBALL_CONFIG.GOAL_Y);
        
        const spawnPoints = {
            blue: [ { x: 100, y: 300 }, { x: 250, y: 200 }, { x: 250, y: 400 } ],
            red: [ { x: 720, y: 300 }, { x: 570, y: 200 }, { x: 570, y: 400 } ]
        };
        
        for (const agent of this.agents) {
            const pos = spawnPoints[agent.team][parseInt(agent.id.split('_')[1]) % spawnPoints[agent.team].length];
            agent.reset(pos.x, pos.y);
        }
    }

    _endMatch() {
        this.isMatchOver = true;
        const winner = this.score.blue > this.score.red ? 'BLUE' :
                       this.score.red > this.score.blue ? 'RED' : 'DRAW';
        Logger.log(`üèÅ MATCH OVER! Winner: ${winner} (${this.score.blue}-${this.score.red})`, 'success');
        
        if (winner !== 'DRAW') {
            const winningTeam = winner === 'BLUE' ? 'blue' : 'red';
            this.agents.filter(a => a.team === winningTeam).forEach(agent => {
                agent.wins++;
                agent.evolutionPoints = 2;
                agent.cumulativeReward += arenaConfig.EVOLUTION.WIN_BONUS;
                agent.net.updateDiagnostics({ kill: true });
            });
        }
        
        const losingTeam = winner === 'BLUE' ? 'red' : 'blue';
        this.agents.filter(a => a.team === losingTeam).forEach(agent => {
            agent.deaths++;
            agent.net.updateDiagnostics({ death: true });
        });
    }

    _collectMatchEvents() {
        const events = [];
        
        if (this.ball.owner) {
            const owner = this.agents.find(a => a.id === this.ball.owner);
            if (owner && owner._lastPassTarget && owner._lastPassTarget?.alive) {
                if (owner.team === owner._lastPassTarget.team && 
                    Utils.dist(this.ball, owner._lastPassTarget) < 30) {
                    events.push({
                        type: 'successful_pass',
                        team: owner.team,
                        from: owner.id,
                        to: owner._lastPassTarget.id,
                        timestamp: this.step
                    });
                    owner._lastPassSuccessful = true;
                    owner._lastPassTarget = null;
                }
            }
        }
        
        return events;
    }

    // Helper for goalkeeper logic
    getGoalkeeper(team) {
        return this.agents.find(a => a.team === team && a.role === 'goalkeeper' && a.alive);
    }
    
    getOpponents(team) {
        return this.agents.filter(a => a.team !== team && a.alive);
    }
    
    getAgent(id) {
        return this.agents.find(a => a.id === id);
    }

    draw(ctx, vision = false, trail = true) {
        if (!ctx) return;
        
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        
        const grad = ctx.createLinearGradient(0, 0, this.logicalWidth, this.logicalHeight);
        grad.addColorStop(0, '#1a4a1a');
        grad.addColorStop(1, '#2a5a2a');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, this.logicalWidth, this.logicalHeight);
        
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
        ctx.lineWidth = 2;
        
        ctx.strokeRect(10, 10, this.logicalWidth - 20, this.logicalHeight - 20);
        
        ctx.beginPath();
        ctx.moveTo(this.logicalWidth / 2, 10);
        ctx.lineTo(this.logicalWidth / 2, this.logicalHeight - 10);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.arc(this.logicalWidth / 2, this.logicalHeight / 2, 50, 0, Math.PI * 2);
        ctx.stroke();
        
        ctx.fillStyle = 'rgba(0, 212, 255, 0.3)';
        ctx.fillRect(0, FOOTBALL_CONFIG.GOAL_Y - FOOTBALL_CONFIG.GOAL_HEIGHT / 2, 10, FOOTBALL_CONFIG.GOAL_HEIGHT);
        ctx.fillStyle = 'rgba(255, 85, 119, 0.3)';
        ctx.fillRect(this.logicalWidth - 10, FOOTBALL_CONFIG.GOAL_Y - FOOTBALL_CONFIG.GOAL_HEIGHT / 2, 10, FOOTBALL_CONFIG.GOAL_HEIGHT);
        
        this.ball.draw(ctx);
        
        for (const agent of this.agents) {
            if (agent) agent.draw(ctx, vision, trail);
        }
        
        ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
        ctx.font = '10px monospace';
        ctx.fillText(`Step: ${this.step} | Match: ${this.episode} | Goals: ${this.totalGoals}`, 12, this.logicalHeight - 12);
    }
}

const Logger = Object.freeze({
    _escape: (str) => String(str).replace(/[&<>"']/g, m => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#039;' }[m])),
    _truncate: (str, max = 180) => str.length > max ? str.slice(0, max) + '‚Ä¶' : str,
    log: (msg, type = 'info') => {
        const safeMsg = Logger._escape(Logger._truncate(msg));
        const safeType = ['info', 'success', 'warn', 'error', 'learning'].includes(type) ? type : 'info';
        const logEl = document.getElementById('eventLog');
        if (!logEl) { console.log(`[${safeType}] ${safeMsg}`); return; }
        const entry = document.createElement('div');
        entry.className = `log-entry ${safeType}`;
        entry.textContent = `[${new Date().toLocaleTimeString()}] ${safeMsg}`;
        logEl.insertBefore(entry, logEl.firstChild);
        while (logEl.children.length > 30) {
            const child = logEl.lastChild;
            logEl.removeChild(child);
        }
        logEl.scrollTop = 0;
    }
});

class GameEngine {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        if (!this.canvas) { console.error('Canvas element not found'); return; }
        this.ctx = this.canvas.getContext('2d');
        if (!this.ctx) { console.error('Failed to get canvas context'); return; }
        this.logicalWidth = arenaConfig.ARCH.LOGICAL_WIDTH;
        this.logicalHeight = arenaConfig.ARCH.LOGICAL_HEIGHT;
        this.resize();
        this.world = new FootballWorld(this.logicalWidth, this.logicalHeight);
        this.running = false;
        this.lastTime = 0;
        this.fps = 60;
        this.vision = false;
        this.debug = false;
        this.showMetrics = true;
        this.selectedAgent = null;
        this.rafId = null;
        this._onResize = this._onResize.bind(this);
        this._onClick = this._onClick.bind(this);
        this._onKey = this._onKey.bind(this);
        this.setupEvents();
        this.init();
    }

    resize() {
        const parent = this.canvas?.parentElement;
        if (!parent) return;
        
        const aspectRatio = 820 / 600;
        const parentWidth = parent.clientWidth;
        const parentHeight = parent.clientHeight;
        
        if (parentWidth / parentHeight > aspectRatio) {
            this.canvas.height = parentHeight;
            this.canvas.width = parentHeight * aspectRatio;
        } else {
            this.canvas.width = parentWidth;
            this.canvas.height = parentWidth / aspectRatio;
        }
    }

    _onResize() { this.resize(); }

    setupEvents() {
        window.addEventListener('resize', this._onResize);
        const handlePointer = (e) => {
            const rect = this.canvas.getBoundingClientRect();
            const scaleX = this.canvas.width / rect.width;
            const scaleY = this.canvas.height / rect.height;
            const clientX = e.touches?.[0]?.clientX ?? e.clientX;
            const clientY = e.touches?.[0]?.clientY ?? e.clientY;
            const x = (clientX - rect.left) * scaleX;
            const y = (clientY - rect.top) * scaleY;
            this._onClick({ x, y });
        };
        this.canvas.addEventListener('click', handlePointer);
        this.canvas.addEventListener('touchend', handlePointer);
        this.canvas.addEventListener('touchstart', (e) => e.preventDefault(), { passive: false });
        document.addEventListener('keydown', this._onKey);
        this.canvas.setAttribute('tabindex', '0');
        this.canvas.setAttribute('role', 'application');
        this.canvas.setAttribute('aria-label', 'AI Football simulation canvas');
        document.getElementById('btnStart').onclick = () => this.toggle();
        document.getElementById('btnReset').onclick = () => this.reset();
        document.getElementById('btnSave').onclick = () => this.save();
        document.getElementById('btnLoad').onclick = () => this.load();
        document.getElementById('btnExport').onclick = () => this.exportWeights();
        document.getElementById('btnDebug').onclick = () => this.toggleDebug();
        document.getElementById('btnVision').onclick = () => { this.vision = !this.vision; this.updateBtns(); };
        document.getElementById('btnApplyFormation').onclick = () => this.applyFormation();
        document.getElementById('btnRandomTeams').onclick = () => this.randomTeams();
        document.getElementById('fileImport').onchange = (e) => this.importWeights(e);
        const bindSlider = (id, configKey, displayId, callback) => {
            const slider = document.getElementById(id);
            const display = document.getElementById(displayId);
            if (!slider || !display) return;
            slider.oninput = (e) => {
                const value = parseFloat(e.target.value);
                if (!isFinite(value)) return;
                arenaConfig[configKey] = value;
                display.textContent = configKey === 'learningRate' || configKey === 'lambda' ? value.toFixed(3) : value.toFixed(0);
                if (typeof callback === 'function') {
                    try { callback.call(this, value); } catch (err) { console.error(err); }
                }
            };
        };
        bindSlider('learningRate', 'learningRate', 'learningRateValue', (v) => {
            if (this.world?.agents) this.world.agents.forEach(a => { if (a?.net) a.net.lr = v; });
        });
        bindSlider('lambda', 'lambda', 'lambdaValue', (v) => {
            if (this.world?.agents) this.world.agents.forEach(a => { if (a?.net) a.net.lambda = v; });
        });
        bindSlider('mutationRate', 'mutationRate', 'mutationRateValue');
        bindSlider('agentSpeed', 'agentSpeed', 'agentSpeedValue', (v) => {
            if (this.world?.agents) this.world.agents.forEach(a => { if (a) a.speed = v; });
        });
        bindSlider('agentCount', 'agentCount', 'agentCountValue');
        bindSlider('viewRadius', 'viewRadius', 'viewRadiusValue');
        bindSlider('matchDuration', 'matchDuration', 'matchDurationValue');
        const bindToggle = (id, configKey) => {
            const toggle = document.getElementById(id);
            if (toggle) {
                toggle.onchange = (e) => { arenaConfig[configKey] = e.target.checked; };
            }
        };
        bindToggle('enableTraining', 'enableTraining');
        bindToggle('enableEvolution', 'enableEvolution');
        bindToggle('enablePassing', 'enablePassing');
        bindToggle('enableShooting', 'enableShooting');
        bindToggle('enableWeightInheritance', 'enableWeightInheritance');
        bindToggle('enableTactical', 'enableTactical');
        bindToggle('enableHebbian', 'enableHebbian');
        bindToggle('enableConsolidation', 'enableConsolidation');
        bindToggle('enableProfessional', 'enableProfessional');
    }

    _onKey(e) {
        if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code)) e.preventDefault();
        switch (e.key) {
            case ' ': e.preventDefault(); this.toggle(); break;
            case '1': this.selectedAgent = this.world?.agents?.[0]; this.updateDebugPanel(); break;
            case '2': this.selectedAgent = this.world?.agents?.[1]; this.updateDebugPanel(); break;
            case 'Tab': e.preventDefault(); const focusable = document.querySelectorAll('button, input, [tabindex="0"]'), idx = Array.from(focusable).indexOf(document.activeElement); focusable[(idx + 1) % focusable.length]?.focus(); break;
            case 'Escape': if (this.debug) { this.debug = false; this.updateDebugPanel(); } break;
        }
    }

    _onClick({ x, y }) {
        if (!this.debug) return;
        const lx = x / (this.canvas.width / this.logicalWidth), ly = y / (this.canvas.height / this.logicalHeight);
        let nearest = null, minD = 25;
        for (const a of this.world?.agents || []) {
            if (!a) continue;
            const d = Math.hypot(a.x - lx, a.y - ly);
            if (d < minD) { minD = d; nearest = a; }
        }
        this.selectedAgent = nearest;
        if (nearest) Logger.log(`üîç Selected agent ${nearest.id}`, 'info');
        this.updateDebugPanel();
    }

    init() {
        this.world.reset();
        const count = parseInt(document.getElementById('agentCount').value);
        const formation = document.getElementById('formationSelect').value;
        this.world.spawnAgents(count, formation);
        if (arenaConfig.enableProfessional) {
            this.world.initProfessional({
                enableEmotions: arenaConfig.enableProfessional,
                enablePrediction: arenaConfig.enableProfessional,
                enableSharedMap: arenaConfig.enableProfessional
            });
        }
        this.updateAgentList();
        this.updateStats();
        Logger.log('‚öΩ AI Football v8.0.3 Professional initialized', 'success');
    }

    toggle() {
        this.running = !this.running;
        const btn = document.getElementById('btnStart');
        btn.textContent = this.running ? '‚è∏ Pause' : '‚ñ∂ Start';
        btn.className = this.running ? 'btn-danger' : 'btn-primary';
        if (this.running) { this.lastTime = performance.now(); this.loop(); }
    }

    reset() {
        this.running = false;
        document.getElementById('btnStart').textContent = '‚ñ∂ Start';
        document.getElementById('btnStart').className = 'btn-primary';
        this.world = new FootballWorld(this.logicalWidth, this.logicalHeight);
        this.world.reset();
        const count = parseInt(document.getElementById('agentCount').value);
        const formation = document.getElementById('formationSelect').value;
        this.world.spawnAgents(count, formation);
        if (arenaConfig.enableProfessional) {
            this.world.initProfessional({
                enableEmotions: arenaConfig.enableProfessional,
                enablePrediction: arenaConfig.enableProfessional,
                enableSharedMap: arenaConfig.enableProfessional
            });
        }
        this.updateAgentList();
        this.updateStats();
        Logger.log('üîÑ Reset', 'warn');
    }

    loop() {
        if (!this.running) return;
        const now = performance.now();
        const deltaTime = now - this.lastTime;
        if (deltaTime > 250) { this.lastTime = now; this.rafId = requestAnimationFrame(() => this.loop()); return; }
        const dt = Math.min(deltaTime / 16.67, 2);
        this.fps = Math.round(1000 / (deltaTime + 0.001));
        this.lastTime = now;
        document.getElementById('fpsCounter').textContent = `FPS: ${this.fps}`;
        this.world.update(dt);
        this.world.draw(this.ctx, this.vision);
        this.updateStats();
        this.updateMetrics();
        this.updateAgentList();
        if (this.debug) this.updateDebugPanel();
        this.rafId = requestAnimationFrame(() => this.loop());
    }

    updateAgentList() {
        const container = document.getElementById('agentList');
        if (!container || !this.world?.agents) return;
        container.innerHTML = this.world.agents.map(agent => `
            <article class="agent-card ${agent.team}" style="border-left-color: ${agent.color}">
                <header class="agent-header">
                    <span style="color:${agent.color}">‚óè</span>
                    <span>${agent.id.toUpperCase()}</span>
                    <span style="margin-left:auto; font-size:0.5rem; opacity:0.7">${agent.role.toUpperCase()}</span>
                </header>
                <div class="health-bar"><div class="health-fill" style="width:${agent.stamina}%"></div></div>
                <div class="agent-stats"><span>‚ö° <b>${Math.round(agent.stamina)}%</b></span><span>‚öΩ <b>${agent.goals}</b></span></div>
                <div class="role-badge">${agent.role}</div>
            </article>
        `).join('');
    }

    updateStats(state = null) {
        if (!state) state = { episode: this.world.episode, totalGoals: this.world.totalGoals };
        document.getElementById('episodeStat').textContent = state.episode;
        document.getElementById('stepStat').textContent = this.world.step;
        document.getElementById('totalGoalsStat').textContent = state.totalGoals;
        document.getElementById('totalPassesStat').textContent = this.world.totalPasses;
        document.getElementById('matchProgress').style.width = `${(this.world.matchTime / this.world.matchDuration) * 100}%`;
        document.getElementById('scoreBlue').textContent = this.world.score.blue;
        document.getElementById('scoreRed').textContent = this.world.score.red;
        const minutes = Math.floor(this.world.matchTime / 60);
        const seconds = this.world.matchTime % 60;
        document.getElementById('matchTime').textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    }

    updateMetrics() {
        if (!this.world?.agents?.length) return;
        const agents = this.world.agents.filter(a => a && a.alive);
        if (!agents.length) return;
        const avgTD = agents.reduce((s, a) => s + (a.net.getStats().tdErrorHistory?.reduce((x,y)=>x+y,0)/Math.max(1,a.net.getStats().tdErrorHistory?.length || 1) || 0), 0) / agents.length;
        const avgPassAcc = agents.reduce((s, a) => s + (a.passStats.successful / Math.max(1, a.passStats.total)), 0) / agents.length;
        const avgShotAcc = agents.reduce((s, a) => s + (a.shotsOnTarget / Math.max(1, a.totalKicks)), 0) / agents.length;
        const bluePossession = this.world.agents.filter(a => a.team === 'blue' && a.id === this.world.ball.owner).length > 0 ? 1 : 0;
        document.getElementById('metricTDError').textContent = avgTD.toFixed(4);
        document.getElementById('metricPassAcc').textContent = avgPassAcc.toFixed(2);
        document.getElementById('metricShotAcc').textContent = avgShotAcc.toFixed(2);
        document.getElementById('metricPossession').textContent = `${bluePossession * 100}%`;
    }

    updateDebugPanel() {
        const panel = document.getElementById('debugPanel');
        const isActive = this.debug && this.selectedAgent;
        panel.classList.toggle('active', isActive);
        if (!isActive || !this.selectedAgent) return;
        const info = this.selectedAgent.getDebugInfo();
        document.getElementById('debugGrid').innerHTML = Object.entries(info).map(([k, v]) => `<div class="debug-item"><span class="debug-label">${k}</span><span class="debug-value">${v}</span></div>`).join('');
    }

    toggleDebug() {
        this.debug = !this.debug;
        document.getElementById('btnDebug').classList.toggle('active', this.debug);
        this.updateDebugPanel();
    }

    updateBtns() {
        document.getElementById('btnVision').classList.toggle('active', this.vision);
    }

    save() {
        const data = { version: '8.0.3-FOOTBALL-PROFESSIONAL', timestamp: Date.now(), config: { agentCount: document.getElementById('agentCount').value, learningRate: arenaConfig.learningRate, agentSpeed: arenaConfig.agentSpeed, viewRadius: arenaConfig.viewRadius, matchDuration: arenaConfig.matchDuration }, world: { episode: this.world.episode, step: this.world.step, totalGoals: this.world.totalGoals, score: this.world.score }, agents: this.world.agents.map(a => a.toJSON()) };
        localStorage.setItem('aiFootballV8Pro', JSON.stringify(data));
        Logger.log('üíæ Saved', 'success');
    }

    load() {
        const raw = localStorage.getItem('aiFootballV8Pro');
        if (!raw) { Logger.log('‚ùå No save', 'error'); return; }
        let data;
        try {
            data = JSON.parse(raw);
        } catch(e) {
            Logger.log('‚ùå Invalid save file', 'error');
            return;
        }
        const required = ['version', 'agents'];
        if (!required.every(k => k in data)) {
            Logger.log('‚ùå Invalid save format', 'error');
            return;
        }
        if (!Array.isArray(data.agents)) {
            Logger.log('‚ùå Agents must be array', 'error');
            return;
        }
        document.getElementById('agentCount').value = data.config?.agentCount || 3;
        arenaConfig.learningRate = data.config?.learningRate || 0.015;
        arenaConfig.agentSpeed = data.config?.agentSpeed || 10;
        arenaConfig.viewRadius = data.config?.viewRadius || 300;
        arenaConfig.matchDuration = data.config?.matchDuration || 600;
        document.getElementById('learningRateValue').textContent = arenaConfig.learningRate.toFixed(3);
        document.getElementById('agentSpeedValue').textContent = arenaConfig.agentSpeed.toFixed(0);
        document.getElementById('viewRadiusValue').textContent = arenaConfig.viewRadius.toFixed(0);
        document.getElementById('matchDurationValue').textContent = arenaConfig.matchDuration.toFixed(0);
        this.world.episode = data.world?.episode || 1;
        this.world.step = data.world?.step || 0;
        this.world.totalGoals = data.world?.totalGoals || 0;
        this.world.score = data.world?.score || { blue: 0, red: 0 };
        this.world.agents = data.agents?.map((a, i) => FootballAgent.fromJSON(a, i < data.agents.length/2 ? '#00d4ff' : '#ff5577')) || [];
        if (arenaConfig.enableProfessional) {
            this.world.initProfessional({
                enableEmotions: arenaConfig.enableProfessional,
                enablePrediction: arenaConfig.enableProfessional,
                enableSharedMap: arenaConfig.enableProfessional
            });
        }
        this.updateAgentList();
        this.updateStats();
        Logger.log('üìÇ Loaded', 'success');
    }

    exportWeights() {
        const data = { version: '8.0.3-FOOTBALL-PROFESSIONAL', timestamp: Date.now(), agents: this.world.agents.map(a => a.toJSON()) };
        const blob = new Blob([JSON.stringify(data)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href = url; a.download = `football-v8-pro-${Date.now()}.json`; a.click();
        URL.revokeObjectURL(url);
        Logger.log('üì§ Exported', 'success');
    }

    importWeights(e) {
        const file = e.target.files?.[0]; if (!file) return;
        const reader = new FileReader();
        reader.onload = (ev) => {
            try {
                const data = JSON.parse(ev.target.result);
                if (data.version !== '8.0.3-FOOTBALL-PROFESSIONAL' && data.version !== '8.0.2-FOOTBALL-PROFESSIONAL' && data.version !== '8.0.1-FOOTBALL-PROFESSIONAL' && data.version !== '8.0.0-FOOTBALL-PROFESSIONAL' && data.version !== '7.0.0-FOOTBALL-PROFESSIONAL') {
                    throw new Error('Wrong version');
                }
                const required = ['agents'];
                if (!required.every(k => k in data)) throw new Error('Invalid format');
                if (!Array.isArray(data.agents)) throw new Error('Agents must be array');
                this.world.agents = data.agents.map((a, i) => FootballAgent.fromJSON(a, i < data.agents.length/2 ? '#00d4ff' : '#ff5577'));
                if (arenaConfig.enableProfessional) {
                    this.world.initProfessional({
                        enableEmotions: arenaConfig.enableProfessional,
                        enablePrediction: arenaConfig.enableProfessional,
                        enableSharedMap: arenaConfig.enableProfessional
                    });
                }
                this.updateAgentList();
                Logger.log('üì• Imported', 'success');
            } catch (err) { Logger.log(`‚ùå Error: ${err.message}`, 'error'); }
            e.target.value = '';
        };
        reader.readAsText(file);
    }

    applyFormation() {
        const formation = document.getElementById('formationSelect').value;
        const count = parseInt(document.getElementById('agentCount').value);
        this.world.spawnAgents(count, formation);
        if (arenaConfig.enableProfessional) {
            this.world.initProfessional({
                enableEmotions: arenaConfig.enableProfessional,
                enablePrediction: arenaConfig.enableProfessional,
                enableSharedMap: arenaConfig.enableProfessional
            });
        }
        this.updateAgentList();
        Logger.log(`‚úÖ Formation applied: ${formation}`, 'success');
    }

    randomTeams() {
        const formations = Object.keys(FOOTBALL_CONFIG.FORMATIONS);
        const formation = formations[Utils.randInt(0, formations.length - 1)];
        document.getElementById('formationSelect').value = formation;
        this.applyFormation();
    }
}

window.AI_FOOTBALL_DEBUG = Object.freeze({
    getAgent(id) { return window.arenaGame?.world?.agents?.find(a => a.id === id); },
    getTeam(team) { return window.arenaGame?.world?.agents?.filter(a => a.team === team) || []; },
    getBall() { return window.arenaGame?.world?.ball; },
    getStats() {
        const world = window.arenaGame?.world;
        if (!world) return null;
        return {
            step: world.step, episode: world.episode, score: world.score,
            totalGoals: world.totalGoals, totalPasses: world.totalPasses,
            agents: world.agents.length, isMatchOver: world.isMatchOver
        };
    },
    getEmotions(team) {
        const system = window.arenaGame?.world?.teamEmotions?.[team];
        if (!system) return null;
        return {
            morale: system.morale.toFixed(3),
            coherence: system.coherence.toFixed(3),
            pressure: system.pressure.toFixed(3)
        };
    },
    getMentalMap(team, type) {
        const map = window.arenaGame?.world?.sharedMaps?.[team];
        if (!map) return null;
        switch(type) {
            case 'danger': return map.dangerMap;
            case 'opportunity': return map.opportunityMap;
            case 'pressure': return map.pressureMap;
            case 'lanes': return map.passingLanes;
            default: return null;
        }
    },
    predictPass(passerId, receiverId) {
        const passer = this.getAgent(passerId);
        const receiver = this.getAgent(receiverId);
        const world = window.arenaGame?.world;
        if (!passer || !receiver || !world) return null;
        if (!passer._ballPredictor) passer._ballPredictor = new BallPredictor();
        return passer._ballPredictor.calculatePassLead(passer, receiver, world);
    },
    simulateStep(steps = 1) {
        const game = window.arenaGame;
        if (!game || !game.world) return null;
        const results = [];
        for (let i = 0; i < steps; i++) {
            game.world.update(1);
            results.push({
                step: game.world.step,
                ball: { x: game.world.ball.x, y: game.world.ball.y },
                score: { ...game.world.score }
            });
        }
        return results;
    },
    resetAgent(id) {
        const agent = this.getAgent(id);
        if (!agent) return false;
        agent.reset(agent.x, agent.y);
        return true;
    },
    setRole(agentId, newRole) {
        const agent = this.getAgent(agentId);
        if (!agent || !FOOTBALL_ROLES[newRole]) return false;
        agent.role = newRole;
        return true;
    },
    exportState() {
        const game = window.arenaGame;
        if (!game || !game.world) return null;
        return {
            config: { ...arenaConfig },
            world: {
                step: game.world.step, episode: game.world.episode,
                score: { ...game.world.score },
                ball: {
                    x: game.world.ball.x, y: game.world.ball.y,
                    vx: game.world.ball.vx, vy: game.world.ball.vy,
                    owner: game.world.ball.owner
                }
            },
            agents: game.world.agents.map(a => ({
                id: a.id, role: a.role, team: a.team,
                x: a.x, y: a.y, stamina: a.stamina,
                cumulativeReward: a.cumulativeReward
            }))
        };
    },
    help() {
        console.log(`
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë         AI FOOTBALL v8.0.3 PROFESSIONAL - DEBUG CONSOLE      ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë  getAgent(id)           - Get agent by ID                    ‚ïë
‚ïë  getTeam(team)          - Get all agents of team             ‚ïë
‚ïë  getBall()              - Get ball state                     ‚ïë
‚ïë  getStats()             - Get match statistics               ‚ïë
‚ïë  getEmotions(team)      - Get team emotion system state      ‚ïë
‚ïë  getMentalMap(team,t)   - Get shared mental map (danger/etc) ‚ïë
‚ïë  predictPass(p,r)       - Predict pass trajectory            ‚ïë
‚ïë  simulateStep(n)        - Simulate N steps                   ‚ïë
‚ïë  resetAgent(id)         - Reset agent state                  ‚ïë
‚ïë  setRole(id,role)       - Change agent role                  ‚ïë
‚ïë  exportState()          - Export current game state          ‚ïë
‚ïë  help()                 - Show this help                     ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
        `);
    }
});

console.log('üéÆ AI_FOOTBALL_DEBUG available in console. Type AI_FOOTBALL_DEBUG.help() for commands.');

window.arenaGame = null;

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initArena);
} else {
    initArena();
}

function initArena() {
    try {
        window.arenaGame = new GameEngine();
        console.log('‚úÖ AI Football Professional v8.0.3 initialized');
        console.log('üß† Cortex-2 Neural Network: 64 inputs ‚Üí 16 outputs');
        console.log('‚öΩ Professional Mode: Roles, Emotions, Prediction, Collective Intelligence');
        console.log('üéØ Features: BallPredictor, TeamEmotionSystem, SharedMentalMap');
    } catch (e) {
        console.error('‚ùå Init error:', e);
        alert('Error initializing AI Football: ' + e.message);
    }
}

window.addEventListener('beforeunload', () => {
    if (window.arenaGame) {
        window.arenaGame.running = false;
        if (window.arenaGame.rafId) {
            cancelAnimationFrame(window.arenaGame.rafId);
        }
        window.arenaGame = null;
    }
});

window.addEventListener('error', (event) => {
    console.error('Global error:', event.error);
    Logger.log(`‚ùå Error: ${event.error?.message || 'Unknown error'}`, 'error');
    
    if (window.arenaGame?.running) {
        window.arenaGame.running = false;
        document.getElementById('btnStart').textContent = '‚ñ∂ Start';
        document.getElementById('btnStart').className = 'btn-primary';
        Logger.log('üîÑ Game paused due to error', 'warn');
    }
});

window.addEventListener('unhandledrejection', (event) => {
    console.error('Unhandled promise rejection:', event.reason);
    Logger.log(`‚ùå Promise Error: ${event.reason?.message || 'Unknown'}`, 'error');
});

document.addEventListener('visibilitychange', () => {
    if (document.hidden && window.arenaGame?.running) {
        console.log('üì¥ Tab hidden - game still running');
    }
});

window.addEventListener('beforeunload', (e) => {
    if (window.arenaGame?.running && window.arenaGame.world?.step > 100) {
        e.preventDefault();
        e.returnValue = '';
        return '';
    }
});

console.log('‚úÖ AI Football Professional v8.0.3 ‚Äî PATCHED: ball physics, possession, vision, movement');
console.log('üîß Cortex-2 architecture PRESERVED: P32‚ÜíA64‚ÜíM144‚ÜíC256‚ÜíS32‚ÜíD16');
</script>
</body>
    </html>
